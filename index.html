<html>
<head>
<meta name="viewport" content="width=device-width,initial-scale=.25"></meta>
<script>
var isMobile=false;
</script>
<script src="detectMobile.js"></script>
<style>
.bm{
font-size:40px;
font-family:monospace;
visibility:visible;
position:relative;
background-color:#ffffff;
padding:30px;
border:1px solid #000000;
margin:3px;
margin-left:-1px;
margin-right:-1px;
}
.tm{
width:30%;
border-bottom:1px solid #cdcdcd;
margin:0px;
font-size:40px;
}
.tm2{
width:70%;
border-bottom:1px solid #cdcdcd;
margin:0px;
padding:4px;
padding-left:0px;
font-size:40px;
}

.b{
font-size:18px;
font-family:monospace;
visibility:visible;
position:relative;
background-color:#ffffff;
padding:11px;
border:1px solid #000000;
margin-right:-4px;
margin-left:-4px;
display:inline-block;
}
.t{
width:25%;
border-bottom:1px solid #cdcdcd;
margin:0px;
font-size:22px;
}
.t2{
width:75%;
border-bottom:1px solid #cdcdcd;
margin:0px;
padding:4px;
padding-left:0px;
font-size:22px;
}

.s{
padding:10px;
font-size:20px;
display:inline-block;
width:110px;

}

.sm{
padding:20px;
font-size:30px;
display:inline-block;
width:150px;
}


.pzm{
display:inline-block;
font-size:60px;
padding:20px;
width:200px
}

.pz{
display:inline-block;
font-size:20px;
padding:20px;
width:100px;
}


.vs{
display:inline-block;
font-size:40px;
padding:10px;
width:150px;
}


.vsm{
display:inline-block;
font-size:60px;
padding:20px;
width:200px;
}

html{
-moz-text-size-adjust:none;
-webkit-text-size-adjust:none;
text-size-adjust:none;
}

.container::-webkit-scrollbar{display:none;}
.container{
-ms-overflow-style:none;
scrollbar-width:none;
}

</style>
</head>
<body id="bodyer" style="font-family:monospace;overflow:hidden;margin:0px;padding:0px;touch-action:none;visibility:hidden;display:block;">
<script>
var supportsPointer='onpointerdown' in window;
var isTouchDevice='ontouchstart' in window;
var usePHP=true; 
//var serverAddress='http://moygen.rf.gd/graph2/';
var serverAddress='http://172.18.11.218:45267/';
//var serverAddress='http://0.0.0.0:45267/';
//var serverAddress='http://48.52.212.109:45267/';
//var serverAddress='http://localhost/graph2/';

var fileContent=null;
var graphData='';
var showSolving=false;
var stepping=false;
var solved=false;
var solving=false;
var pauser=false;
var streamSolving=true;
var loading=false;
var setRandomVerts=false;
var loadDataFileNameAtStart=!setRandomVerts;
var dataFileName="pentagon.txt";
var numPoints=0;
var isLive=serverAddress.indexOf('moygen');
if(isLive>=0){
showSolving=true;
streamSolving=true;
loading=true;
numPoints=60;
}else{
showSolving=false;
streamSolving=false;
loading=true;
numPoints=60;
}

var zoomFactor=1;
var vertSize=35;
var fonter=30;
var diam=110;
var randOnlySome=.29;

var scaleFactor=1;
var EPSILON=1.0e-6;
var Vertex;
var Triangle;
var Edge;
var triangulate;
var edges;
var vertices;
var triangles;
var vertPairs;
var pairString='';
var fourColor=["red","gold","MediumSeaGreen","DeepSkyBlue","white"];
var fourColorShort=['R','Y','G','B','W'];
var savedData=[];
var triColors=[];
var dragging=false;
var altKey=false;
var inset=125;
var vertexToEdit=-1;
var backgroundColor='#f5f5f5';
var numSavedGraphs=0;
var graphFileNames=[];
var dataSend='';
var finishedSavingFile=false;
var getDataInterval=0;
var stringArr=[];
var pairArr=[];
var segPoints=[];
var segCounter=0;
var settingSegPoints=[];
var curvedLinkStart=-1;
var curvedLinkEnd=-1;
var gettingCurvedLinkStart=false;
var gettingCurvedLinkEnd=false;
var tapMessageShown=false;
var sortedVerts=[];
var counter=0;
var colorSavedGraph=false;
var xray=false;
var sameColorVerts=[];
var highlightSame=true;
var sortString='';
var searcher=[];
var lastSearcher=[];
var nonNeighbor=[];
var numSolves=0;
var randomDropping=false;
var solveCounter=0;
var chunkSolveString='';
var allSolvesString='';
var nIndexString='';
var loopingDetected=false;
var solveRemainingPass=0;
var loopCounter=0;
var tripleCheck=false;
var framesPerSecond=120;
var stillSearching=false;
var showNumNeigh=false;
var animId=0;

var showSolvingTime=false;
var totalSolveTime=0;
var startSolveTime=[];
var endSolveTime=[];
var numPauses=0;

var lastButton='buildRandomGraph';
var savedButtonId=lastButton;
var savedLastButton=lastButton;
var messageTimer=0;
var building=false;
var flexibles=[];
var showFlexibles=true;
var flexibleColor='#db37d9';
var numSolvesCounter=0;
var flexiblesCount=0;
var diffColorPairsCount=0;
var sameColorPairsCount=0;
var zoomFactor=.8;
var zoomInFactor=1.1;
var zoomOutFactor=.9; 
var zoomingIn=false;
var zoomingOut=false;
var centerX=0;
var centerY=0;
var panning=false;
var lastTouchX=null;
var lastTouchY=null;
var targetRatio=.075;
var defaultRatio=targetRatio;
var vertSizeDecrease=false;
var vertSizeIncrease=false;
var lastShuffleButton='restoreNativeButton';
var vertSortType='';
var savedVertSortType=vertSortType;
var b_shuffleRandomTimed=false;
var b_restoreNativeTimed=false;
var b_sort2DTimed=false;
var b_sortOutInTimed=false;
var b_sortInOutTimed=false;
var b_sorterByNeighsTimed=false
var shuffledVertices=[];
var nativeVertOrder=[];
var nativePairArr=[];
var sortedVerts2D=[];
var sorterByNeighCount=[];
var gettingLinkStart=false;
var addingVert=false;
var linkStart=-1;
var linkEnd=-1;
var startConnecting=false;
var endConnecting=false;
var delaunay=true;
var moveRaw=false;
var solveTimer=0;clearTimeout(solveTimer);
var animateTimer=0;clearTimeout(animateTimer);
var typing=false;
var resizeCanv=false;
var selectedLineWidth=40;
var modifiedGraph=false;

var waitFilenamesInt=0;
var waitFileLoad=0;
var waitGraphDataInt=0;

var listNeighsFontSize=25;
var listNeighsLineHeight=30;

//green=#daf5e4
var B={blue:'#dbedff',red:'#ffd7d4',green:'#dff3e9',white:'#ffffff'};
//bcf5da

</script>


<div id="sortControls" style="font-size:35px;z-index:1000000;position:fixed;left:0px;bottom:0px;background-color:#ffffff;padding-left:0px;padding-right:15px;padding-top:10px;padding-bottom:10px;border:6px solid #000000;display:none;text-align:center;line-height:60px;">Sort vertices to change solve order:
<br>

<div id="sortLabelShowSolve" style="display:inline-block;font-size:20px;font-family:monospace;text-align:right;padding-left:6px;margin-right:-16px;">&nbsp;Anim:
</div> 

<div style="padding-bottom:8px;display:inline-block;">
 
<input class="s" id="shuffleRandomButton" value="Random" type="button">

<input class="s" id="restoreNativeButton" value="Native" type="button">

<input class="s" id="sort2DButton" value="2D" type="button">

<input class="s" id="sortOutInButton" value="OutIn" type="button">

<input class="s" id="sortInOutButton" value="InOut" type="button">

<input class="s" id="sortByNeighborCountButton" value="Neighs" type="button">
</div><br>

<div id="sortLabelTimedSort" style="display:inline-block;font-size:20px;font-family:monospace;text-align:right;padding-left:6px;margin-right:-16px;">Timed:
</div>

<div style="padding:0px;display:inline-block;">
 
<input class="s" id="shuffleRandomTimed" value="Random" type="button">

<input class="s" id="restoreNativeTimed" value="Native" type="button">

<input class="s" id="timedSort2D" value="2D" type="button">

<input class="s" id="timedSortOutIn" value="OutIn" type="button">

<input class="s" id="timedSortInOut" value="InOut" type="button">

<input class="s" id="timedSortByNeighborCount" value="Neighs" type="button">

<input id="sortsClose" value=" X " type="button"  style="display:inline-block;font-size:30px;padding:10px;position:absolute;right:0px;top:0px;">
</div>
</div>

<div id="messageHolder" style="position:absolute;left:450px;top:500px;padding:60px;border:8px solid black;display:none;z-index:1000000;background-color:white;">

<div id="message" style="display:block;white-space:nowrap;font-family:monospace;font-weight:bold;color:black;font-size:40px;">
</div>
</div>


<canvas id="canvas" width="440" height="550" style="position:absolute;left:0px;top:0px;z-index:100;"></canvas>


<div class="container" id="shortcutKeys" style="background-color:white;position:absolute;left:30px;top:30px;z-index:10000;border:2px solid black;display:none;overflow:auto;padding:10px;margin:0px;">
 
<div id="shortcutKeysHeading" style="border:2px solid black;color:white;background-color:#000000;font-family:monospace;padding:10px;margin:0px;position:fixed;left:30px;top:30px;z-index:10001;font-size:40px;">
<b>Shortcut Keys:</b>

<div id="shortcutCloser" style="text-align:center;color:#bbbbbb;top:6px;right:6px;font-size:20px;color:black;padding-bottom:8px;padding-left:8px;padding-right:8px;height:18px;width:18px;background-color:#dddddd;border: 2px solid #bbbbbb;position:absolute;font-family:monospace;">x</div>
</div>
<div style="background-color:#ffffff;font-family:monospace;padding:10px;display:block;">
<br><br>
<table >
<tr><td class="t" style="padding-top:40px;">
[P]: Anim Solving </td><td class="t2" style="padding-top:40px;">Renders each step of the 4-coloring algorithm as it solves the graph
</td></tr>
<tr><td class="t">
[6]: Stream Solve Current Graph</td><td class="t2">Repeatedly solve current graph
</td></tr>
<tr><td class="t">
[7]: Stream Solve Random Graphs</td><td class="t2">Continuously solve random graphs
</td></tr>
<tr><td class="t">[S]: Solve </td><td class="t2">Renders result of solve and displays time in milliseconds
</td></tr>
<tr><td class="t">[V]: Step </td><td class="t2">Advance one step of algorithm solving at a time 
</td></tr>
<tr><td class="t">[B]: Build Random Graph </td><td class="t2">Build a random graph with delaunay triangulation
</td></tr>
<tr><td class="t">[H]: Show/Hide Buttons </td><td class="t2">Show/Hide buttons for all functions
</td></tr>
<tr><td class="t">[A]: Add Vertex </td><td class="t2">Click on graph to add a vertex with delaunay triangulation connecting it to surrounding Vertices
</td></tr>
<tr><td class="t">[M]: Move Vertex </td><td class="t2">Click on a vertex and drag it to move it with delaunay triangulation adjusting connections 
</td></tr>
<tr><td class="t">[D]: Delete Vertex </td><td class="t2">Click on a vertex to delete it with delaunay triangulation modifying surrounding connections
</td></tr>
<tr><td class="t">[C] Color Vertex </td><td class="t2">Click on a vertex to change the color in cycles of red, yellow, green and blue
</td></tr>
<tr><td class="t">[N] Number of Vertices</td><td class="t2">Set number of vertices
</td></tr>
<tr><td class="t">[F] Frames Per Second</td><td class="t2">Set frames per second of animation when showing Solving
</td></tr>
<tr><td class="t">[T] Time to Solve</td><td class="t2">Display time to solve in milliseconds and number of steps
</td></tr>
<tr><td class="t">[G] Number of Neighbors</td><td class="t2">Display numbers of neighbors on each vertex
</td></tr>
<tr><td class="t">[X] Flexibles</td><td class="t2">Highlight the vertices which can be another color and list possible colors
</td></tr>
<tr><td class="t">[O] Console</td><td class="t2">Enter a variable and hit enter to see the value of a global variable
</td></tr>
<tr><td class="t">[1] Add Vertex<br>(no delaunay)</td><td class="t2">Click the graph to add a vertex without delaunay triangulation
</td></tr>
<tr><td class="t">[2] Add a Linked Vertex<br>(no delaunay)</td><td class="t2">Click a starting vertex and then a free space to add a linked vertex without delaunay triangulation
</td></tr>
<tr><td class="t">[3] Link Vertices<br>(no delaunay)</td><td class="t2">Click a vertex to which to link, and then another vertex to link them, without delaunay triangulation
</td></tr>
<tr><td class="t">[4] Move a Vertex<br>(no delaunay)</td><td class="t2">Click a vertex and drag to move a vertex without delaunay triangulation
</td></tr>
<tr><td class="t">[5] Delete a Vertex<br>(no delaunay)</td><td class="t2">Click a vertex to delete it without any delaunay triangulation
</td></tr>
<tr><td class="t">[W] Toggle Fullscreen</td><td class="t2">Toggle Fullscreen
</td></tr>
<tr><td class="t">[Y] Tester Display</td><td class="t2">In the source javascript, use da('testerHolder',variable); to overwrite tester; use daa... to append writes
</td></tr>
<tr><td class="t">[K] Shortcut Keys</td><td class="t2">Toggle shortcut key list with descriptions
</td></tr>
<tr><td class="t">[L] Load Graph</td><td class="t2">Load a graph file (someName.txt) from the server
</td></tr>
<tr><td class="t">[E] Save Graph</td><td class="t2">Save a graph file (someName.txt) to the server
</td></tr>
<tr><td class="t">[8] Pan Zoom</td><td class="t2">Pan and Zoom the graph
</td></tr>
<tr><td class="t">[R] Rotate Graph</td><td class="t2">Rotate the graph
</td></tr>
<tr><td class="t">[I] Vertex Size</td><td class="t2">Increase/Decrease vertex size
</td></tr></table>
</div>
</div>



<div id="selectGraphHolder" style="z-index:10000000;display:none;position:absolute;bottom:0px;left:100px;">
 
<select id="selectGraph" onchange="loadFile();" style="font-size:30px;font-family:monospace;background-color:#ffffff;border:6px solid #000000;padding:30px;">
<option id="selectGraphOption" style="font-size:30px;font-family:monospace;" disabled value="" id="label">Load Graph</option>
</select>

<input id="closeSelect" value="X" type="button" style="color:#000000;font-size:30px;font-family:monospace;background-color:#ffffff;border:6px solid #000000;padding:30px;margin-left:-12px;">
</div>

<!--
<div id="fpsInputDiv" style="bottom:0px;white-space:nowrap;font-size:25px;font-family:monospace;z-index:1000000;position:absolute;left:100px;background-color:#ffffff;padding:20px;padding-right:40px;border:6px solid #000000;height:40px;visibility:hidden;">

<div id="selectGraphHolder" style="z-index:10000000;display:none;position:absolute;top:100px;left:50px;">
 
<select id="selectGraph" onchange="loadFile();" style="font-size:30px;font-family:monospace;background-color:#ffffff;border:6px solid #000000;padding:30px;">
<option id="selectGraphOption" style="font-size:30px;font-family:monospace;" disabled value="" id="label">Load Graph</option>
</select>

<input id="closeSelect" value="X" type="button" style="color:#000000;font-size:30px;font-family:monospace;background-color:#ffffff;border:6px solid #000000;padding:30px;margin-left:-12px;">
</div>
-->



<div id="filenameInputDiv" style="z-index:1000000000;position:fixed;left:50px;bottom:0px;font-size:30px;font-family:monospace;background-color:#ffffff;padding:40px;padding-top:20px;border:4px solid black;display:none;height:80px;">


Filename:
<input id="enterGraphName" type="text" value="" style="display:inline-block;font-family:monospace;color:black;font-size:30px;border:1px solid black;" size="30">

<br>

<input id="saveFile" value="save" type="button" style="display:inline-block;font-size:30px;margin-top:12px;">

<input id="cancelSave" value="cancel" type="button" style="display:inline-block;font-size:30px;margin-top:12px;">

</div>


<div id="testerHolder" style="font-size:25px;font-family:monospace;display:none;color:#00ff00;background-color:black;position:absolute;left:40px;top:40px;z-index:10000000000;border:6px solid white;overflow-y:auto;overflow-x:hidden;padding:20px;word-wrap:break-word;">
</div> 

<input type="button" value="X" id="testerCloser" style="text-align:center;color:#bbbbbb;top:60px;right:-20px;font-size:40px;color:black;padding:0px;height:50px;width:50px;background-color:#dddddd;border:4px solid #bbbbbb;position:absolute;z-index:1000000000000;font-family:monospace;display:none;">



<div id="consoleInputDiv" style="z-index:10000000000;position:absolute;left:30px;top:30px;font-size:30px;font-family:monospace;background-color:#ffffff;padding:30px;border:4px solid #000000;visibility:hidden;">
 
Enter Javascript:
<textarea rows="14" cols="45" id="consoleInput" type="text" style="left:0px;font-family:Monospace;color:#00ff00;background-color:#000000;font-size:30px;word-wrap:break-word;width:100%">JSON.stringify(triangles)</textarea>
<br>
<input id="consoleEnterButton" value=" Enter " type="button" style="display:block;font-size:30px;padding:10px;right:40px;position:absolute;">
<br>
Output:<br>
<div id="consoleScroller" style="width:100%;height:50%;display:block;font-size:30px;background-color:black;overflow:auto;">
 
<div id="consoleOutput" style="margin:20px;font-size:30px;background-color:black;color:#00ff00;word-wrap:break-word;">

 
</div>


<input type="button" id="consoleCloser" style="bottom:10px;right:40px;font-size:40px;font-family:monospace;position:absolute;border:2px solid black;" value="x">
 
</div>
</div>
 




<div id="buttonHolder" style="left:0px;margin:0px;text-align:left;white-space:wrap;z-index:1000;position:fixed;background-color:#ffffff;padding:6px;bottom:0px;overflow:hidden;display:block;touch-action:none;width:100%">
 
<div id="buttonHolderInner" style="width:100%;">
 
<input id="about" type="button" value="About" class="b">


<input id="streamSolve" type="button" value="stream"  class="b" title="[7]">

<input id="showSolving" type="button" value="AnimSolving" class="b" title="[P] or spacebar">

<input id="solve" type="button" value="Solve"  class="b" title="[S]">

<input id="step" type="button" value="Step" class="b" title="[ V ]">

<input id="solveData" type="button" value="SolveData" class="b" title="[8]">


<input id="buildRandomGraph" type="button" value="BuildGraph" class="b" title="[B]">

<input id="addVertexDelaunay" type="button" value="AddVert" class="b" title="[A]">

<input id="moveVertexDelaunay" type="button" value="MoveVert" class="b" title="[M]">

<input id="deleteVertexDelaunay" type="button" value="DeleteVert" class="b" title="[D]">

<input id="colorVertsButton" type="button" value="ColorVert" class="b" title="[C]">

<input id="numVertsButton" type="button" value="NumVerts" class="b" title="[N]">

<input id="fpsId" type="button" value="FPS"  class="b" title="[F]">
<!--
<input id="timeToSolveId" type="button" value="Time" class="b" title="[T]">
-->
<input id="neighs" type="button" value="Neighs" 
 class="b" title="[G]">

<input type="button" value="Flexibles" id="flexiblesButton" class="b" title="[X]" style="display:none">

<input id="dropRandom" type="button" value="Random" class="b">

<input id="loadGraphButton" type="button" value="load"  class="b" title="[L]">

<input id="saveGraphButton" type="button" value="save"  class="b" title="[E]">


<input type="button" value="reload" id="reloadGraphButton" class="b" style="display:none;">


<input type="button" value="Tester" id="testerButton" class="b" title="[Y]" style="display:inline-block;">

 
<input type="button" value="Console" id="consoleButton" class="b" title="[O]" style="display:inline-block">


<input type="button" value="add" id="addButton"
 class="b" title="[1]">

<input type="button" value="addLinked" id="addLinkedButton" class="b" title="[2]">

<input type="button" value="Link" id="linkVertsButton" class="b" title="[3]">

<input type="button" value="curvedLink" id="addCurveButton" class="b" title="[0]">

<input id="moveVertButton" type="button" value="Move" class="b" title="[4]">

<input id="deleteVertButton" type="button" value="Delete" class="b" title="[5]">


<input type="button" value="rotate" id="rotateButton" class="b" title="[6]">

<input type="button" value="panZoom" id="panZoomButton" class="b">

<input id="vertSizeButton" type="button" value="VertSize" class="b" style="display:inline-block;">

<input type="button" value="Sorts" id="sortsButton" class="b" style="display:inline-block;">

<input type="button" value="genVerts" id="gen2Button" class="b">

<input id="clear" type="button" value="Clear" class="b" title="[9]">


<input id="keysButton" type="button" value="Keys" class="b" title="[K]">


<input id="defaultTouchButton" type="button" value="DefaultTouch" class="b" title="[]">

</div><!--end buttonHolder Inner-->

</div><!--end buttonHolder Outer-->




<input type="button" value="K" id="shortcuts"  style="color:#000000;text-align:center;right:4px;position:fixed;font-weight:bold;font-size:30px;font-family:monospace;white-space:nowrap;background-color:#ffffff;padding:6px;border:1px solid #000000;bottom:102px;z-index:1000000000;visibility:visible;width:50px;height:44px;margin:0px;display:block;" title="[K]">
 
<input type="button" value="[]" id="fullscreen"  style="color:#000000;text-align:center;right:4px;position:fixed;font-weight:bold;font-size:24px;font-family:monospace;white-space:nowrap;background-color:#ffffff;padding:8px;border:1px solid #000000;bottom:52px;z-index:1000000000;visibility:visible;width:50px;height:44px;margin:0px;vertical-align:top;display:block;" title="[W]">


<input type="button" value="-" id="expander"  style="color:#000000;text-align:center;right:4px;position:fixed;font-weight:bold;font-size:20px;font-family:monospace;white-space:nowrap;background-color:#ffffff;padding:6px;border:1px solid #000000;bottom:4px;z-index:100000000000;visibility:visible;width:50px;height:42px;margin:0px;" title="[H]">

<!--
<input type="button" value="-" id="expander"  style="color:#000000;text-align:center;right:0px;position:fixed;font-weight:bold;font-size:65px;font-family:monospace;white-space:nowrap;background-color:#ffffff;padding:20px;border:1px solid #000000;bottom:0px;z-index:100000000000;visibility:visible;width:120px;margin:0px;" title="[H]">
--> 



<div id="numVertsInputDiv" style="font-size:25px;font-family:monospace;visibility:hidden;z-index:1000000;position:fixed;bottom:0px;background-color:#ffffff;padding:15px;border:6px solid #000000;height:50px;">

Number of Vertices:
<input id="enterNumVerts" type="text"  size="3" value="60" style="background-color:black;caret-color:white;font-family:monospace;color:white;font-size:25px;padding:5px">

<input id="numVertsApply" value="Apply" type="button" style="display:inline-block;font-size:25px;padding:5px;">

<input id="numVertsCancel" value="cancel" type="button" style="display:inline-block;font-size:25px;padding:5px;">

</div>

<!--
<div id="fpsInputDiv" style="white-space:nowrap;font-size:25px;font-family:monospace;z-index:1000000;position:absolute;left:100px;background-color:#ffffff;padding:20px;padding-right:40px;border:6px solid #000000;height:50px;visibility:hidden;"> 
-->


<div id="fpsInputDiv" style="bottom:0px;white-space:nowrap;font-size:25px;font-family:monospace;z-index:1000000;position:absolute;left:100px;background-color:#ffffff;padding:20px;padding-right:40px;border:6px solid #000000;height:40px;visibility:hidden;"> 

FPS (1-60):
<input id="enterFPS" type="text"  size="3" value="" style="font-family:monospace;color:white;font-size:25px;padding:5px;background-color:black;">

<input id="fpsApply" value="Apply" type="button" style="display:inline-block;font-size:25px;padding:5px;">

<input id="fpsCancel" value="cancel" type="button" style="display:inline-block;font-size:25px;padding:5px;">

</div>




<div id="panZoomControls" style="font-size:30px;font-family:monospace;line-height:100px;z-index:1000000;position:fixed;left:200px;bottom:0px;background-color:#ffffff;padding:80px;padding-top:20px;padding-bottom:20px;border:6px solid #000000;display:none;">
 <center>PanZoom Controls:</center>
 
<input id="fitButton" value="FIT" type="button" class="pz">

<input id="zoomOutButton" value=" - " type="button" class="pz">

<input id="zoomInButton" value=" + " type="button" class="pz">

<input id="panButton" value="PAN" type="button"  class="pz">

<input id="panZoomClose" value=" X " type="button"  style="display:inline-block;font-size:15px;padding:10px;position:absolute;right:0px;top:0px;">
</div>


<div id="vertSizeControls" style="font-size:50px;font-family:monospace;line-height:100px;z-index:1000000;position:fixed;left:200px;bottom:0px;background-color:#ffffff;padding:80px;padding-top:20px;padding-bottom:20px;border:6px solid #000000;display:none;">
 
 <center>VertSize Controls:</center>

<input id="vertSizeResetButton" value="Reset" type="button" class="vs">

<input id="vertSizeDownButton" value=" - " type="button" class="vs">

<input id="vertSizeUpButton" value=" + " type="button" class="vs">

<input id="vertSizeCloseButton" value=" X " type="button" style="display:inline-block;font-size:15px;padding:10px;position:absolute;right:0px;top:0px;">
</div>




<div class="container" id="aboutDiv" style="background-color:white;position:absolute;left:12px;top:12px;z-index:10000;border:6px solid black;display:none;overflow:auto;padding:0px;margin:0px;">
 
<div id="aboutDivHeading" style="border:2px solid black;color:white;background-color:#000000;font-family:monospace;padding:10px;margin:0px;left:0px;top:0px;z-index:10001;font-size:12px;width:100%">
<b>A Javascript 4-Coloring Program</b>
<div id="aboutCloser" style="text-align:center;color:#bbbbbb;top:0px;right:10px;font-size:30px;color:black;padding:4px;height:38px;width:38px;background-color:#dddddd;border:2px solid #bbbbbb;position:absolute;font-family:monospace;">X
</div>
</div>

<div id="aboutDivBody" style="background-color:#ffffff;font-family:addVertDelaunay;padding:30px;font-size:9px;text-align:justify;line-height:13px;">
The github files are here:<br>
<a href="https://github.com/thismain/Four-Color-Theorem-Coloring-Tester" target="_blank">https://github.com/thismain/Four-Color-Theorem-Coloring-Tester</a>
<br><br>
The live Desktop demo is here:<br>
<a href="http://moygen.rf.gd/graph2/desktop.html" target="_blank">http://moygen.rf.gd/graph2/desktop.html</a>
<br><br>
The live Mobile demo is here:<br>
<a href="http://moygen.rf.gd/graph2/index.html" target="_blank">http://moygen.rf.gd/graph2/index.html</a>
<br><br>
<img id="screenshot" src="screenshotter.png">
<br><br>
This is a javascript program for four coloring any graph. It has solved hundreds of 600 or fewer vertices. The lowest time to solve for 600 vertices was 22ms, though the average is around 300ms. I use delaunay triangulation, from <a href="https://travellermap.com/tmp/delaunay.js" target="_blank">Joshua Bell's code</a>, to generate random graphs, and these graphs may be modified, either with or without delaunay triangulation. 
<br><br>
The best part of this program, I think, is watching the animation of the algorithm solving the graph at a human observable speed. 
<br><br>
<b>The algorithm:</b><br>
I recently found a faster way. I had been sorting the vertices by number of neighbors, and using high priority colors on vertices of high degree of connectivity, which would get colored first, and low priority colors on vertices of low degree of connectivity, which would get colored last. However, It turns out, it's faster to just go through the vertices as they were set down when building the graph, from the top of the screen to the bottom, applying colors in the same order each time, when they can be applied without conflict.
<br><br>
After the algorithm has gone through the whole graph this way, it then goes back to the vertices for which no color was available. It searches the neighbors of the uncolored vertex for the neighbors with the fewest fellows of their own color. If there are more than one neighbors with only one fellow of the same color, the algorithm chooses the neighbor of the highest priority color. The algorithm assigns the color of that neighbor to the uncolored vertex and then repeats the same process for that neighbor, excluding the vertex which just took its color. 
<br><br>
When the algorithm goes into a loop of following the same circuit over and over, it kicks itself out of the loop with a random choice of either the second or third choice of neighbors from which to take a color, where the neighbors have been sorted by the number of fellows of the same color. 
<br><br>
Finally, the algorithm triple checks the graph for any neighboring vertices of the same color and proceeds in the same manner to fix them.
<br><br>
The reason I made this program is because I wanted to find out why the 4CT is true, and I reasoned that the best way to find that out would be to see why the algorithms that work do work, and how they can be made to work less well and broken. 
<br><br>
I wonder whether a neural network can learn from billions of correctly colored graphs to recognize patterns in strings of permutations of numbers of neighbors and immediately know what colors the vertices can be. So it would solve the graph the way a rubik's cube is solved, rather than searching for the correct solution in real time.
<br><br>
<hr>
<br>
What would a sufficient reason require? Obviously, it would need to explain why five colors are never necessary, but it would also need to show why three colors are sometimes not possible, and what are the conditions that must occur for a three-colorable graph to become a four-colorable one. An analysis of how a graph can, or must, be modified to go from requiring only three colors, to requiring four colors, and also from two to three, and from one to two, would be useful. I'd love to identify and parameterize some property or properties of planar graphs that results in the flexibility we find in assigning colors. But for such a property to be proven to be the operative four-coloring mechanism one would need to show that only the coloring algorithms that exploit this property work, and algorithms that do not exploit this property do not work, and those that only partly make use of this property only partly work. Which task would require that one had first set up the environment for testing several and various algorithms, so as to compare and rate their performance. To this end I imagine identifying the complete set of discrete components which comprise every four coloring algorithm, and from this set of modules choosing, and their parameters adjusting in turn, so as to evaluate the change in effectiveness wrought thereby.
<br><br>
In reality my code is very messy, but still I dream.
<br><br>
What might those modules be? Let's number them:
<br><br>
1) Sorting nodes by numbers of neighbors<br>
2) Assigning the four colors levels of priority<br>
3) Sorting neighbors by number of a color<br>
4) Behavior when no color is available<br>
5) Color transfer from neighbor to uncolored<br> node, or to a conflicted node<br>
6) Loop detection and breaking<br>
7) Self checking the result<br>
8) Order of coloring<br>
9) ...
<br><br>
It turns out to have been unnecessary to worry about complexity increasing with increasing numbers of vertices and with increasing numbers of connections for each node. The hardest graph anyone can contrive will be trivial to color by a sufficient algorithm. There's always enough flexibility in the choice of colors so as to allow for changing colors along a path until a node is encountered that is only neighbored by nodes of two colors, or by one. I think it's worthwhile to mention at the start of anyone's exposure to the 4CT that if four colors are randomly dropped onto one thousand randomly built graphs, the ratio of differently colored neighbors to same colored neighbors averages out to three to one; three differently colored neighbors for every one that is the same color, or 75% different, 25% same.
<br><br>
<hr>
<br>

After solving graphs manually and watching the algorithm solve graphs in a similar way, one develops an intuition for the reason the four color theorem is true. But articulating this feeling requires much ratiocination and accounting for all possible cases, not to mention a careful definition of terms along the way, which often interferes with the flow of the logic of one's argument. Then also, any exposition which does not rest upon quantifiable statstical relationships rings hollow. It's easy to suppose that there's a certain minimum degree of flexibility which is common to all four-colored planar graphs, where flexibility is defined as the option to be one or two colors other than one's own, without conflict. But it's not so easy to statistically quantify this minimum degree of flexibility. Everyone can see that conflicted nodes can be resolved by swapping colors along a path toward a flexible node, and it also becomes obvious that this flexibility is deriving from the inevitable isolation of every node from the rest of the graph by its neighbors. But how can one show, without testing every possible kind of case, that this local principle of isolation will always yield enough flexibility to four-color any graph?
<br><br>
</div>
</div>
 




<div class="container" id="data" style="background-color:white;position:absolute;left:30px;top:30px;z-index:10000;border:2px solid black;display:none;height:70%;overflow:auto;padding:10px;margin:0px;">
 
<div id="dataHeading" style="border:2px solid black;color:white;background-color:#000000;font-family:monospace;padding:10px;margin:0px;position:fixed;left:30px;top:30px;z-index:10001;font-size:30px;">
<b>Random Drop of Colors: Data for Analysis:</b>

</div>
<div style="background-color:#ffffff;font-family:monospace;padding:10px;padding-top:60px;">
<br><br><br>
<table id="tableId" style="width:100%;"></table>
</div>

</div>

<div id="dataShowHideButton" style="display:none;text-align:center;color:#bbbbbb;top:12px;right:12px;font-size:30px;color:black;padding-top:1px;padding-bottom:5px;padding-left:8px;padding-right:8px;height:30px;width:30px;background-color:#dddddd;border: 2px solid #bbbbbb;position:absolute;font-family:monospace;z-index:100002;">-</div>


<script>


function el(a){return document.getElementById(a);}
function da(a,b){if(el(a)){el(a).innerHTML=b;
//el(a).style.display='block';
}}

function daa(a,b){
if(isThere(el(a))){
el(a).innerHTML+=b;
}//if(isThere(el(a))){
}//function daa(a,b){


function daar(a,b){
if(isThere(el(a))){
el(a).innerHTML=b+el(a).innerHTML;
}//if(isThere(el(a))){
}//function daar(a,b){

function randRange(min, max){return Math.floor(Math.random() * (max - min + 1)) + min;}
function degToRad(a){return a*Math.PI/180;}
function isThere(a){return(typeof a!=="undefined"&&typeof a!==null&&(a||a==0));}
function els(a){return document.getElementById(a).style;}
function elc(a){return document.getElementsByClassName(a);}
function showHide(a){if(els(a).display=='block'){els(a).display='none'}else{els(a).display='block'}}

function showHideV(a){if(els(a).visibility=='visible'){els(a).visibility='hidden'}else{els(a).visibility='visible'}}

var savedStringVars='';
 
//testVars("maxx",maxx,"cW",cW,"maxy",maxy,"cH",cH,"scaleFactorY",scaleFactorY,"scaleFactorX",scaleFactorX);
function testVars(...args){
let stringVars='';
for(let i=0;i<args.length;i++){
if(i==0||i%2==0){
stringVars+=args[i]+': '+args[i+1]+'<br>';
}
}//end i loop
daar('testerHolder',stringVars+'<br>');
}//end testVars



function zoom(elm,scale,w,h){ 

elm.style.transform="scale("+scale+")";
elm.style.transformOrigin="top left";
elm.style.width=(w/scale)+"%";
elm.style.height=(h/scale)+"%";

}//end zoom




var replaceMoveEventById;
var replaceUpEventById;
var replaceDownEventById;


if(supportsPointer){ 
replaceMoveEventById=function(id,func,event){
el(id).onpointermove=function(event){func(event);}}
replaceUpEventById=function(id,func,event){
el(id).onpointerup=function(event){func(event);}}
replaceDownEventById=function(id,func,event){
if(!isThere(el(id))){alert(id);}
el(id).onpointerdown=function(event){func(event);}}

}else if(isTouchDevice){
replaceMoveEventById=function(id,func,event){
el(id).ontouchmove=function(event){func(event);}}
replaceUpEventById=function(id,func,event){
el(id).ontouchend=function(event){func(event);}}
replaceDownEventById=function(id,func,event){
if(!isThere(el(id))){alert(id);}
el(id).ontouchstart=function(event){func(event);}}

}else{
replaceMoveEventById=function(id,func,event){
el(id).onmousemove=function(event){func(event);}}
replaceUpEventById=function(id,func,event){
el(id).onmouseup=function(event){func(event);}}
replaceDownEventById=function(id,func,event){
if(!isThere(el(id))){alert(id);}
el(id).onmousedown=function(event){func(event);}}
}



function reSolverReset(){
solving=false;
solved=false;
showSolving=false;
//showSolvingStatus();
pairString='';
numSolves=0;
solveCounter=0;
chunkSolveString='';
loopingDetected=false;
nIndexString='';
solveRemainingPass=0;
tripleCheck=false;
pairString='';
allSolvesString='';
}//end resolver reset


function activeButton(buttonId){
el(buttonId).style.backgroundColor='#dbedff';

if(lastButton=='zoomInButton'||lastButton=='zoomOutButton'||lastButton=='fitButton'||lastButton=='panButton'){
el(lastButton).style.backgroundColor='#eeeeee';

}else if(lastButton!='defaultTouchButton'&&lastButton!=buttonId
&&!((solving&&lastButton=='solve')||(showSolving&&lastButton=='showSolving'))){
el(lastButton).style.backgroundColor='#ffffff';
}


else if(lastButton=='solve'&&(buttonId=='showSolving'||buttonId=='step'||buttonId=='streamSolve')){
el('solve').style.backgroundColor='#ffffff';
el('solve').value='Solve';
}


if(lastButton=='showSolving'&&(buttonId=='solve'||buttonId=='step'||buttonId=='streamSolve')){
el('showSolving').style.backgroundColor='#ffffff';
el('showSolving').value='AnimSolving';
}

savedButtonId=buttonId;
savedLastButton=lastButton;
lastButton=buttonId;
 
if(lastButton!='dropRandom'){el('dataShowHideButton').style.display='none';el('data').style.display='none';}
if(lastButton!='about'){el('aboutDiv').style.display='none';}
if(lastButton!='curvedLink'&&gettingCurvedLinkEnd){
gettingCurvedLinkStart=false;
gettingCurvedLinkEnd=false;
curvedLinkStart=-1;
curvedLinkEnd=-1;
segPoints[pairArr.length]=null;
settingSegPoints[pairArr.length]=false;
segCounter=0;
render();
}//end if(lastButton!='curvedLink'

if(lastButton!='linkVertsButton'){
startConnecting=false;
gettingLinkStart=false;
endConnecting=false;
}//if(lastButton!='link'){

}//activeButton




function activeShuffleButton(buttonId){
el(lastShuffleButton).style.backgroundColor='#eeeeee';
el(buttonId).style.backgroundColor='#dbedff';
lastShuffleButton=buttonId;
}//activeShuffleButton

activeShuffleButton('restoreNativeButton');


window.onresize=function(){setTimeout("render();",200);};


function setDataShowHideButton(){
let dataRect=el('data').getBoundingClientRect();
el('dataShowHideButton').style.right=parseInt(ww-dataRect.width-16)+'px';
el('dataShowHideButton').style.top=parseInt(dataRect.top+6)+'px';
el('dataShowHideButton').style.display='block';
//alert(el('dataShowHideButton').style.right);
}//end setDataShowHideButton


var canv=document.getElementById("canvas");
var ctx=canv.getContext('2d');
var cW,cH,ww,hh;

ww=window.innerWidth;
hh=window.innerHeight;
canv.width=window.innerWidth;
canv.height=window.innerHeight;
cW=canv.width;
cH=canv.height;
canv.style.width=cW+"px";
canv.style.height=cH+"px";
canv.style.left='0px';
canv.style.touchAction='none';
if(scaleFactor!=1){
vertSize=vertSize*scaleFactor;
scaleFactor=1;
}


//`/script><script src='modStyles.js'>/script><script`


function changeClass(oldClass,newClass){
for(let i=elc(oldClass).length-1;i>=0;i--){
elc(oldClass)[i].classList.add(newClass);
elc(oldClass)[i].classList.remove(oldClass);
}
}//changeClass

/*
var bhRect=el('buttonHolder').getBoundingClientRect();
var bhHeight=bhRect.height;
var bhBottom=bhRect.bottom;
var bhTop=bhRect.top;
*/

var bhStyle=getComputedStyle(el('buttonHolder'));
var bhStyleHeight=parseInt(bhStyle.height);
var bhStyleTop=parseInt(bhStyle.top);

function modStyles(){
els('buttonHolder').width=ww+'px';
els('buttonHolderInner').width=ww+'px';

bhStyle=getComputedStyle(el('buttonHolder'));
bhStyleTop=parseInt(bhStyle.top);

els('shortcutKeys').height=bhStyleTop-70+'px';

els('screenshot').width=ww*.85+'px';

els('shortcutKeys').width=ww*.91+'px';
els('shortcutKeysHeading').width=ww*.91+'px';

els('messageHolder').left=ww*.5-220+'px';
els('messageHolder').top=hh*.23+'px';
els('messageHolder').border='8px solid black';


if(isTouchDevice){
els('defaultTouchButton').display='inline-block';
}else{
els('defaultTouchButton').display='none';
}



if(isMobile){

changeClass('b','bm');
changeClass('t','tm');
changeClass('t2','tm2');
changeClass('s','sm');
changeClass('pz','pzm');
changeClass('vs','vsm');

els('data').width=ww*.95+'px';
els('dataHeading').width=ww*.95+'px';
els('dataHeading').fontSize=50+'px';

els('keysButton').display='none';
els('fullscreen').display='none';
els('shortcuts').display='none';

els('expander').fontSize='65px';
els('expander').padding='20px';
els('expander').width='120px';
els('expander').height='120px';

els('message').fontSize='60px';

els('sortControls').paddingLeft='0px';
els('sortControls').left='0px';
els('sortControls').paddingRight='110px';
els('sortControls').paddingTop='20px';
els('sortControls').paddingBottom='40px';
els('sortControls').fontSize='45px';
els('sortControls').lineHeight='105px';
els('sortLabelShowSolve').fontSize='30px';
els('sortLabelTimedSort').fontSize='30px'; 
els('sortsClose').fontSize='40px';

els('panZoomControls').fontSize='50px';
els('panZoomControls').lineHeight='100px';
els('panZoomClose').fontSize='60px';

els('vertSizeControls').fontSize='50px';
els('vertSizeControls').lineHeight='100px';
els('vertSizeCloseButton').fontSize='60px';

els('buttonHolder').width=ww+'px';
els('buttonHolderInner').width=ww+'px';
bhStyle=getComputedStyle(el('buttonHolder'));
bhStyleTop=parseInt(bhStyle.top);
bhStyleHeight=parseInt(bhStyle.height);

els('selectGraph').fontSize='40px';
els('selectGraphOption').fontSize='40px';
els('closeSelect').fontSize='40px';
els('selectGraphHolder').bottom=bhStyleHeight+60+'px';
centerDiv('selectGraphHolder');


els('consoleInputDiv').width=ww*.90+'px';
els('consoleInputDiv').height=bhStyleTop-100+'px';
els('consoleInputDiv').fontSize='50px';
els('consoleInput').fontSize='40px';
els('consoleEnterButton').fontSize='40px';
els('consoleEnterButton').right='40px';
els('consoleCloser').width='70px';
els('consoleCloser').height='70px';
els('consoleCloser').bottom='40px';
els('consoleCloser').right='40px';
els('consoleCloser').fontSize='50px';
els('consoleOutput').fontSize='40px';

els('aboutDiv').width=ww*.95+'px';
els('aboutDiv').height=bhStyleTop*.95+'px';
els('aboutDivBody').fontSize='38px';
els('aboutDivBody').lineHeight='46px';
els('aboutDivHeading').fontSize='45px';
els('aboutCloser').width='60px';
els('aboutCloser').height='60px';
els('aboutCloser').fontSize='50px';
els('aboutCloser').padding='2px';

el('fpsInputDiv').style.bottom=bhStyleHeight+160+'px';
el('numVertsInputDiv').style.bottom=bhStyleHeight+160+'px';
el('filenameInputDiv').style.bottom=bhStyleHeight+260+'px';

zoom(el('filenameInputDiv'),2,80,12);
zoom(el('numVertsInputDiv'),2,80,4);
zoom(el('fpsInputDiv'),2,60,4);

els('testerHolder').width=ww*.91+'px';
els('testerHolder').height=bhStyleTop-100+'px';
els('testerHolder').fontSize='35px';
els('testerCloser').right='60px';
els('testerCloser').fontSize='40px';
els('testerCloser').width='80px';
els('testerCloser').height='80px';

listNeighsFontSize=50;
listNeighsLineHeight=60;




}else if(!isMobile){

els('data').width=ww*.91+'px';
els('dataHeading').width=ww*.91+'px';


els('buttonHolder').width=ww+'px';
els('buttonHolderInner').width=ww*.95+'px';
bhStyle=getComputedStyle(el('buttonHolder'));
bhStyleTop=parseInt(bhStyle.top);
bhStyleHeight=parseInt(bhStyle.height);

els('panZoomControls').fontSize='30px';
els('panZoomControls').lineHeight='60px';
els('panZoomClose').fontSize='30px';

els('vertSizeControls').fontSize='30px';
els('vertSizeControls').lineHeight='60px';
els('vertSizeCloseButton').fontSize='30px';

els('selectGraph').fontSize='30px';
els('selectGraphOption').fontSize='30px';
els('closeSelect').fontSize='40px';
els('selectGraphHolder').bottom=bhStyleHeight+60+'px';
centerDiv('selectGraphHolder');

els('consoleInputDiv').width=ww*.87+'px';
els('consoleInputDiv').height=bhStyleTop-140+'px';
els('consoleInputDiv').fontSize='30px';
els('consoleEnterButton').right='40px';
els('consoleCloser').width='50px';
els('consoleCloser').height='50px';
els('consoleCloser').bottom='10px';
els('consoleCloser').right='40px';
els('consoleCloser').fontSize='36px';


el('fpsInputDiv').style.bottom=bhStyleHeight+60+'px';
el('numVertsInputDiv').style.bottom=bhStyleHeight+60+'px';
el('filenameInputDiv').style.bottom=bhStyleHeight+90+'px';

els('aboutDiv').width=ww*.95+'px';
els('aboutDiv').height=bhStyleTop*.95+'px';
els('aboutDivBody').fontSize='21px';
els('aboutDivBody').lineHeight='26px';
els('aboutDivHeading').fontSize='28px';
els('aboutCloser').width='30px';
els('aboutCloser').height='30px';
els('aboutCloser').fontSize='25px';
els('aboutCloser').padding='1px';


els('testerHolder').width=ww*.87+'px';
els('testerHolder').height=bhStyleTop-100+'px';
els('testerHolder').fontSize='25px';
els('testerCloser').right='60px';
els('testerCloser').fontSize='40px';
els('testerCloser').width='50px';
els('testerCloser').height='50px';

listNeighsFontSize=30;
listNeighsLineHeight=40;


}//}else if(!isMobile){


}//modStyles





function controlPanelOpenClose(){
if(el('buttonHolder').style.display=='none'){
el('buttonHolder').style.display='block';
el('expander').value='-';
}else{
el('buttonHolder').style.display='none';
el('expander').value='+';
}
}//end controlPane lOpenClose
 



async function getGraphFilenames(){
graphFileNames=null;
try{
const response=await fetch(serverAddress+'filenameReader.php');

if(!response.ok){
showMessage(`<center>HTTP Error 1:<br>`+response.status+`</center>`,50000);
throw new Error(`HTTP Error 1: ${response.status}`);
//console.error('HTTP Error 1:', response.status);
//alert('HTTP Error 1:<br>'+response.status);
}//if(!response.ok){

graphFileNames=await response.json();
if(isThere(graphFileNames)){
numSavedGraphs=graphFileNames.length;
initSelectGraph();

}//if(isThere(graphFileNames)){

}catch(error){
showMessage('<center>Fetching Error 1:<br>'+ error+`</center>`,50000);
throw new Error(`Fetching Error 1: ${error}`);
//console.error('Fetching Error 1: ', error);
//alert(`Fetching Error 1:<br>`+error);
}
}//async function getGraphFilenames(){






function initSelectGraph(){
for(let i=0;i<numSavedGraphs;i++){
let op=document.createElement("option");
op.id='op'+i;
op.value=i;
op.text=graphFileNames[i];

if(op.text==dataFileName){
op.selected='selected';
}

el('selectGraph').appendChild(op);
}//end i loop
//el('op0').selected="selected";
}//end init select graph







async function loadTextFile(filePath){
try{
const response=await fetch(filePath);
if(!response.ok){
showMessage(`<center>HTTP Error 2:<br>`+response.status+`</center>`,50000);
throw new Error(`HTTP Error 2: ${response.status}`);
//console.error('HTTP Error 2:', response.status);
//alert('HTTP Error 2:<br>'+response.status);
}
const text=await response.text();
return text;
}catch(error){
showMessage(`<center>Loading Error 1:<br>`+error+`</center>`,50000);
throw new Error(`Loading Error 1: ${error}`);
//console.error('Loading Error 1:', error);
//alert(`Loading Error 1:<br>`+error);
return null;
}//catch
}//async function loadTextFile(filePath){





async function processFile(fileName){

showMessage('Loading Graph...',60000000);
fileContent=await loadTextFile(fileName);

solved=false;

if(isThere(fileContent)){

reSolverReset();

if(fileContent.indexOf('[')>=0){
delaunay=false;

segPoints=[];
let segPointString='';
let segPointsCopy=[];

if(fileContent.lastIndexOf('] [[')>=0){

segPointString=fileContent.substring(0,fileContent.lastIndexOf('] [[')+1);

segPoints=JSON.parse(segPointString);

segPointsCopy=JSON.parse(JSON.stringify(segPoints));

if(isThere(segPoints)){
fileContent=
fileContent.replace(segPointString+' ','');
}
}//end if(fileContent.


let pairArrString=fileContent.substring(0,fileContent.lastIndexOf(']')+1);
pairArr=JSON.parse(pairArrString);


fileContent=
fileContent.replace(pairArrString+' ','');

if(isThere(segPointsCopy)){
for(let i=0;i<pairArr.length;i++){
segPoints[i]=null;
for(let m=0;m<segPointsCopy.length;m++){
if(segPointsCopy[m][0].pairIndex==i){
segPoints[i]=JSON.parse(JSON.stringify(segPointsCopy[m]));
}//==
}//end m loop 
}//end i loop
}//if(isThere(segPoints)){


}//if(fileContent.indexOf('[')>=0){


stringArr=fileContent.split(" ");

for(let i=0;i<stringArr.length;i+=4){
vertices.push(new Vertex(parseInt(stringArr[i]),parseInt(stringArr[i+1]),parseInt(stringArr[i+2]),parseInt(stringArr[i+3]),[],0,false,false,false,parseInt(stringArr[i+3])));

if(delaunay){
triangles=triangulate(vertices);
}
}//end i loop

fileContent=null;
sortByNeighborCount();
nativeVertOrder=[...vertices];
nativePairArr=[...pairArr];
graphRotater(90);
graphRotater(-90);
modifiedGraph=true;
hideMessage(messageTimer);
}//end isThere


}//async function processFile(fileName){




function loadFile(){
hideMessage(messageTimer);
showMessage('Loading Graph...',60000000);
setRandomVerts=false;
dataFileName=graphFileNames[parseInt(el('selectGraph').options[el('selectGraph').selectedIndex].value)];
buildAndRender();
}//onChangeLoadFile




function saveFileButtonActions(event){
el('filenameInputDiv').style.display='none';
showMessage('Saving Graph...',60000000);
setTimeout(`
typing=false;
dataFileName=el('enterGraphName').value+'.txt';
saveGraphData();
`,10);
}//saveFileButtonActions
replaceDownEventById('saveFile',saveFileButtonActions);




function saveGraphData(){
if(usePHP){
graphData='';
for(let i=0;i<vertices.length;i++){
graphData+=parseInt(vertices[i].x)+' '+parseInt(vertices[i].y)+' '+vertices[i].c+' '+vertices[i].i;
if(i<vertices.length-1){graphData+=' ';}
}//end i loop

if(!delaunay){
removeDuplicatePairs();
let segPointsCopy=[];
for(let i=0;i<segPoints.length;i++){
segPointsCopy[i]=segPoints[i];
}//end i loop
let sp='';
if(isThere(segPointsCopy)){
for(let i=segPointsCopy.length-1;i>=0;i--){
if(!isThere(segPointsCopy[i])){
segPointsCopy.splice(i,1);
}
}//end i loop

for(let i=0;i<segPointsCopy.length;i++){
if(isThere(segPointsCopy[i])){
for(let s=0;s<segPointsCopy[i].length;s++){
segPointsCopy[i][s].x=parseInt(segPointsCopy[i][s].x);
segPointsCopy[i][s].y=parseInt(segPointsCopy[i][s].y);
}//s loop
}//isThere
}//end i loop

sp=JSON.stringify(segPointsCopy)+' ';
}
graphData=sp+JSON.stringify(pairArr)+' '+graphData;
}


postTextFile();


if(!el('op'+numSavedGraphs)){
graphFileNames.push(dataFileName);
let op=document.createElement("option");
op.id='op'+numSavedGraphs;
op.value=numSavedGraphs;
op.text=dataFileName;
el('selectGraph').appendChild(op);
numSavedGraphs++;
}//end if(!el


}//usePHP
}//end saveGraphData



async function postTextFile(){
showMessage('Saving Graph...',60000000);

let response=await fetch(serverAddress+"saver.php?saving=1&dataFileName="+dataFileName,
{
method:'POST',
headers:{'Content-Type':'text/plain'},
body:graphData
})
.then(response=>{
if(!response.ok){
showMessage(`HTTP error! status:${response.status}`,2000);
}
return response.text(); 
})
.then(data=>{

showMessage('<center>Graph Saved as:<br><br>'+dataFileName+'</center>',2000);
})
.catch(error=>{
alert('Error saving file:', error);
});//fetch
}//postTextFile(url,file){




function graphRotater(angle){
let margin=vertSize*2;


let graphAng=-90*Math.PI/180;
if(isThere(angle)){
graphAng=angle*Math.PI/180;
}


for(let i=0;i<segPoints.length;i++){
if(isThere(segPoints[i])){
for(let s=0;s<segPoints[i].length;s++){
if(isThere(segPoints[i][s])){
let dist=Math.sqrt(segPoints[i][s].y*segPoints[i][s].y+segPoints[i][s].x*segPoints[i][s].x);

let ang=Math.atan2(segPoints[i][s].y,segPoints[i][s].x);
ang+=graphAng; 
segPoints[i][s].y=Math.sin(ang)*dist;
segPoints[i][s].x=Math.cos(ang)*dist;
}//if(isThere(segPoints[i][s])){
}//end s loop
}//if(isThere(segPoints[i]))
}//end i loop



for(let i=0;i<vertices.length;i++){
let dist=Math.sqrt(vertices[i].y*vertices[i].y+vertices[i].x*vertices[i].x)
let ang=Math.atan2(vertices[i].y,vertices[i].x);
ang+=graphAng;
vertices[i].y=Math.sin(ang)*dist;
vertices[i].x=Math.cos(ang)*dist;
}//end i loop


let miny=100000;
let minx=100000;
let maxy=-100000;
let maxx=-100000;


for(let i=0;i<segPoints.length;i++){
if(isThere(segPoints[i])){
for(let s=0;s<segPoints[i].length;s++){
if(segPoints[i][s].y<miny){miny=segPoints[i][s].y;}
if(segPoints[i][s].x<minx){minx=segPoints[i][s].x;}
}//end s loop
}//if(isThere(segPoints[i]))
}//end i loop


for(let i=0;i<vertices.length;i++){
if(vertices[i].y<miny){miny=vertices[i].y;}
if(vertices[i].x<minx){minx=vertices[i].x;}
}//end i loop



for(let i=0;i<segPoints.length;i++){
if(isThere(segPoints[i])){
for(let s=0;s<segPoints[i].length;s++){

segPoints[i][s].y-=miny-margin;
segPoints[i][s].x-=minx-margin;

}//end s loop
}//if(isThere(segPoints[i]))
}//end i loop


for(let i=0;i<vertices.length;i++){
vertices[i].y-=miny-margin;
vertices[i].x-=minx-margin;
}



for(let i=0;i<segPoints.length;i++){
if(isThere(segPoints[i])){
for(let s=0;s<segPoints[i].length;s++){

if(segPoints[i][s].y>maxy){maxy=segPoints[i][s].y;}
if(segPoints[i][s].x>maxx){maxx=segPoints[i][s].x;}

}//end s loop
}//if(isThere(segPoints[i]))
}//end i loop


for(let i=0;i<vertices.length;i++){
if(vertices[i].y>maxy){maxy=vertices[i].y;}
if(vertices[i].x>maxx){maxx=vertices[i].x;}
}//end i loop



let wRatio=(cW-margin)/(maxx+margin);//((maxx+margin)-(minx-margin));
let hRatio=(cH-margin)/(maxy+margin);//((maxy+margin)-(miny-margin));


for(let i=0;i<segPoints.length;i++){
if(isThere(segPoints[i])){
for(let s=0;s<segPoints[i].length;s++){
if(isThere(segPoints[i][s])){
if(wRatio<hRatio){
segPoints[i][s].x*=wRatio;
segPoints[i][s].y*=wRatio;
}else{
segPoints[i][s].x*=hRatio;
segPoints[i][s].y*=hRatio;
}
}//if(isThere(segPoints[i][s])){
}//end s loop
}//if(isThere(segPoints[i]))
}//end i loop


for(let i=0;i<vertices.length;i++){
if(wRatio<hRatio){
vertices[i].x*=wRatio;
vertices[i].y*=wRatio;
}else{
vertices[i].x*=hRatio;
vertices[i].y*=hRatio;
}
}//end i loop

sorterSwitch();
vertScaler();
render();

}//end graphRotater






function changeVertexColor(event){
if(isThere(vertices[vertexToEdit])){
vertices[vertexToEdit].c++;
if(vertices[vertexToEdit].c>3){
vertices[vertexToEdit].c=0;
}
render();
}//is There
}// end changeVertexColor


function eventUp(event){
event.preventDefault();
if(dragging){vertexToEdit=-1;}
dragging=false;
panning=false;
zoomingOut=false;
zoomingIn=false;
el('expander').style.visibility='visible';
render();
}//end eventUp
replaceUpEventById('canvas',eventUp);


function eventMove(event){
event.preventDefault();
if(dragging){
el('expander').blur();
if(moveRaw){
moveVertex(event,delaunay=false);
}else{
moveVertex(event,delaunay=true);
}
sortByNeighborCount();
render();
}//if(dragging)
else if(panning){
el('expander').blur();
panner(event);
}//if(panning)
else if(zoomingIn||zoomingOut){
centerX=event.pageX;
centerY=event.pageY;
}
}//end eventMove
replaceMoveEventById('canvas',eventMove)



function eventSwitch(event){
let eventer='';
if(supportsPointer){
eventer=event;
}else if(isTouchDevice){
eventer=event.touches[0];
}else{
eventer=event;
}
return eventer;
}//eventSwitch


function aboutAction(event){
event.preventDefault();
activeButton('about');
showHide('aboutDiv');
}//aboutAction
replaceDownEventById('about',aboutAction);



function aboutCloserAction(event){
event.preventDefault();
showHide('aboutDiv');
}//aboutCloserAction
replaceDownEventById('aboutCloser',aboutCloserAction);

function shortcutCloserAction(event){
event.preventDefault();
activeButton('shortcutCloser');
showHide('shortcutKeys');
}//shortcutCloserAction
replaceDownEventById('shortcutCloser',shortcutCloserAction);


function enterGraphNameAction(event){
typing=true;
}//enterGraphNameAction
replaceDownEventById('enterGraphName',enterGraphNameAction);




function showSolvingButton(){
activeButton('showSolving')

if(!pauser&&showSolving){
el('showSolving').value='AnimSolving';
el('showSolving').style.backgroundColor=B.green;

}else if(pauser&&showSolving){
el('showSolving').value='Anim Paused';
el('showSolving').style.backgroundColor=B.red;
}


el('solve').style.backgroundColor='#ffffff';
el('solve').value='Solve';


stepping=false;
solving=false;
showSolving=true;
showSolvingStatus();
solveButtonStatus();
}//end showSolvingButton
 


function showSolvingStatus(){

if(!showSolving&&lastButton!='showSolving'){
el('showSolving').value='AnimSolving';
el('showSolving').style.backgroundColor=B.white;

}else if(!showSolving&&lastButton=='showSolving'){
el('showSolving').value='AnimSolving';
el('showSolving').style.backgroundColor=B.blue;
}

if(streamSolving){
el('streamSolve').style.backgroundColor=B.green;

}else if(!streamSolving){
el('streamSolve').style.backgroundColor=B.white;
}

}//end showSolvingStatus



function showSolvingActions(event){ 
if(isThere(event)){event.preventDefault();}
activeButton('showSolving');

if(savedLastButton!='showSolving'){
replaceDownEventById('canvas',showSolvingActions);
}

sorterSwitch();


if(!showSolving){

if(!stepping&&!solving){
reSolverReset();
for(let v=0;v<vertices.length;v++){
vertices[v].c=4;}
}

numPauses=0;
totalSolveTime=0;
startSolveTime=[];
endSolveTime=[];
solved=false;
stepping=false;
pauser=false
solving=false;
showSolving=true;
startSolveTime.push(Date.now());
if(showSolvingTime){updateSolveData();}


}else if(showSolving&&!pauser){
pauser=true;
endSolveTime[numPauses]=Date.now();
numPauses++;

}else if(showSolving&&pauser){
pauser=false;
startSolveTime.push(Date.now());
endSolveTime.push(Date.now());
if(showSolvingTime){updateSolveData();}
}

showSolvingButton();
}//end showSolvingActions
replaceDownEventById('showSolving',showSolvingActions);




function streamSolvingActions(event){
if(isThere(event)){event.preventDefault();}
activeButton('streamSolve');

replaceDownEventById('canvas',showSolvingActions);

streamSolving=!streamSolving; 
if(streamSolving){
showSolving=true;
solved=false;
for(let v=0;v<vertices.length;v++){
vertices[v].c=4;}
}//if(streamSolving){
showSolvingButton();
}// end streamSolvingActions
replaceDownEventById('streamSolve',streamSolvingActions);





function solveButton(){
//activeButton('solve');  

if(!pauser&&solving){
el('solve').value='Solve';
el('solve').style.backgroundColor=B.green;

}else if(pauser&&solving){
el('solve').value='Pause';
el('solve').style.backgroundColor=B.red;
}


el('showSolving').style.backgroundColor='#ffffff';
el('showSolving').value='AnimSolving';

el('streamSolve').style.backgroundColor='#ffffff';
}//end solveButton




function solveButtonStatus(){
if(solving&&solved){
el('solve').value='Solve';
el('solve').style.backgroundColor=B.blue;
}
}//solveButtonStatus




function solveActions(event){
if(isThere(event)){event.preventDefault();}
activeButton('solve');
//setTimeout(`
if(savedLastButton!='solve'){
replaceDownEventById('canvas',solveActions);
}


if(!solving&&pauser){pauser=false;}

if(!solving){
if(streamSolving){streamSolvingActions();}

if(!stepping&&!solving){
reSolverReset();
for(let v=0;v<vertices.length;v++){
vertices[v].c=4;}
}

render();

numPauses=0;
totalSolveTime=0;
startSolveTime=[];
endSolveTime=[];
solved=false;
stepping=false;
solving=true;
showSolving=false;

maxCallStackSizeExceeded=false;

}else if(solving&&!pauser&&stepping){

stepping=false;
solving=true;

}else if(solving&&!pauser){
pauser=true;
endSolveTime[numPauses]=Date.now();
numPauses++;

}else if(solving&&pauser){
pauser=false;
}

if(b_shuffleRandomTimed){
shuffleRandomVertices();
b_shuffleRandomTimed=false;
}else if(b_restoreNativeTimed){
restoreNativeVertOrder();
b_restoreNativeTimed=false;
}else if(b_sort2DTimed){
sort2D();
b_sort2DTimed=false;
}else if(b_sortOutInTimed){
sortRadial('outIn');
b_sortOutInTimed=false;
}else if(b_sortInOutTimed){
sortRadial('inOut');
b_sortInOutTimed=false;
}else if(b_sorterByNeighsTimed){
sorterByNeigh();
b_sorterByNeighsTimed=false;
}

if(solving&&!pauser){
startSolveTime.push(Date.now());
endSolveTime.push(Date.now());
if(showSolvingTime){updateSolveData();}
recursiveNeighborSolver();
}//if(solving&&!pauser

solveButton();
//`,20);
}//end solveActions
replaceDownEventById('solve',solveActions);




function updateSolveData(){
if((solving||showSolving)&&!pauser&&!solved){

totalSolveTime=0;
endSolveTime[numPauses]=Date.now();
for(let q=0;q<startSolveTime.length;q++){
totalSolveTime+=
(endSolveTime[q]-startSolveTime[q]);
}//q loop

}//if(solving&&!pauser&&!solved){

let vertsPerMs=(vertices.length/(totalSolveTime)).toFixed(2);
if(vertsPerMs=='Infinity'){vertsPerMs=0;}
let solvedOrNot='';
if(solved){solvedOrNot=`<center><span style="background-color:MediumSeaGreen;color:white;display:block;font-family:Monospace;width:250px;padding:15px">Solved</span></center><br>`;}
showMessage(solvedOrNot+
`Solve Data:<br> `+totalSolveTime+` ms<br>`
+(totalSolveTime/1000).toFixed(2)+' sec<br>'
+(totalSolveTime/1000/60).toFixed(2)+' min<br>'
+ numSolvesCounter+` steps<br>`
+(vertices.length)+` Vertices<br>`
//+(totalSolveTime/(vertices.length)).toFixed(2)+` ms/numVerts<br>`
+vertsPerMs+` verts/ms<br><br><center>[close]</center>`,2000000);

}//updateSolveData




function stepActions(event){
event.preventDefault();
activeButton('step');
if(!showSolving&&solved&&!stepping){
reSolverReset();
for(let v=0;v<vertices.length;v++){
vertices[v].c=4;}
}//end if(!showSolving&
pauser=false;
solved=false;
stepping=true;
showSolving=false;
recursiveNeighborSolver();
render();
showSolvingStatus();
replaceDownEventById('canvas',stepActions);
}//end stepActions
replaceDownEventById('step',stepActions);




function solveTimeActions(event){
if(isThere(event)){event.preventDefault();}
//activeButton('solveData');
if(!showSolvingTime){
el('solveData').style.backgroundColor=B.blue;
showSolvingTime=true;
updateSolveData();
}else if(showSolvingTime){
el('solveData').style.backgroundColor=B.white;
showSolvingTime=false;
hideMessage();
}

}//solveTimeActions
replaceDownEventById('solveData',solveTimeActions);


function sortsButtonActions(event){
event.preventDefault();
activeButton('sortsButton');
showHide('sortControls');
el('sortControls').style.left=
centerDiv('sortControls');
}//sortsButtonActions
replaceDownEventById('sortsButton',sortsButtonActions);


 
function shuffleRandomActions(event){
event.preventDefault();
activeShuffleButton('shuffleRandomButton');
clearActions();
shuffleRandomVertices();
showSolvingActions(event);
}//shuffleRandomActions
replaceDownEventById('shuffleRandomButton',shuffleRandomActions);

 
function restoreNativeActions(event){
event.preventDefault();
activeShuffleButton('restoreNativeButton');
clearActions();
restoreNativeVertOrder();
showSolvingActions(event);
}//restoreNativeActions
replaceDownEventById('restoreNativeButton',restoreNativeActions);

 
function sort2DActions(event){
event.preventDefault();
activeShuffleButton('sort2DButton');
clearActions();
sort2D();
showSolvingActions(event);
}//sort2DActions
replaceDownEventById('sort2DButton',sort2DActions);

 
function sortOutInActions(event){
event.preventDefault();
activeShuffleButton('sortOutInButton');
clearActions();
sortRadial('outIn');
showSolvingActions(event);
}//sortOutInActions
replaceDownEventById('sortOutInButton',sortOutInActions);

 
function sortInOutActions(event){
event.preventDefault();
activeShuffleButton('sortInOutButton');
clearActions();
sortRadial('inOut');
showSolvingActions(event);
}//sortInOutActions
replaceDownEventById('sortInOutButton',sortInOutActions);

 
function sortByNeighborCountActions(event){
event.preventDefault();
activeShuffleButton('sortByNeighborCountButton');
clearActions();
sorterByNeigh();
showSolvingActions(event);
}//sortByNeighborCountActions
replaceDownEventById('sortByNeighborCountButton',sortByNeighborCountActions);



 
function shuffleRandomTimedActions(event){
event.preventDefault();
activeShuffleButton('shuffleRandomTimed');
b_shuffleRandomTimed=true;
solveActions(event);
}//shuffleRandomTimedActions
replaceDownEventById('shuffleRandomTimed',shuffleRandomTimedActions);

 
function restoreNativeTimedActions(event){
event.preventDefault();
activeShuffleButton('restoreNativeTimed');
b_restoreNativeTimed=true;
solveActions(event);
}//restoreNativeTimedActions 
replaceDownEventById('restoreNativeTimed',restoreNativeTimedActions);

 
function sort2DTimedActions(event){
event.preventDefault();
activeShuffleButton('timedSort2D');
b_sort2DTimed=true;
solveActions(event);
}//sort2DTimedActions 
replaceDownEventById('timedSort2D',sort2DTimedActions);

 
function sortOutInTimedActions(event){
event.preventDefault();
activeShuffleButton('timedSortOutIn');
b_sortOutInTimed=true;
solveActions(event);
}//sortOutInTimedActions 
replaceDownEventById('timedSortOutIn',sortOutInTimedActions);

 
function sortInOutTimedActions(event){
event.preventDefault();
activeShuffleButton('timedSortInOut');
b_sortInOutTimed=true;
solveActions(event);
}//sortInOutTimedActions 
replaceDownEventById('timedSortInOut',sortInOutTimedActions);


 
function sorterByNeighsTimedActions(event){
event.preventDefault();
activeShuffleButton('timedSortByNeighborCount');
b_sorterByNeighsTimed=true;
solveActions(event);
}//sorterByNeighsTimedActions 
replaceDownEventById('timedSortByNeighborCount',sorterByNeighsTimedActions);



function sortsCloseButtonActions(event){
event.preventDefault();
el('sortControls').style.display='none';
}//end sortsCloseButtonActions
replaceDownEventById('sortsClose',sortsCloseButtonActions);



function vertSizeButtonActions(event){
event.preventDefault();
activeButton('vertSizeButton');
showHide('vertSizeControls');
centerDiv('vertSizeControls');
}//end vertSizeButtonActions
replaceDownEventById('vertSizeButton',vertSizeButtonActions);

function vertSizeResetButtonActions(event){
event.preventDefault();
activeButton('vertSizeResetButton');
targetRatio=defaultRatio;
vertScaler();
render();
}//end vertSizeResetButtonActions
replaceDownEventById('vertSizeResetButton',vertSizeResetButtonActions);


function vertSizeDownButtonDownActions(event){
event.preventDefault();
activeButton('vertSizeDownButton');
vertSizeDecrease=true;
}//end vertSizeDownButtonDownActions
replaceDownEventById('vertSizeDownButton',vertSizeDownButtonDownActions);


function vertSizeDownButtonUpActions(event){
event.preventDefault();
activeButton('vertSizeDownButton');
vertSizeDecrease=false;
}//end vertSizeDownButtonUpActions
replaceUpEventById('vertSizeDownButton',vertSizeDownButtonUpActions);


function vertSizeUpButtonDownActions(event){
event.preventDefault();
activeButton('vertSizeUpButton');
vertSizeIncrease=true;
}//end vertSizeUpButtonDownActions
replaceDownEventById('vertSizeUpButton',vertSizeUpButtonDownActions);

function vertSizeUpButtonUpActions(event){
event.preventDefault();
activeButton('vertSizeUpButton');
vertSizeIncrease=false;
}//end vertSizeUpButtonUpActions
replaceUpEventById('vertSizeUpButton',vertSizeUpButtonUpActions);

function vertSizeCloseButtonDownActions(event){
event.preventDefault();
el('vertSizeControls').style.display='none';
}//end vertSizeCloseButtonDownActions
replaceDownEventById('vertSizeCloseButton',vertSizeCloseButtonDownActions);


function keysButtonDownActions(event){
event.preventDefault();
activeButton('keysButton');
showHide('shortcutKeys');
}//end keysButtonDownActions
replaceDownEventById('keysButton',keysButtonDownActions);

var defaultTouch=false;

function defaultTouchButtonActions(event){
if(isThere(event)){event.preventDefault();}
activeButton('defaultTouchButton');
if(els('bodyer').touchAction=='none'){
defaultTouch=true;
els('bodyer').touchAction='auto';
els('canvas').touchAction='auto';
els('buttonHolder').touchAction='auto';
replaceDownEventById('canvas',()=>{});
//replaceUpEventById('canvas',()=>{});
//replaceMoveEventById('canvas',()=>{});
controlPanelOpenClose();
}else{
defaultTouch=false;
els('bodyer').touchAction='none';
els('canvas').touchAction='none';
els('buttonHolder').touchAction='none';
replaceDownEventById('canvas',showSolvingActions);
}
if(defaultTouch){
els('defaultTouchButton').backgroundColor=B.blue;
}else{
els('defaultTouchButton').backgroundColor=B.white;
}
}//end defaultTouchButtonActions
replaceDownEventById('defaultTouchButton',defaultTouchButtonActions);



function buildGraphActions(event){
event.preventDefault();
activeButton('buildRandomGraph');
showSolving=false;
streamSolving=false;
showSolvingStatus();
showMessage('Building Graph',60000);
setRandomVerts=true;
setTimeout('buildAndRender();',50);
replaceDownEventById('canvas',buildGraphActions);
}//buildGraphActions
replaceDownEventById('buildRandomGraph',buildGraphActions);


function addVertexDelaunayButtonActions(event){
event.preventDefault();
activeButton('addVertexDelaunay');
replaceDownEventById('canvas',function(event){
event.preventDefault();
delaunay=true;
mouseAdd_Vertex(event);
solved=false;
});//replaceDownEventById('canvas',function(event){
}//end addVertDelaunay
replaceDownEventById('addVertexDelaunay',addVertexDelaunayButtonActions);



function moveVertexDelaunayButtonActions(event){
event.preventDefault();
activeButton('moveVertexDelaunay');
replaceDownEventById('canvas',function(event){
event.preventDefault();
delaunay=true;
el('expander').blur();
dragging=true;
moveRaw=false;
getVertexToEdit(event,true);
solved=false;
});
}//moveVertexButtonActions
replaceDownEventById('moveVertexDelaunay',moveVertexDelaunayButtonActions);


function deleteVertexDelaunayActions(event){
event.preventDefault();
activeButton('deleteVertexDelaunay');
replaceDownEventById('canvas',function(event){
event.preventDefault();
getVertexToEdit(event,true);
deleteVertex(event,true);
solved=false;
});//end replaceDownEventById('canvas',function(event){
}//deleteVertexDelaunayActions
replaceDownEventById('deleteVertexDelaunay',deleteVertexDelaunayActions);




function colorVertsActions(event){
event.preventDefault();
activeButton('colorVertsButton');
replaceDownEventById('canvas',function(event){
event.preventDefault();
getVertexToEdit(event);
changeVertexColor(event);
solved=false;
});//end replaceDownEventById('canvas',function(event){
}//colorVertsActions
replaceDownEventById('colorVertsButton',colorVertsActions);




function enterNumVertsButtonActions(event){
typing=true;
}//enterNumVertsButtonActions
replaceDownEventById('enterNumVerts',enterNumVertsButtonActions);

function numVertsButtonActions(event){
event.preventDefault();
activeButton('numVertsButton');
el('enterNumVerts').value=numPoints;
showHideV('numVertsInputDiv');
centerDiv('numVertsInputDiv');
}//numVertsButtonActions
replaceDownEventById('numVertsButton',numVertsButtonActions);


function numVertsApplyButtonActions(event){
typing=false;
activeButton('numVertsApply');
showMessage('Building Graph',60000);
flexibles=[];
numPoints=parseInt(el('enterNumVerts').value);
graphRenderScaleFactors();
el('numVertsInputDiv').style.visibility='hidden';
setRandomVerts=true;
setTimeout('buildAndRender();',100);
}//numVertsApplyButtonActions
replaceDownEventById('numVertsApply',numVertsApplyButtonActions);


function numVertsCancelActions(event){
typing=false;
el('numVertsInputDiv').style.visibility='hidden';
}//numVertsCancelActions
replaceDownEventById('numVertsCancel',numVertsCancelActions);



function toggleFullscreenActions(event){
toggleFullScreen();
}//toggleFullscreenActions
replaceDownEventById('fullscreen',toggleFullscreenActions);


function shortcutKeysActions(event){
showHide('shortcutKeys');
}//shortcutKeysActions
replaceDownEventById('shortcuts',shortcutKeysActions);


function expanderActions(event){
controlPanelOpenClose();
}//expanderActions
replaceDownEventById('expander',expanderActions);

function enterFpsActions(event){
typing=true;
}//enterFpsActions
replaceDownEventById('enterFPS',enterFpsActions);


function fpsActions(event){
activeButton('fpsId');
el('enterFPS').value=parseInt(framesPerSecond);
showHideV('fpsInputDiv');
centerDiv('fpsInputDiv');
}//fpsActions
replaceDownEventById('fpsId',fpsActions);



function fpsApplyActions(event){
typing=false;
framesPerSecond=parseInt(el('enterFPS').value);
if(framesPerSecond<1){framesPerSecond=1;
}else if(framesPerSecond>120){framesPerSecond=120;}
el('fpsInputDiv').style.visibility='hidden';
}//fpsApplyActions
replaceDownEventById('fpsApply',fpsApplyActions);



function fpsCancelActions(event){
typing=false;
el('fpsInputDiv').style.visibility='hidden';
}//fpsCancelActions
replaceDownEventById('fpsCancel',fpsCancelActions);

/*
function solveTimeActions(event){
event.preventDefault();
activeButton('timeToSolveId');
showMessage('Solved in: '+deltaTime+' ms<br>'+(deltaTime/(vertices.length)).toFixed(2)+' ms/vertex<br>'+((vertices.length)/deltaTime).toFixed(2)+' verts/ms<br> '+ numSolvesCounter+' steps<br>'+(vertices.length)+' Vertices<br><br><center>[close]</center>',20000);
}//solveTimeActions
replaceDownEventById('timeToSolveId',solveTimeActions);
*/

function neighsActions(event){
event.preventDefault();
activeButton('neighs');
showNumNeigh=!showNumNeigh;
if(showNumNeigh){listNumNeighs();}
else{messageCancelActions(event);}
render();
}//neighsActions
replaceDownEventById('neighs',neighsActions);



function listNumNeighs(){
listNumNeighsArr=[];
let nSortedVerts=[...vertices];
nSortedVerts.sort((a,b)=>b.nCount-a.nCount);
for(i=0;i<nSortedVerts.length;i++){
if(i==0){listNumNeighsArr[0]={
nCount:nSortedVerts[i].nCount,
vertCount:1
};
}else if(i>0){
if(nSortedVerts[i].nCount==nSortedVerts[i-1].nCount){
listNumNeighsArr[listNumNeighsArr.length-1].vertCount++;
}else if(nSortedVerts[i].nCount!=nSortedVerts[i-1].nCount){
listNumNeighsArr.push({
nCount:nSortedVerts[i].nCount,
vertCount:1
});
}
}//}else if(i>0){
}//i loop

let stringer='';
for(i=0;i<listNumNeighsArr.length;i++){
if(i==0){
stringer+='<div style="display:inline-block;white-space:nowrap;font-family:monospace;font-weight:bold;color:black;font-size:'+listNeighsFontSize+'px;line-height:'+listNeighsLineHeight+'px;text-align:right;padding-right:60px;">Neighs<br>';
}
stringer+=listNumNeighsArr[i].nCount+'<br>';
}//i loop
stringer+='</div>';

for(i=0;i<listNumNeighsArr.length;i++){
if(i==0){
stringer+='<div style="padding-left:60px;display:inline-block;white-space:nowrap;font-family:monospace;font-weight:bold;color:black;font-size:'+listNeighsFontSize+'px;line-height:'+listNeighsLineHeight+'px;text-align:left;border-left:1px solid black;">Verts<br>';
}
stringer+=listNumNeighsArr[i].vertCount+'<br>'
}//i loop
stringer+='</div><br><br><center><div style="font-size:'+listNeighsFontSize+'">[close]</div></center>';

showMessage(stringer,10000000);
}//listNumNeighs




function clearActions(event){
if(isThere(event)){event.preventDefault();
activeButton('clear');
}

for(let v=0;v<vertices.length;v++){
vertices[v].c=4;}
reSolverReset();
vertScaler();
sortByNeighborCount();
render();
}//clearActions
replaceDownEventById('clear',clearActions);


function flexiblesActions(event){
event.preventDefault();
activeButton('flexiblesButton');
showFlexibles=!showFlexibles;
render();
}//flexiblesActions
replaceDownEventById('flexiblesButton',flexiblesActions);


function dropRandomActions(event){
event.preventDefault();
activeButton('dropRandom');
buildGraphActions(event);
el('selectGraphHolder').style.display='none';
el('filenameInputDiv').style.display='none';
randomDropping=true;
showMessage('Running Samples',60000);
setTimeout('dropRandom();',300);
}//dropRandomActions
replaceDownEventById('dropRandom',dropRandomActions);



function dropRandomShowHide(event){
showHide('data');
if(el('data').style.display=='block'){
el('dataShowHideButton').innerHTML='-';
}else{
el('dataShowHideButton').innerHTML='+';
}
}//dropRandomShowHide
replaceDownEventById('dataShowHideButton',dropRandomShowHide);


function consoleButtonActions(event){
event.preventDefault();
activeButton('consoleButton');
showHideV('consoleInputDiv');
}//consoleButtonActions
replaceDownEventById('consoleButton',consoleButtonActions);


function consoleInputActions(event){
typing=true;
}//consoleInputActions
replaceDownEventById('consoleInput',consoleInputActions);


function consoleEnterButtonActions(event){
typing=false;
daar('testerHolder',eval(el('consoleInput').value)+'<br><hr><br>');
daar('consoleOutput',eval(el('consoleInput').value)+'<br><hr><br>');
el('consoleScroller').scrollTop=0;
}//consoleEnterButtonActions
replaceDownEventById('consoleEnterButton',consoleEnterButtonActions);


function consoleCloserActions(event){
typing=false;
showHideV('consoleInputDiv');
}//consoleCloserActions
replaceDownEventById('consoleCloser',consoleCloserActions);



function panZoomControlsButtonActions(event){
event.preventDefault();
}//panZoomControlsButtonActions
replaceDownEventById('panZoomControls',panZoomControlsButtonActions);

function panZoomButtonActions(event){
event.preventDefault();
activeButton('panZoomButton');
showHide('panZoomControls');
centerDiv('panZoomControls');
}//panZoomButtonActions
replaceDownEventById('panZoomButton',panZoomButtonActions);


function fitButtonActions(event){
event.preventDefault();
activeButton('fitButton');
graphRotater(90);
graphRotater(-90);
//graphRotater(0);
}//fitButtonActions
replaceDownEventById('fitButton',fitButtonActions);

function panZoomCloseButtonActions(event){
event.preventDefault();
el('panZoomControls').style.display='none';
}//panZoomCloseButtonActions
replaceDownEventById('panZoomClose',panZoomCloseButtonActions);



function rotateButtonActions(event){
event.preventDefault();
activeButton('rotateButton');
graphRotater();
replaceDownEventById('canvas',function(event){
event.preventDefault();
graphRotater();
});//replaceDownEventById('canvas',function(event){
}//rotateButtonActions
replaceDownEventById('rotateButton',rotateButtonActions);



function saveGraphButtonActions(event){
event.preventDefault();
activeButton('saveGraphButton');
showHide('filenameInputDiv');
centerDiv('filenameInputDiv');
}//saveGraphButtonActions
replaceDownEventById('saveGraphButton',saveGraphButtonActions);




function cancelSaveButtonActions(event){
typing=false;
el('filenameInputDiv').style.display='none';
}//cancelSaveButtonActions
replaceDownEventById('cancelSave',cancelSaveButtonActions);



function loadButtonActions(event){
event.preventDefault();
activeButton('loadGraphButton');

if(savedLastButton!='loadGraphButton'){
replaceDownEventById('canvas',showSolvingActions);
}
streamSolving=false;
showSolvingStatus();
showHide('selectGraphHolder');
centerDiv('selectGraphHolder');
}//loadButtonActions
replaceDownEventById('loadGraphButton',loadButtonActions);


function closeSelectActions(event){
el('selectGraphHolder').style.display='none';
}//closeSelectActions
replaceDownEventById('closeSelect',closeSelectActions);


function reloadButtonActions(event){
event.preventDefault();
activeButton('reloadGraphButton');
streamSolving=false;
showSolvingStatus();
loadFile();
el('selectGraphHolder').style.display="none";
}//reloadButtonActions
replaceDownEventById('reloadGraphButton',reloadButtonActions);


function curvedLinkButtonActions(event){
event.preventDefault();
activeButton('addCurveButton');
if(!tapMessageShown){tapMessageShown=true;showMessage('<center>Tap dotted<br>line between <br>unlinked nodes</center>',3000);}
gettingCurvedLinkStart=true;
curvedLink();
}//curvedLinkButtonActions
replaceDownEventById('addCurveButton',curvedLinkButtonActions);


function addVertButtonActions(event){
event.preventDefault();
activeButton('addButton');
startConnecting=false;
gettingLinkStart=false;
endConnecting=false;
replaceDownEventById('canvas',function(event){
event.preventDefault();
delaunay=false;
el('expander').blur();
mouseAdd_Vertex(event);
solved=false;
});//replaceDownEventById('canvas',function(event){
}//addVertButtonActions
replaceDownEventById('addButton',addVertButtonActions);


function addLinkedButtonActions(event){
event.preventDefault();
activeButton('addLinkedButton');
startConnecting=false;
gettingLinkStart=true;
endConnecting=false;
replaceDownEventById('canvas',function(event){
event.preventDefault();
delaunay=false;
el('expander').blur();
getVertexToEdit(event);
solved=false;
});//replaceDownEventById('canvas',function(event){
}//addLinkedButtonActions
replaceDownEventById('addLinkedButton',addLinkedButtonActions);


function linkVertsButtonActions(event){
event.preventDefault();
activeButton('linkVertsButton');
gettingLinkStart=false;
startConnecting=true;
endConnecting=false;
replaceDownEventById('canvas',function(event){
event.preventDefault();
delaunay=false;
el('expander').blur();
getVertexToEdit(event);
solved=false;
});//replaceDownEventById('canvas',function(event){
}//linkVertsButtonActions
replaceDownEventById('linkVertsButton',linkVertsButtonActions);



function moveVertButtonActions(event){
event.preventDefault();
activeButton('moveVertButton');
startConnecting=false;
endConnecting=false;
gettingLinkStart=false;
replaceDownEventById('canvas',function(event){
event.preventDefault();
delaunay=false;
el('expander').blur();
dragging=true;
moveRaw=true;
getVertexToEdit(event,false);
solved=false;
});//replaceDownEventById('canvas',function(event){
}//moveVertButtonActions
replaceDownEventById('moveVertButton',moveVertButtonActions);


function deleteVertButtonActions(event){
event.preventDefault();
activeButton('deleteVertButton');
startConnecting=false;
endConnecting=false;
gettingLinkStart=false;
replaceDownEventById('canvas',function(event){
event.preventDefault();
getVertexToEdit(event,false);
deleteVertex(event,false);
solved=false;
});//replaceDownEventById('canvas',function(event){
}//deleteVertButtonActions
replaceDownEventById('deleteVertButton',deleteVertButtonActions);

var testNumber=0;

function testerButtonActions(event){
event.preventDefault();
activeButton('testerButton');
showHide('testerHolder');
showHide('testerCloser');
if(els('testerHolder').display=='block'){
testVars("testNumber",testNumber,"solving:",solving,"solved",solved,"pauser",pauser,"showSolving",showSolving,"stepping",stepping,"loading",loading,"loadDataFileNameAtStart",loadDataFileNameAtStart,"streamSolving",streamSolving,"modifiedGraph",modifiedGraph);
testNumber++;
}

//el('testerHolder').scrollTop=el('testerHolder').scrollHeight;
}//testerButtonActions
replaceDownEventById('testerButton',testerButtonActions);


function testerCloserActions(event){
if(isThere(event)){event.preventDefault();}
showHide('testerHolder');
showHide('testerCloser');
}//testerCloserAction
replaceDownEventById('testerCloser',testerCloserActions);




function messageCancelActions(event){
if(event){event.preventDefault();}
el('messageHolder').style.display='none';
showSolvingTime=false;
el('solveData').style.backgroundColor=B.white;
showNumNeigh=false;
}//messageCancelActions
replaceDownEventById('messageHolder',messageCancelActions);



function gen2ButtonActions(event){
if(isThere(event)){event.preventDefault();}
activeButton('gen2Button');

if(savedLastButton!='gen2Button'){
replaceDownEventById('canvas',gen2ButtonActions);
}

showMessage('Generating Vertices',10000000);
setTimeout(`addVertsAtTriangleCenters2();`,1);
}//gen2ButtonActions
replaceDownEventById('gen2Button',gen2ButtonActions);


function addVertsAtTriangleCenters2(){
//testVars("pauser",pauser,"solved",solved,"showSolvingTime",showSolvingTime,"showSolving",showSolving,"solving",solving);
delaunay=true;
for(i=0;i<vertices.length;i++){
triangles=triangulate(vertices);
}//i loop
sortByNeighborCount();
delaunay=false
for(i=0;i<triangles.length;i++){
 
let triCenterX=parseInt((
triangles[i].v0.x+
triangles[i].v1.x+
triangles[i].v2.x)/3);

let triCenterY=parseInt((
triangles[i].v0.y+
triangles[i].v1.y+
triangles[i].v2.y)/3);

vertices.push(new Vertex(triCenterX,triCenterY,4,vertices.length+1,[],0,false,false,false,vertices.length+1));


pairArr.push([vertices.length-1,triangles[i].v0.i]);
pairArr.push([vertices.length-1,triangles[i].v1.i]);
pairArr.push([vertices.length-1,triangles[i].v2.i]);

segPoints.push(null);
segPoints.push(null);
segPoints.push(null);

}//i loop

vertScaler();
sortByNeighborCount();
render();
delaunay=false;
modified=true;
hideMessage(messageTimer);
}//addVertsAtTriangleCenters2






function moveVertex(event,delaunay){
if(vertexToEdit>=0){
let lastx=vertices[vertexToEdit].x;
let lasty=vertices[vertexToEdit].y;
let eventer=eventSwitch(event);
vertices[vertexToEdit].x=eventer.pageX;
vertices[vertexToEdit].y=eventer.pageY;
let moveDifx=[];
let moveDify=[];
ctx.clearRect(0,0,cW,cH);
if(delaunay){triangles=triangulate(vertices);}

for(let i=0;i<pairArr.length;i++){
if(pairArr[i][0]==vertexToEdit||pairArr[i][1]==vertexToEdit){
if(isThere(segPoints[i])){
moveDifx[i]=vertices[vertexToEdit].x-lastx;
moveDify[i]=vertices[vertexToEdit].y-lasty;
let fac=.98;
let facFac=.7;

let difx0=segPoints[i][1].x-vertices[vertexToEdit].x;
let dify0=segPoints[i][1].y-vertices[vertexToEdit].y;
let distToSeg0=Math.sqrt(difx0*difx0+dify0*dify0);

let difxL=segPoints[i][segPoints[i].length-1].x-vertices[vertexToEdit].x;
let difyL=segPoints[i][segPoints[i].length-1].y-vertices[vertexToEdit].y;
let distToSegLength=Math.sqrt(difxL*difxL+difyL*difyL);

if(distToSeg0<=distToSegLength){//forward loop

for(let s=0;s<segPoints[i].length-1;s++){
moveDifx[i]*=fac;
segPoints[i][s].x+=moveDifx[i];
moveDify[i]*=fac;
segPoints[i][s].y+=moveDify[i];
fac*=facFac;
}//end s loop
 
}else if(distToSeg0>distToSegLength){//backward loop

for(let s=segPoints[i].length-1;s>=0;s--){
moveDifx[i]*=fac;
segPoints[i][s].x+=moveDifx[i];
moveDify[i]*=fac;
segPoints[i][s].y+=moveDify[i];
fac*=facFac;
}//end s loop

}//end if(distToSeg0>distToSegLength){
}//isThere segPoints
}//if(pairArr[i][0]==vertexToEdit||pairArr[i][1]==vertexToEdit){
}//end i loop

render();
}//if(vertexToEdit>=0){
}//end moveVertex




function mouseAdd_Vertex(event){
modifiedGraph=true;
ctx.clearRect(0,0,cW,cH);
let eventer=eventSwitch(event);
vertices.push(new Vertex(eventer.pageX,eventer.pageY,4,vertices.length+1,[],0,false,false,false,vertices.length+1));
if(delaunay){
triangles=triangulate(vertices);
}
sortByNeighborCount();
render();
}//end mouseAdd_Vertex




function curvedLink(){
curvedLinkEnd=-1;
curvedLinkStart=-1;
segCounter=0;
replaceDownEventById('canvas',function(event){
event.preventDefault();
let eventer=eventSwitch(event);
//el('expander').style.visibility='hidden';
delaunay=false;
vertexToEdit=-1;
let alreadyConnected=false;

for(let i=0;i<vertices.length;i++){
ctx.beginPath();
ctx.arc(vertices[i].x, vertices[i].y, vertSize*2, 0, Math.PI * 2, true);
if(ctx.isPointInPath(eventer.pageX, 
eventer.pageY)){
vertexToEdit=i;
modifiedGraph=true;

ctx.lineWidth=selectedLineWidth*scaleFactor;
ctx.strokeStyle=fourColor[vertices[vertexToEdit].c];
ctx.stroke();


if(gettingCurvedLinkStart){
gettingCurvedLinkStart=false;
gettingCurvedLinkEnd=true;
curvedLinkStart=vertexToEdit;
segPoints[pairArr.length]=[];
segPoints[pairArr.length][segCounter]={
pairIndex:pairArr.length,
x:parseInt(vertices[curvedLinkStart].x),
y:parseInt(vertices[curvedLinkStart].y)
};
settingSegPoints[pairArr.length]=true;
segCounter++;

}else if(gettingCurvedLinkEnd){

curvedLinkEnd=vertexToEdit;
for(let i=0;i<pairArr.length;i++){
if(
(curvedLinkEnd==pairArr[i][0]&&curvedLinkStart==pairArr[i][1])||
(curvedLinkEnd==pairArr[i][1]&&curvedLinkStart==pairArr[i][0])){
alreadyConnected=true;
curvedLinkEnd=-1;
curvedLinkStart=-1;
gettingCurvedLinkStart=true;
segPoints[pairArr.length]=null;
segCounter=0; 
showMessage('Already Connected',3000);
}//end if already connected
}//end i loop


if(!alreadyConnected){
gettingCurvedLinkEnd=false;
settingSegPoints[pairArr.length]=false;
segPoints[pairArr.length][segCounter]={
x:parseInt(vertices[curvedLinkEnd].x),
y:parseInt(vertices[curvedLinkEnd].y)
};

 
if(curvedLinkStart>=0&&curvedLinkEnd>=0){
pairArr.push([curvedLinkStart,curvedLinkEnd]);
removeDuplicatePairs();
curvedLinkStart=curvedLinkEnd;
curvedLinkEnd=-1;
segCounter=0;
segPoints[pairArr.length]=[];
segPoints[pairArr.length][segCounter]={
pairIndex:pairArr.length,
x:parseInt(vertices[curvedLinkStart].x),
y:parseInt(vertices[curvedLinkStart].y)
};
settingSegPoints[pairArr.length]=true;
segCounter++;
gettingCurvedLinkEnd=true;

}//if(curvedLinkStart>=
}//end if(gettingCurvedLinkEnd){


}//end if(!alreadyConnected){
}//ctx.isPointInPath
}//i loop

ctx.closePath();

if(!alreadyConnected){
if(settingSegPoints[pairArr.length]){
segPoints[pairArr.length][segCounter]={
x:parseInt(eventer.pageX),
y:parseInt(eventer.pageY)
};
segCounter++;
}//end if(settingSegPoints[pairArr.length]){
}//end if(!alreadyConnected){

sortByNeighborCount();
render();
});//replaceDownEventById('canvas',function(event){
}//end curvedLink






function getVertexToEdit(event,isDelaunay){
event.preventDefault();
let eventer=eventSwitch(event);
vertexToEdit=-1;
for(let i=0;i<vertices.length;i++){
ctx.beginPath();
ctx.arc(vertices[i].x, vertices[i].y, vertSize*2, 0, Math.PI * 2, true);

if(ctx.isPointInPath(eventer.pageX,eventer.pageY)){


if(isThere(isDelaunay)){
if(isDelaunay){
delaunay=true;
}else{
delaunay=false;
}
}//if(isThere(isDelaunay)){

modifiedGraph=true;
vertexToEdit=i;
ctx.lineWidth=selectedLineWidth*scaleFactor;
ctx.strokeStyle=fourColor[vertices[vertexToEdit].c];
ctx.stroke();

if(!delaunay){
if(gettingLinkStart){
linkStart=vertexToEdit;
addingVert=true;

replaceDownEventById('canvas',function(event){
event.preventDefault();
let eventer=eventSwitch(event);
el('expander').style.visibility='hidden';
if(addingVert){
ctx.clearRect(0,0,cW,cH);

vertices.push(new Vertex(eventer.pageX,eventer.pageY,4,vertices.length+1,[],0,false,false,false,vertices.length+1));

linkEnd=vertices.length-1;
if(linkStart>=0&&linkEnd>=0&&linkStart!=linkEnd){
pairArr.push([linkStart,linkEnd]);
segPoints.push(null);
removeDuplicatePairs();
linkStart=linkEnd;
}//end if(linkStart
sortByNeighborCount();
render();

}//end adding vert
});//end replaceDownEventById('canvas',function(event){

}else if(startConnecting){
addingVert=false;
linkStart=vertexToEdit;
startConnecting=false;
endConnecting=true;

}else if(endConnecting){
addingVert=false;
delaunay=false;
linkEnd=vertexToEdit;

if(linkStart>=0&&linkEnd>=0&&linkStart!=linkEnd){
pairArr.push([linkStart,linkEnd]);
segPoints.push(null);
removeDuplicatePairs();

linkStart=linkEnd;
}
sortByNeighborCount();
render();

}//end if(endConnecting){
}//if(!delaunay

}//ctx.isPointInPath

}//i loop
ctx.closePath();
}//end getVertexToEdit
 


function deleteVertex(e,delaunay){
if(vertexToEdit>=0){
modifiedGraph=true;

if(!delaunay){
for(let i=pairArr.length-1;i>=0;i--){
if(isThere(segPoints[i])){
segPoints[i][0].pairIndex-=vertices[vertexToEdit].nCount;
}//isThere
}//i loop  
}//if(!delaunay){

vertices.splice(vertexToEdit,1);
for(let v=0;v<vertices.length;v++){
vertices[v].i=v;}

if(!delaunay){
for(let i=pairArr.length-1;i>=0;i--){
if(vertexToEdit==pairArr[i][0]||vertexToEdit==pairArr[i][1]){
pairArr.splice(i,1);
segPoints.splice(i,1);
}
}//i loop
delaunay=false;
}//!delaunay

if(delaunay){
triangles=triangulate(vertices);
}

for(let j=0;j<pairArr.length;j++){
if(pairArr[j][0]>vertexToEdit){
pairArr[j][0]--;}
if(pairArr[j][1]>vertexToEdit){
pairArr[j][1]--;}
}//j loop 

sortByNeighborCount();
render();
}//if(vertexToEdit>=0){
}//end deleteVertex

 


function getVertexPairs(){
if(delaunay){
pairArr=[];
segPoints=[];
settingSegPoints=[];
for(let i=0;i<triangles.length;i++){
pairArr.push([triangles[i].v0.i, triangles[i].v1.i]);
pairArr.push([triangles[i].v0.i, triangles[i].v2.i]);
pairArr.push([triangles[i].v1.i, triangles[i].v2.i]);
}//i loop
}//if(delaunay)
removeDuplicatePairs();
}//end getVertexPairs




//remove duplicate pairs
function removeDuplicatePairs(){
for(let i=pairArr.length-1;i>=1;i--){
for(let j=i-1;j>=0;j--){
if(isThere(pairArr[i])
&&
isThere(pairArr[j])){
if(
(pairArr[i][0]==pairArr[j][0]
&&
pairArr[i][1]==pairArr[j][1])
||
(pairArr[i][0]==pairArr[j][1]
&&
pairArr[i][1]==pairArr[j][0])
){
pairArr.splice(i,1);
segPoints.splice(i,1);
}
}//end isThere
}//end j loop
}//end i loop
}//removeDuplicatePairs



function getNeighbors(){
getVertexPairs();
for(let v=0;v<vertices.length;v++){
vertices[v].n=[];
for(let i=0;i<pairArr.length;i++){
if(
v==pairArr[i][0]
){
vertices[v].n.push(pairArr[i][1]);
}else if(
v==pairArr[i][1]
){
vertices[v].n.push(pairArr[i][0]);
}
if(i==pairArr.length-1){
vertices[v].nCount=vertices[v].n.length;
}
}//end i loop
}//end v loop
}//end get neighbors



function sortByNeighborCount(){
getNeighbors();
sortedVerts=[];
for(let v=0;v<vertices.length;v++){
sortedVerts[v]={nCount:vertices[v].nCount,i:vertices[v].i,n:vertices[v].n};
}
sortedVerts.sort((a,b)=>b.nCount-a.nCount);
}//end sortByNeighborCount




function colorGraph(){
for(let v=0;v<vertices.length;v++){
vertices[v].c=4;}

for(let v=0;v<sortedVerts.length;v++){
for(let c=0;c<4;c++){
let colorAvailable=true;
for(let n=0;n<sortedVerts[v].nCount;n++){
if(isThere(vertices[sortedVerts[v].n[n]])){
if(vertices[sortedVerts[v].n[n]].c==c){
colorAvailable=false;break;
}
}//isThere
}//end n loop
if(colorAvailable){vertices[sortedVerts[v].i].c=c;break;}
}//end c loop
}//end v loop
}//end colorGraph





function buildRandomGraphButton(){
if(building&&el('buildRandomGraph').value=='Build Random Graph'){
el('buildRandomGraph').value='Building..........';
el('buildRandomGraph').style.backgroundColor='#ffd7d4';
}else if(!building&&el('buildRandomGraph').value=='Building..........'){
el('buildRandomGraph').value='Build Random Graph';
el('buildRandomGraph').style.backgroundColor='#dbedff';
}
}//end buildRandomGraphButton





document.body.onload=function(){
cancelAnimationFrame(animId);
modStyles();
getGraphFilenames();
graphRenderScaleFactors();
buildAndRender();
animInit();
showHideV('bodyer');
//setTimeout(`showHideV('bodyer');`,200);
replaceDownEventById('canvas',showSolvingActions);
}//end onload 



//called once onload
function animInit(){
cancelAnimationFrame(animId);
animId=0;
stepping=false;
solved=false;
//showSolvingStatus();
pauser=false;
animate();
//setTimeout("activeButton('showSolving');showSolvingButton();",100);
}//end animInit



function animate(){
clearTimeout(animateTimer);
animateTimer=setTimeout(function(){
animId=requestAnimationFrame(animate);

if(streamSolving&&loading){
solved=false;
loading=false;
//buildAndRender();
activeButton('showSolving');
totalSolveTime=0;
numPauses=0;
startSolveTime=[];
endSolveTime=[];
startSolveTime.push(Date.now());
showSolvingButton();


}else if(streamSolving&&solved&&!modifiedGraph){
solved=false;
setTimeout(`
buildAndRender();
totalSolveTime=0;
numPauses=0;
startSolveTime=[];
endSolveTime=[];
startSolveTime.push(Date.now());
if(showSolvingTime){updateSolveData();}
activeButton('showSolving');
showSolving=true;
showSolvingButton();
`,2000);

}else if(streamSolving&&solved&&modifiedGraph){
solved=false;
setTimeout(`
for(let v=0;v<vertices.length;v++){
vertices[v].c=4;}
totalSolveTime=0;
numPauses=0;
startSolveTime=[];
endSolveTime=[];
startSolveTime.push(Date.now());
if(showSolvingTime){updateSolveData();}
activeButton('showSolving');
showSolving=true;
showSolvingButton();`
,2000);

}


if(zoomingIn||zoomingOut){setTimeout("zoomer();",20);}


if(vertSizeDecrease){
if(targetRatio>.001){
targetRatio*=.95;vertScaler();render();
}
}

if(vertSizeIncrease){ 
targetRatio*=1.05;vertScaler();render();
}

if(showSolving&&!pauser&&!stepping){
recursiveNeighborSolver();
render();
}//end showSolving&&!&&pauser


},1000/framesPerSecond);//end setTimeout
}//end animate





function recursiveNeighborSolver(){

numSolves++; 
numSolvesCounter=numSolves;

stillSearching=false;
let stringer='';
let errorString='';
let checkCounter=0;

nonNeighbor=[];
for(let s=0;s<lastSearcher.length;s++){
nonNeighbor[s]=lastSearcher[s];
}
searcher=[];
lastSearcher=[];


nextVertex:
for(let v=0;v<vertices.length;v++){
let neighArray=[];
let neighColorCount=[];
let colorAvailable=[true,true,true,true];

if(vertices[v].c==4||vertices[v].searching){
stillSearching=true;

for(let n=0;n<vertices[v].nCount;n++){
if(isThere(vertices[vertices[v].n[n]])){
let nColor=vertices[vertices[v].n[n]].c;
neighArray.push({
i:vertices[v].n[n],
color:nColor
});

colorAvailable[nColor]=false;
}//isThere
}//end n loop

for(let c=0;c<4;c++){
if(colorAvailable[c]&&c!=vertices[v].c){
vertices[v].c=c;
vertices[v].searching=false;
if(showSolving||stepping){

if(v==0||v%5==0){ 
if((showSolving||solving)&&stillSearching&&!pauser&&showSolvingTime){
updateSolveData();
}
}

render();return;}else{
continue nextVertex;
}
}//if(colorAvailable[c]
}//end c loop

let colorCounter=[];
for(let c=0;c<4;c++){
colorCounter[c]= neighArray.filter((obj)=>obj.color==c).length;

let nIndex=neighArray.filter(x=>x.color===c).map(x=>x.i);


let isNeigh=true;
for(let nn=0;nn<nonNeighbor.length;nn++){
for(let j=0;j<nIndex.length;j++){
if(nonNeighbor[nn]==nIndex[j]){isNeigh=false;}

}//end j loop
}//end nn loop

if(isNeigh){
neighColorCount.push({
nIndex:nIndex,
color:c, 
count:colorCounter[c]
});
}//isNeigh
}//end c loop

neighColorCount.sort((a,b)=>
a.count-b.count
||
a.color-b.color);

let ind=0;
if(loopingDetected){ind=randRange(1,2);
loopCounter++;
if(loopCounter>2){
loopingDetected=false;
}
}

if(isThere(neighColorCount[ind])&&isThere(neighColorCount[ind].nIndex[0])){

vertices[v].c=vertices[neighColorCount[ind].nIndex[0]].c;


for(let j=0;j<neighColorCount[ind].nIndex.length;j++){
searcher.push(neighColorCount[ind].nIndex[j]);

}//end j loop
 
lastSearcher.push(vertices[v].i);

//for looping detection
for(let i=0;i<parseInt(neighColorCount[0].nIndex.length*.5);i++){
nIndexString+=neighColorCount[0].nIndex[i]+' ';
}//i loop

chunkSolveString+=vertices[v].i+' '+nIndexString;
allSolvesString+=vertices[v].i+' '+nIndexString;


solveCounter++;
if(solveCounter==2){
solveCounter=0;


let regEx=new RegExp(chunkSolveString,'g');
let matchCount=(allSolvesString.match(regEx)||[]).length;

if(matchCount>1){loopingDetected=true;}

chunkSolveString='';
nIndexString='';
}//end if solveCounter greater than
//end looping detection
}//isThere neighColorCount
}//end if .c==4

//solve remaining same colored pairs
if(v==vertices.length-1&&(!stillSearching||tripleCheck)){

lastSearcher=[];
let foundUnsolved=false;

for(let i=0;i<pairArr.length;i++){
if(isThere(vertices[pairArr[i][0]])&&isThere(vertices[pairArr[i][1]])){
if(
vertices[pairArr[i][0]].c==
vertices[pairArr[i][1]].c
){

vertices[pairArr[i][0]].searching=true;
vertices[pairArr[i][1]].searching=true;
lastSearcher.push(vertices[pairArr[i][0]].i);
lastSearcher.push(vertices[pairArr[i][1]].i);
vertices[pairArr[i][0]].c=0;
vertices[pairArr[i][1]].c=0;

solveRemainingPass++;
foundUnsolved=true;

}//if same color
}//isThere
}//end i loop

if(foundUnsolved){v=0;
}else if(!tripleCheck){
v=0;
checkCounter++;
if(checkCounter>3){
tripleCheck=true;}
}//if !tripleCheck
}//if v==vertices.length-1
//end solve remaining same colored pairs




}//end v loop


for(let v=0;v<vertices.length;v++){
vertices[v].searching=false;
for(let s=0;s<searcher.length;s++){
if(searcher[s]==vertices[v].i){
vertices[v].searching=true;
}
}//end s loop



if(v==vertices.length-1){


if((showSolving||solving)&&stillSearching&&!pauser&&showSolvingTime){
updateSolveData();
}


if(stillSearching==false){


if(solving){
updateSolveData();
solved=true;
solveButtonStatus();
if(!showSolvingTime){
showMessage('Solved in: '+totalSolveTime+' ms',2000);
}else{
updateSolveData();
}
}//if(solving){

solved=true;

if(showSolving||stepping){
updateSolveData();
solved=true;
if(!showSolvingTime){
showMessage('All Solved',2000);
}else{
updateSolveData();
}
stepping=false;
}


pauser=false;
solving=false;
showSolving=false;
showSolvingStatus();
pairString='';
numSolves=0;
solveCounter=0;
chunkSolveString='';
loopingDetected=false;
nIndexString='';
solveRemainingPass=0;
tripleCheck=false;

render();

return;
}else if(stillSearching==true){

if(numSolves==100){
tripleCheck=false;
checkCounter=0;
}else if(numSolves==100000000){

alert('still solving after numSolves:'+numSolves+' so...returning.');
return;
}


if(!showSolving&&!pauser&&!stepping){


try{

if(numSolves%100==0){
clearTimeout(solveTimer);
solveTimer=setTimeout(`
recursiveNeighborSolver();
render();
`,1);
}else{
recursiveNeighborSolver();
}

}catch(error){
clearTimeout(solveTimer);
alert(error.message);
return;

if(error instanceof RangeError && error.message.includes("Maximum call stack size exceeded")){
maxCallStackSizeExceeded=true;
alert("Maximum call stack size exceeded");
return;
}//if(error 
}//}catch(error){

}//if(!showSolving&&!pauser&&!stepping){
}//if stillSearching
}//if(v==vertices.length-1){
}//end v loop
}//end recursiveNeighborSolver


function centerDiv(id){
el(id).style.left=
(cW*.5-el(id).getBoundingClientRect().width*.5)+'px';
}//centerDiv

function showMessage(messageString,time){
hideMessage(messageTimer);
el('messageHolder').style.display='block';
da('message',messageString);
centerDiv('messageHolder');
/*
let rect=el('messageHolder').getBoundingClientRect();
let width=rect.width;
el('messageHolder').style.left=
(cW*.5-width*.5)+'px';
*/
messageTimer=setTimeout("el('messageHolder').style.display='none';",time);
}//end show message


function hideMessage(timerId){
clearTimeout(timerId);
el('messageHolder').style.display='none';
}//hide message





function getFlexibles(){
flexibles=[];

for(let v=0;v<vertices.length;v++){
flexibles[v]={
avail:false,
i: vertices[v].i,
colorsAvailable:[]
};
if(vertices[vertices[v].i].c!=4){
let colorAvailable=[true,true,true,true];
for(let c=0;c<4;c++){
for(let n=0;n<vertices[v].nCount;n++){
if(isThere(vertices[vertices[v].n[n]])){
if(
(vertices[v].c==c)||
(vertices[vertices[v].n[n]].c==c)){
colorAvailable[c]=false;
break;//next color
}
}//isThere
}//end n loop

if(colorAvailable[c]){
flexibles[v].avail=true;
flexibles[v].colorsAvailable.push(fourColorShort[c]);
}

}//end c loop
}//!=4
}//end v loop

flexiblesCount=
flexibles.filter((obj)=>obj.avail==true).length;

}//end getFlexibles


function clamp(a,min,max){
if(a<min){a=min;}else if(a>max){a=max;}
return a;
}//end clamp


/*

function graphRenderScaleFactors(){
diam=Math.sqrt(cW*cH/numPoints*.29);
vertSize=clamp(.22*diam,minVertSize,maxVertSize);
}//graphRenderScaleFactors
*/


function graphRenderScaleFactors(){
diam=Math.sqrt(cW*cH/numPoints*randOnlySome);
}//graphRenderScaleFactors
//graphRenderScaleFactors();




function buildAndRender(){
vertices=[];
triangles=[];
pairArr=[];
segPoints=[];
settingSegPoints=[];
pairString='';
numSolves=0;
solveCounter=0;
chunkSolveString='';
allSolvesString='';
loopingDetected=false;
nIndexString='';
solveRemainingPass=0;
tripleCheck=false;
rColorGraphDone=false;
solved=false;
solving=false;
showSolving=false;
linkStart=-1;
linkEnd=-1;
delaunay=true;
pauser=false;

let radius=diam*.5;
let offset=.5*radius;
let onlySome=0;
let pointCounter=0;

if(setRandomVerts){
for(let y=radius*1.7;y<cH-radius;y+=diam){
if(pointCounter>=numPoints){break;}
for(let x=radius*1.5;x<cW-radius*1.5;x+=diam){
let randOffX=randRange(-offset,offset);
let randOffY=randRange(-offset,offset);
onlySome=randRange(1,30);
if(onlySome>20){
vertices.push(new Vertex(x+randOffX,y+randOffY,4,pointCounter,0,[],false));
pointCounter++;
triangles=triangulate(vertices);

if(pointCounter>=numPoints){break;}
}//onlySome
}//end x loop
}//end y loop


vertScaler();
sortByNeighborCount();

nativeVertOrder=[...vertices];
nativePairArr=[...pairArr];


if(!showSolving){
render();
}

}else if(!setRandomVerts&&!randomDropping){

if(isLive>=0){
processFile('../graph2/data/'+dataFileName);
}else{
processFile('/data/'+dataFileName);
}
}
 
building=false;
if(setRandomVerts&&!randomDropping){
buildRandomGraphButton();
hideMessage(messageTimer);
}
}// end buildAndRender





function updatePairArr(vertsArray){
if(!delaunay){
let pairArrCopy=[]; 
for(let p=0;p<pairArr.length;p++){
if(!isThere(pairArrCopy[p])){
pairArrCopy[p]=[];}
pairArrCopy[p][0]=vertsArray.findIndex(
vert=>vert.i===pairArr[p][0]);
pairArrCopy[p][1]=vertsArray.findIndex(
vert=>vert.i===pairArr[p][1]);
}
pairArr=[...pairArrCopy];
}//if(!delaunay){ 
}//updatePairArr




function restoreNativeVertOrder(){
vertices=[...nativeVertOrder];
vertices.sort((a,b)=>a.nativeIndex-b.nativeIndex);
if(delaunay){
for(let i=0;i<vertices.length;i++){
triangles=triangulate(vertices);
}//i loop
}//if(delaunay){
updatePairArr(vertices);
vertScaler();
sortByNeighborCount();
render();
}//restoreNativeVertOrder


function shuffle(array){
for(let i=array.length-1;i>0;i--){
const j=Math.floor(Math.random()*(i+1));
[array[i],array[j]]=[array[j],array[i]];
}//i loop
return array;
}//shuffle
 
 
function shuffleRandomVertices(){
shuffledVertices=shuffle(vertices);
vertices=[...shuffledVertices];
for(let i=0;i<vertices.length;i++){
if(delaunay){
triangles=triangulate(vertices);
}
}//i loop
updatePairArr(shuffledVertices);
vertScaler();
sortByNeighborCount();
render();
}//shuffleRandomVertices 




function sortPoints(points){
return points.sort((a,b)=>{
//if(a.y!==b.y){return a.y-b.y;
//}else{return a.x-b.x;}});
if(a.x===b.x){return a.x-b.x;
}else{return a.y-b.y;}});
}//sortPoints


function sort2D(){
let sortedVerts2D=sortPoints(vertices);
vertices=[...sortedVerts2D];
for(let i=0;i<vertices.length;i++){
if(delaunay){
triangles=triangulate(vertices);
}
}//i loop 
updatePairArr(sortedVerts2D);
vertScaler(); 
sortByNeighborCount();
render();
}//sort2D


function sortRadial(outIn){
let outInVerts=[...vertices];
let sumX=0;
let sumY=0;
for(let i=0;i<outInVerts.length;i++){
sumX+=parseInt(outInVerts[i].x);
sumY+=parseInt(outInVerts[i].y);
//if(i==10){alert('f'+sumY);}
}//i loop

let centerX=sumX/outInVerts.length;
let centerY=sumY/outInVerts.length;

for(let i=0;i<outInVerts.length;i++){
let subx=parseInt(outInVerts[i].x)-centerX;
let suby=parseInt(outInVerts[i].y)-centerY;
let distFromCenter=Math.sqrt(subx*subx+suby*suby);

outInVerts[i].distFromCenter=distFromCenter;
}//i loop

if(outIn=='outIn'){
outInVerts.sort((a,b)=>b.distFromCenter-a.distFromCenter);

}else if(outIn=='inOut'){
outInVerts.sort((a,b)=>a.distFromCenter-b.distFromCenter);
}

vertices=[...outInVerts];
vertices.forEach(vert=>{delete vert.distFromCenter;});

for(let i=0;i<vertices.length;i++){
if(delaunay){
triangles=triangulate(vertices);
}
}//i loop 
updatePairArr(vertices);
vertScaler(); 
sortByNeighborCount();
render();
}//sortRadial




function sorterByNeigh(){
sortedByNeighCount=[...vertices];
sortedByNeighCount.sort((a,b)=>b.nCount-a.nCount);
vertices=[...sortedByNeighCount];

if(delaunay){
for(let i=0;i<vertices.length;i++){
triangles=triangulate(vertices);
}//i loop 
}//if(delaunay){

updatePairArr(vertices);
vertScaler(); 
sortByNeighborCount();
render();
}//sorterByNeigh




function sorterSwitch(){
if( vertSortType!=''){
if(vertSortType=='random'){
shuffleRandomVertices();
}else if(vertSortType=='sort2D'){
sort2D();
}else if(vertSortType=='native'){
restoreNativeVertOrder();
}else if(vertSortType=='outIn'){
sortRadial('outIn');
}else if(vertSortType=='inOut'){
sortRadial('inOut');
}else if(vertSortType=='neighs'){
sorterByNeigh();
}
}//if( vertSortType!=''){
}//sorterSwitch







function render(){

for(let v=0;v<vertices.length;v++){
vertices[v].i=v;}


if(showFlexibles){getFlexibles();}

//drawBackground
ctx.beginPath();
ctx.globalAlpha=1;
ctx.fillStyle=backgroundColor;//d6d651
ctx.fillRect(0, 0, cW, cH);
ctx.closePath();

/*
//drawFrame that saves to image
ctx.globalAlpha=.4;
ctx.lineWidth=4;
ctx.strokeStyle='black';
ctx.strokeRect(0, 0, cW, cH);
//end drawFrame
*/

ctx.strokeStyle='black';
ctx.lineWidth=2*scaleFactor;

if(delaunay){
//draw triangles
ctx.globalAlpha=1;
let i=0;
triangles.forEach(function(triangle){
ctx.beginPath();
ctx.moveTo(triangle.v0.x, triangle.v0.y);
ctx.lineTo(triangle.v1.x, triangle.v1.y);
ctx.lineTo(triangle.v2.x, triangle.v2.y);
ctx.closePath();
ctx.strokeStyle="black";
ctx.lineWidth=2*scaleFactor;
ctx.stroke();
//ctx.fillStyle='transparent';//triColors[i];
//ctx.fill();
i++;
});//end triangles foreach

}//!custom



if(!delaunay){
ctx.globalAlpha=1;


if(settingSegPoints[pairArr.length]&&isThere(segPoints[pairArr.length])){

for(let s=0;s<segPoints[pairArr.length].length;s++){
ctx.beginPath();
ctx.arc(segPoints[pairArr.length][s].x, segPoints[pairArr.length][s].y, vertSize, 0, Math.PI * 2, true);
ctx.closePath();
ctx.fillStyle='white';
ctx.fill();
ctx.strokeStyle='black';
ctx.lineWidth=2*scaleFactor;
ctx.stroke();
}//end s loop
}//if settingSegPoints[pairArr.length]


for(let i=0;i<pairArr.length;i++){
if(isThere(vertices[pairArr[i][0]])&&isThere(vertices[pairArr[i][1]])){

if(isThere(segPoints[i])&&!settingSegPoints[i]){

ctx.beginPath();
ctx.moveTo(segPoints[i][0].x, segPoints[i][0].y);

for(let s=1;s<segPoints[i].length-2;s++){
let xc=(segPoints[i][s].x+segPoints[i][s+1].x)/2;
let yc=(segPoints[i][s].y+segPoints[i][s+1].y)/2;
ctx.quadraticCurveTo(
segPoints[i][s].x, 
segPoints[i][s].y, 
xc, yc);
}//end s loop

// Connect the last two points
ctx.quadraticCurveTo(
segPoints[i][segPoints[i].length-2].x,
segPoints[i][segPoints[i].length-2].y,
segPoints[i][segPoints[i].length-1].x,
segPoints[i][segPoints[i].length-1].y
);

//ctx.closePath();


}else if(!isThere(segPoints[i])){

 
ctx.beginPath();

ctx.moveTo(
vertices[pairArr[i][0]].x, 
vertices[pairArr[i][0]].y);

ctx.lineTo(
vertices[pairArr[i][1]].x,
vertices[pairArr[i][1]].y);
ctx.closePath();

}//if(!isThere(segPoints[i])){


ctx.strokeStyle='black';
ctx.lineWidth=2*scaleFactor;
ctx.stroke();

}//if(isThere(vertices[pairArr[i][0]])&&
}//end i loop
}//if !delaunay



//highlight same color vertices link


if(highlightSame){

sameColorVerts=[];
for(let i=0;i<pairArr.length;i++){
sameColorVerts[i]=false;
}

for(let i=0;i<pairArr.length;i++){
if(isThere(vertices[pairArr[i][0]])&&isThere(vertices[pairArr[i][1]])){
if(vertices[pairArr[i][0]].c==vertices[pairArr[i][1]].c){
sameColorVerts[i]=true;
}//end if
}//isThere
}//end i loop


for(let i=0;i<pairArr.length;i++){

if(sameColorVerts[i]&&!isThere(segPoints[i])){

ctx.beginPath();
ctx.moveTo(vertices[pairArr[i][0]].x, vertices[pairArr[i][0]].y);
ctx.lineTo(vertices[pairArr[i][1]].x, vertices[pairArr[i][1]].y);
ctx.closePath();
ctx.strokeStyle="black";
ctx.lineWidth=6*scaleFactor;
ctx.stroke();


}else if(sameColorVerts[i]&&isThere(segPoints[i])&&!settingSegPoints[i]){


ctx.beginPath();
ctx.moveTo(segPoints[i][0].x, segPoints[i][0].y);

for(let s=1;s<segPoints[i].length-2;s++){
let xc=(segPoints[i][s].x+segPoints[i][s+1].x)/2;
let yc=(segPoints[i][s].y+segPoints[i][s+1].y)/2;
ctx.quadraticCurveTo(
segPoints[i][s].x, 
segPoints[i][s].y, 
xc, yc);
}//end s loop

// Connect the last two points
ctx.quadraticCurveTo(
segPoints[i][segPoints[i].length-2].x,
segPoints[i][segPoints[i].length-2].y,
segPoints[i][segPoints[i].length-1].x,
segPoints[i][segPoints[i].length-1].y
);

//ctx.closePath();
ctx.strokeStyle="black";
ctx.lineWidth=6*scaleFactor;
ctx.stroke();
}//}else if(sameColorVerts[i]&&isThere(segPoints[i])&&!settingSegPoints[i]){{
}//end i loop

}//end if highlightSame




//draw vertices as circles
let ci=0;
this.vertices.forEach(function(vertex){
ctx.beginPath();
ctx.strokeStyle="black";
ctx.lineWidth=2*scaleFactor;
ctx.arc(vertex.x, vertex.y, vertSize, 0, Math.PI * 2, true);
ctx.stroke();
ctx.closePath();

if(xray){
ctx.fillStyle='transparent';
}else{
ctx.fillStyle=fourColor[vertices[ci].c];
}
ctx.fill();


fonter=parseInt(30*scaleFactor);

if(showFlexibles&&flexibles[ci].avail){
ctx.fillStyle='black';
for(let c=0;c<flexibles[ci].colorsAvailable.length;c++){
let coff=c*parseInt(15*scaleFactor);
ctx.fillText(flexibles[ci
].colorsAvailable[c],vertex.x+parseInt(vertSize*1.3)+coff,vertex.y+parseInt(vertSize*1.1));
}//end c loop
ctx.strokeStyle='black';
let flexLine=10*scaleFactor;
flexLine=clamp(flexLine,0,14);
ctx.lineWidth=parseInt(flexLine);
}else{
ctx.strokeStyle='black';
let regLine=2*scaleFactor;
regLine=clamp(regLine,.5,2);
ctx.lineWidth=parseInt(regLine);
}
ctx.stroke();



if(vertices[ci].c==4){
ctx.fillStyle='black';
}else{
ctx.fillStyle='white';
}

ctx.font=fonter+"px Monospace";

let xOff=0;
let yOff=0;

if(vertex.i>99){
xOff=parseInt(28*(scaleFactor));
yOff=parseInt(8*(scaleFactor));
}else if(vertex.i>9){
xOff=parseInt(18*(scaleFactor));
yOff=parseInt(8*(scaleFactor));
}else if(vertex.i<=9){
xOff=parseInt(8*(scaleFactor));
yOff=parseInt(8*(scaleFactor));
}


if(showNumNeigh){
if(vertex.nCount>9){
xOff=parseInt(18*(scaleFactor));
yOff=parseInt(8*(scaleFactor));
}else if(vertex.nCount<=9){
xOff=parseInt(8*(scaleFactor));
yOff=parseInt(8*(scaleFactor));
}
ctx.fillText(vertex.nCount,vertex.x-xOff,vertex.y+yOff);
}else{
ctx.fillText(vertex.i,vertex.x-xOff,vertex.y+yOff);
}


ci++;
});//end vertices foreach

//testVars("gettingLinkStart",gettingLinkStart,"startConnecting",startConnecting,"endConnecting",endConnecting,"addingVert",addingVert,"linkStart",linkStart,"linkEnd",linkEnd);

if(loadDataFileNameAtStart&&streamSolving){
loadDataFileNameAtStart=false;
setTimeout(`showSolvingActions();`,500);
}

}//end render







//Vertex object constructor; //returns {x:x,y:y,c:c,i:i,n:n,nCount:nCount,searching:searching}

function Vertex(x,y,c,i,n,nCount,searching,inSameColorPair,isFlexible,nativeIndex){ 
this.x=parseInt(x);
this.y=parseInt(y);
this.c=c;//color
this.i=i;//index
this.n=n;//array of neighbors
this.nCount=nCount;//neighbors count
this.searching=searching;
this.inSameColorPair=inSameColorPair;
this.isFlexible=isFlexible;
this.nativeIndex=nativeIndex;
}//end Vertex



//Triangle object constructor
//returns {v0:Vertex, v1:Vertex, v2:Vertex, center:Vertex, radius:number, radius_squared:number}

function Triangle(v0, v1, v2){ 
this.v0=v0;
this.v1=v1;
this.v2=v2;
//calculate circumcircle;we always do this when we build a new triangle object, so why not put it here in the constructor, instead of putting it somewhere else and calling it from here?
let A=this.v1.x - this.v0.x;
let B=this.v1.y - this.v0.y;
let C=this.v2.x - this.v0.x;
let D=this.v2.y - this.v0.y;
let E=A * (this.v0.x + this.v1.x) + B * (this.v0.y + this.v1.y);
let F=C * (this.v0.x + this.v2.x) + D * (this.v0.y + this.v2.y);
let G=2.0 * (A * (this.v2.y - this.v1.y) - B * (this.v2.x - this.v1.x));
let dx, dy;
if(Math.abs(G)<EPSILON){
let minx=Math.min(this.v0.x, this.v1.x, this.v2.x);
let miny=Math.min(this.v0.y, this.v1.y, this.v2.y);
let maxx=Math.max(this.v0.x, this.v1.x, this.v2.x);
let maxy=Math.max(this.v0.y, this.v1.y, this.v2.y);
this.center=new Vertex(parseInt((minx + maxx) / 2), parseInt((miny + maxy) / 2), 4);
dx=this.center.x - minx;
dy=this.center.y - miny;
}else{
let cx=(D * E - B * F) / G;
let cy=(A * F - C * E) / G;
this.center=new Vertex(cx, cy, 4);
dx=this.center.x - this.v0.x;
dy=this.center.y - this.v0.y;
}
this.radius_squared=parseInt(dx * dx + dy * dy);
this.radius=parseInt(Math.sqrt(this.radius_squared));
//end calculate circumcircle;
}//end Triangle

//Edge object constructor; 
//returns {v0:Vertex,v1:vertex,equals:function,inverse:function}
function Edge(v0, v1){ 
this.v0=v0;
this.v1=v1;
this.equals=function(other){return (this.v0 === other.v0 && this.v1 === other.v1);};
this.inverse=function(){return new Edge(this.v1, this.v0);};
}//end edge


function triangulate(vertices){
pairString='';
let triangles=[];
let minx, miny, maxx, maxy;
vertices.forEach(function(vertex){
if(minx === undefined || vertex.x<minx){ minx=vertex.x;}
if(miny === undefined || vertex.y<miny){ miny=vertex.y;}
if(maxx === undefined || vertex.x > maxx){ maxx=vertex.x;}
if(maxy === undefined || vertex.y > maxy){ maxy=vertex.y;}
});
let dx=(maxx - minx) * 10;
let dy=(maxy - miny) * 10;
let stv0=new Vertex(minx - dx, miny - dy * 3, 4);
let stv1=new Vertex(minx - dx, maxy + dy, 4);
let stv2=new Vertex(maxx + dx * 3, maxy + dy, 4);
let st=new Triangle(stv0, stv1, stv2);
triangles.push(st);

let ci=0;
vertices.forEach(function(vertex){
vertex.i=ci;
ci++;

edges=[];
triangles=triangles.filter(function(triangle){
let dx=triangle.center.x - vertex.x;
let dy=triangle.center.y - vertex.y;
let dist_squared=dx * dx + dy * dy;
let inCirc=(dist_squared <= triangle.radius_squared);
if(inCirc){
edges.push(new Edge(triangle.v0, triangle.v1));
edges.push(new Edge(triangle.v1, triangle.v2));
edges.push(new Edge(triangle.v2, triangle.v0));
return false;
}else{
return true;
}
});

let uniqueEdgesArray=[];


for(let i=0;i<edges.length;++i){
let edge1=edges[i];

let unique=true;
for(let j=0;j<edges.length;++j){
if(i === j){continue;}
let edge2=edges[j];
if(edge1.equals(edge2) || edge1.inverse().equals(edge2)){unique=false;break;}
} //end j loop
if(unique){
uniqueEdgesArray.push(edge1);
}
}//end i loop
edges=uniqueEdgesArray;

edges.forEach(function(edge){
triangles.push(new Triangle(edge.v0, edge.v1, vertex));
});//end foreach edges
});//end foreach vertices


triangles=triangles.filter(function(triangle){
return !(triangle.v0 == st.v0 || triangle.v0 == st.v1 || triangle.v0 == st.v2 ||
triangle.v1 == st.v0 || triangle.v1 == st.v1 || triangle.v1 == st.v2 ||
triangle.v2 == st.v0 || triangle.v2 == st.v1 || triangle.v2 == st.v2);
});


return triangles;
}//end triangulate
 
 


function countOccurrences(arr,property,targetValue,conditionProperty, conditionValue){
return arr.reduce((count,obj)=>{
if(obj[property]===targetValue &&obj[conditionProperty]===conditionValue){
return count+1;
}
    return count;
  }, 0);
}



function dropRandom(){
streamSolving=false;
showSolving=false;
showSolvingStatus();

let sampleSize=5;

let sumVertCount=0;
let avgVertCount=0;

let sumFlexCount=0;
let avgFlexCount=0;

let sumVertFlexRatios=0;
let avgVertFlexRatios=0;


let sumDiffColorPairsCount=0;
let avgDiffColorPairsCount=0;

let sumSameColorPairsCount=0;
let avgSameColorPairsCount=0;

let avgDiffSamePairsRatio=0;
let sumDiffSamePairsRatio=0;

let sumPairCount=0;
let avgPairCount=0;

let sumSameFlexibleCount=0;
let avgSameFlexibleCount=0;

let sumVertsInSameColorPairCount=0;
let avgVertsInSameColorPairCount=0;

let vertsInSameColorPairCount=0;

let sumNeighsPerVertex=0;
let avgNeighsPerVertex=0;

let sumColorsPerFlexible=0;
let avgColorsPerFlexible=0;

let maxNeighs=0;
let minNeighs=1000;

for(let r=0;r<sampleSize;r++){
buildAndRender();

let sameColorPairsCount=0;
let diffColorPairsCount=0;
let neighsPerVertex=0;
let colorsPerFlexible=0;

sumVertCount+=vertices.length;
sumPairCount+=pairArr.length;

maxNeighs=0;

for(let v=0;v<vertices.length;v++){
vertices[v].c=randRange(0,3);
neighsPerVertex+=vertices[v].nCount;
if(vertices[v].nCount>maxNeighs){
maxNeighs=vertices[v].nCount;
}
if(vertices[v].nCount<minNeighs){
minNeighs=vertices[v].nCount;
}

//render();
}//end v loop

neighsPerVertex/=vertices.length;
sumNeighsPerVertex+=neighsPerVertex;

for(let j=0;j<pairArr.length;j++){
if(vertices[pairArr[j][0]].c==vertices[pairArr[j][1]].c){
vertices[pairArr[j][0]].inSameColorPair=true;
vertices[pairArr[j][1]].inSameColorPair=true;
sameColorPairsCount++;
}else{
diffColorPairsCount++;
}
}//end j loop

render();
getFlexibles();

for(let f=0;f<flexibles.length;f++){
if(flexibles[f].avail){
colorsPerFlexible+=flexibles[f].colorsAvailable.length;
}//if(flex
}//f loop
sumColorsPerFlexible+=colorsPerFlexible/flexiblesCount;

sumFlexCount+=flexiblesCount;
sumVertFlexRatios+=(vertices.length/flexiblesCount);

sumDiffSamePairsRatio+=(diffColorPairsCount/sameColorPairsCount);

sumSameColorPairsCount+=sameColorPairsCount;
sumDiffColorPairsCount+=diffColorPairsCount;

let sameFlexibleCount=countOccurrences(vertices, 'isFlexible',true,'inSameColorPair',true);
sumSameFlexibleCount+=sameFlexibleCount;


vertsInSameColorPairCount=vertices.filter((obj)=>obj.inSameColorPair==true).length;
sumVertsInSameColorPairCount+=vertsInSameColorPairCount;


}//end r loop

avgColorsPerFlexible=(sumColorsPerFlexible/sampleSize).toFixed(3);

avgNeighsPerVertex=(sumNeighsPerVertex/sampleSize).toFixed(0);

avgVertsInSameColorPairCount=(sumVertsInSameColorPairCount/sampleSize).toFixed(0);


avgSameFlexibleCount=(sumSameFlexibleCount/sampleSize).toFixed(0);

avgPairCount=(sumPairCount/sampleSize).toFixed(0);

avgSameColorPairsCount=(sumSameColorPairsCount
/sampleSize).toFixed(0);

avgDiffColorPairsCount=(sumDiffColorPairsCount
/sampleSize).toFixed(0);

avgDiffSamePairsRatio=(sumDiffSamePairsRatio/sampleSize).toFixed(2);

avgVertCount=(sumVertCount/sampleSize).toFixed(0);
avgPercentVertsInSameColorPair=((avgVertsInSameColorPairCount/avgVertCount)*100).toFixed(0);
avgFlexCount=(sumFlexCount/sampleSize).toFixed(0);
avgVertFlexRatio=(sumVertFlexRatios/sampleSize).toFixed(2);

let avgVertPairPercent=((avgVertCount/avgPairCount)*100).toFixed(0);
let avgVertPairRatio=(avgVertCount/avgPairCount).toFixed(2);
let avgPairsPerVertex=(avgPairCount/avgVertCount).toFixed(2)

el('data').style.display='block';

let dat=[
[`number of graphs sampled:`,sampleSize], 
[`avg # vertices:`,avgVertCount],
[`avg # pairs:`,avgPairCount],
['avg ratio pairs/verts:',avgPairsPerVertex+` x more pairs`],
['avg ratio verts/pairs:',avgVertPairRatio+' ('+avgVertPairPercent+'% of pairs)'],
['avg neighbors per vertex, max, min:',avgNeighsPerVertex+', '+maxNeighs+', '+minNeighs],
[`avg # flexibles:`,avgFlexCount],
[`avg ratio flexibles/vertices:`,
(1/avgVertFlexRatio).toFixed(2)+` (`+((1/avgVertFlexRatio)*100).toFixed(0)+`% of verts)`],
[`avg ratio vertices/flexibles:`,avgVertFlexRatio+` x more verts`],
[`avg # different color pairs:`,avgDiffColorPairsCount],
[`avg # same color pairs:`,avgSameColorPairsCount],
[`avg ratio diff/same pairs:`,avgDiffSamePairsRatio+` times more diff`],
[`avg ratio same/diff pairs:`,(1/avgDiffSamePairsRatio).toFixed(2)+` (`+((1/avgDiffSamePairsRatio)*100).toFixed(0)+`% of same)`],
[`avg % of pairs which are different colors:`,((avgDiffColorPairsCount/avgPairCount)*100).toFixed(0)+`%`],
[`avg % of pairs which are same colors:`,((avgSameColorPairsCount/avgPairCount)*100).toFixed(0)+`%`],
[`avg # verts in at least one same color pair:`,avgVertsInSameColorPairCount+` (`+avgPercentVertsInSameColorPair+`% of all verts)`],
[`avg # flexible verts in same color pairs:`,avgSameFlexibleCount+` (`+((avgSameFlexibleCount/avgFlexCount)*100).toFixed(0)+`% of all flexibles)`],
[`avg % verts in same color pairs which are flexible:`,((avgSameFlexibleCount/avgVertsInSameColorPairCount)*100).toFixed(0)+`%`],
[`avg # alternate colors per flexible:`,avgColorsPerFlexible]
];


let stringer2=`<table style="width:100%;"`;
for(let d=0;d<dat.length;d++){
let t2='t2';
if(isMobile){t2='tm2';}
let t='t';
if(isMobile){t='tm';}
stringer2+=
`<tr><td class="`+t2+`">`+
dat[d][0]
+`</td><td class="`+t+`">`+
dat[d][1]
;
}//end d loop
stringer2+=`</td></tr></table>`;

da('tableId',stringer2);
activeButton('dropRandom');
setTimeout('setDataShowHideButton();',100);
hideMessage(messageTimer);
randomDropping=false;
}//dropRandom





document.body.onkeydown=function(){onKeyDowner(event);}



onKeyDowner=function(event){

if(!typing){
el('selectGraph').blur();
switch(event.key){
case 'i':
vertSizeButtonActions(event);
break;
case 'l':
loadButtonActions(event);
break;
case 'e':
saveGraphButtonActions(event);
break;
case 'w':
toggleFullScreen();
break;
case 'k':
showHide('shortcutKeys');
break;
case '9':
streamSolving=!streamSolving;
break;
case ' ':
canv.click();
showSolvingActions(event);
case 'p':
showSolvingActions(event);
break;
case 's':
solveActions(event);
break;
case 'v': 
stepActions(event);
break;
case 'b':
buildGraphActions(event);
break;
case 'h':
controlPanelOpenClose();
break;
case 'a':
addVertexDelaunayButtonActions(event);
break;
case 'm':
moveVertexDelaunayButtonActions(event);
break;
case 'd':
deleteVertexDelaunayActions(event);
break;
case 'c':
colorVertsActions(event);
break;
case 'y':
//testerButtonActions(event);
break;
case 'n':
numVertsButtonActions(event);
break;
case 'f':
fpsActions(event);
break;
case 't':
solveTimeActions(event);
break;
case 'g':
neighsActions(event);
break;
case 'x':
flexiblesActions(event);
break;j
case 'o':
consoleInputActions(event);
break;
case '1':
addVertButtonActions(event);
break;
case '2':
addLinkedButtonActions(event);
break;
case '3':
linkVertsButtonActions(event);
break;
case '4':
moveVertButtonActions(event);
break;
case '5':
deleteVertButtonActions(event);
break;
case '6':

case '7':

break;
case 'r':
rotateButtonActions(event);
break;
case '0':
curvedLinkButtonActions(event);
break;
case '8':
panZoomButtonActions(event);
break;
}//end switch
}//end if(!typing){
}//end onKeyDowner



function isFullScreen(){
return (document.fullScreenElement && document.fullScreenElement !== null)
|| document.mozFullScreen
|| document.webkitIsFullScreen;
}//end is full screen

function requestFullScreen(){
var el=document.documentElement;
var rfs=el.requestFullscreen
|| el.webkitRequestFullScreen
|| el.mozRequestFullScreen
|| el.msRequestFullscreen;
rfs.call(el);
}//end request full screen 

function exitFullScreen(){
var d=document;
var rfs=d.exitFullscreen
|| d.webkitExitFullscreen
|| d.mozCancelFullScreen
|| d.msExitFullscreen ;
rfs.call(d);
}//end exit fullscreen

function toggleFullScreen(){
if(isFullScreen()){exitFullScreen();
}else{requestFullScreen();
}
}//end toggle full screen





function zoomer(onGraphCenter){
if(zoomingIn){
zoomFactor=1.05;
}else if(zoomingOut){
zoomFactor=.95;
}else{
zoomFactor=1;
}

for(let i=0;i<vertices.length;i++){
if(isThere(vertices[i])){
let subX=vertices[i].x-centerX;
let subY=vertices[i].y-centerY;

let angToVert=Math.atan2(subY,subX);
let distToVert=Math.sqrt(subX*subX+subY*subY);

vertices[i].x=centerX+Math.cos(angToVert)*(distToVert*zoomFactor);
vertices[i].y=centerY+Math.sin(angToVert)*(distToVert*zoomFactor);
}//isThere

}//end i loop

for(let i=0;i<segPoints.length;i++){
if(isThere(segPoints[i])){
for(let s=0;s<segPoints[i].length;s++){
let subX=segPoints[i][s].x-centerX;
let subY=segPoints[i][s].y-centerY;
let angToVert=Math.atan2(subY,subX);
let distToVert=Math.sqrt(subX*subX+subY*subY);
segPoints[i][s].x=centerX+Math.cos(angToVert)*(distToVert*zoomFactor);
segPoints[i][s].y=centerY+Math.sin(angToVert)*(distToVert*zoomFactor);
}//end s loop
}//end if(isThere)
}//end i loop

vertScaler();
render();
}//end zoomer()




function zoomOutButtonDownActions(event){
activeButton('zoomOutButton');
event.preventDefault();
zoomingIn=false;
//zoomingOut=true;
//zoomer(true);
replaceDownEventById('canvas',function(event){
event.preventDefault();
el('expander').blur();
let eventer=eventSwitch(event);
centerX=eventer.pageX;
centerY=eventer.pageY;
zoomingIn=false;
zoomingOut=true;
zoomer();
});//replaceDownEventById('canvas',function(event){
}//zoomOutButtonDownActions
replaceDownEventById('zoomOutButton',zoomOutButtonDownActions);



function zoomOutButtonUpActions(event){
event.preventDefault();
zoomingOut=false;
zoomingIn=false;
el('expander').style.visibility='visible';
}//zoomOutButtonUpActions
replaceUpEventById('zoomOutButton',zoomOutButtonUpActions);



function zoomInButtonDownActions(event){
event.preventDefault();
activeButton('zoomInButton');
//zoomingIn=true;
zoomingOut=false;
//zoomer(true);
replaceDownEventById('canvas',function(event){
event.preventDefault();
el('expander').blur();
let eventer=eventSwitch(event);
centerX=eventer.pageX;
centerY=eventer.pageY;
zoomingIn=true;
zoomingOut=false;
zoomer();
});//replaceDownEventById('canvas',function(event){
}//zoomInButtonDownActions
replaceDownEventById('zoomInButton',zoomInButtonDownActions);



function zoomInButtonUpActions(event){
event.preventDefault();
zoomingOut=false;
zoomingIn=false;
el('expander').style.visibility='visible';
}//zoomInButtonUpActions
replaceUpEventById('zoomInButton',zoomInButtonUpActions);
 


function panButtonActions(event){
event.preventDefault();
activeButton('panButton');
zoomingOut=false;
zoomingIn=false;
replaceDownEventById('canvas',function(event){
event.preventDefault();
el('expander').blur();
let eventer=eventSwitch(event);
activeButton('panButton');
panning=true;
zoomingOut=false;
zoomingIn=false;
lastTouchX=eventer.pageX;
lastTouchY=eventer.pageY;
panner(event);
el('expander').blur();
});//replaceDownEventById('canvas',function(event){
}//panButtonActions
replaceDownEventById('panButton',panButtonActions);




function panner(event){
for(let i=0;i<vertices.length;i++){
vertices[i].x+=event.clientX-lastTouchX;
vertices[i].y+=event.clientY-lastTouchY;
}//end i loop

for(let i=0;i<segPoints.length;i++){
if(isThere(segPoints[i])){
for(let s=0;s<segPoints[i].length;s++){
segPoints[i][s].x+=event.clientX-lastTouchX;
segPoints[i][s].y+=event.clientY-lastTouchY;
}//end s loop
}//if(isThere(segPoints[i]))
}//end i loop
lastTouchX=event.clientX; 
lastTouchY=event.clientY;
render();
}//panner





function vertScaler(){

let miny=100000;
let minx=100000;
let maxy=-100000;
let maxx=-100000;


for(let i=0;i<segPoints.length;i++){
if(isThere(segPoints[i])){
for(let s=0;s<segPoints[i].length;s++){
if(segPoints[i][s].y<miny){miny=segPoints[i][s].y;}
if(segPoints[i][s].x<minx){minx=segPoints[i][s].x;}
}//end s loop
}//if(isThere(segPoints[i]))
}//end i loop


for(let i=0;i<vertices.length;i++){
if(vertices[i].y<miny){miny=vertices[i].y;}
if(vertices[i].x<minx){minx=vertices[i].x;}
}//end i loop


let segPointsTotalLength=0;
for(let i=0;i<segPoints.length;i++){
if(isThere(segPoints[i])){
for(let s=0;s<segPoints[i].length;s++){
if(segPoints[i][s].y>maxy){maxy=segPoints[i][s].y;}
if(segPoints[i][s].x>maxx){maxx=segPoints[i][s].x;}
segPointsTotalLength++;
}//end s loop
}//if(isThere(segPoints[i]))
}//end i loop

let vertsTotalLength=0;
for(let i=0;i<vertices.length;i++){

if(vertices[i].y>maxy){maxy=vertices[i].y;}
if(vertices[i].x>maxx){maxx=vertices[i].x;}
vertsTotalLength++;

}//end i loop


let totalNumVerts=vertsTotalLength+segPointsTotalLength;

let graphArea=(maxx-minx)*(maxy-miny);

let totalVertsArea=totalNumVerts*
((vertSize*2)*(vertSize*2));


//targetRatio=.075;
vertSize=Math.sqrt(graphArea*targetRatio/totalNumVerts)*.5;

//targetRatio=totalVertsArea/graphArea;

//testVars("targetRatio",targetRatio,"graphArea",graphArea,"totalNumVerts",totalNumVerts,"vertSize",vertSize,"totalVertsArea",totalVertsArea);

//testVars("scaleFactor",scaleFactor,"vertSize",vertSize,"totalVertsArea",totalVertsArea,"graphArea",graphArea,"currentRatioVertsAreaToGraphArea",currentRatioVertsAreaToGraphArea,"totalNumVerts",totalNumVerts);

scaleFactor=vertSize*.03;
}//end vertScaler




canv.addEventListener('wheel',function(event){
if(event.deltaY>0){
el('expander').blur();
centerX=event.pageX;
centerY=event.pageY;
zoomingIn=false;
zoomingOut=true;
zoomer();
}else if(event.deltaY<0){
el('expander').blur();
centerX=event.pageX;
centerY=event.pageY;
zoomingIn=true;
zoomingOut=false;
zoomer();
}
zoomingIn=false;zoomingOut=false;
});//canv.addEventListener('wheel',func...


function middleButtonPan(event){
if(event.button===1&&panning){
event.preventDefault();
activeButton('panButton');
panning=true;
zoomingOut=false;
zoomingIn=false;
lastTouchX=event.clientX;
lastTouchY=event.clientY;
panner(event);
el('expander').blur();
}//if(event.button===1&&panning){
}//middleButtonPan

canv.addEventListener('pointerdown',(event)=>{
middleButtonPan(event);});

canv.addEventListener('mousedown',(event)=>{
middleButtonPan(event);});




</script>

</body>
</html>
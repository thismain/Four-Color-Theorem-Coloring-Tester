<html>
<head>
<meta name="viewport" content="width=device-width,initial-scale=.25"></meta>
<!--<script src="redirectToDesktop.js"></script>-->
<style>
.b{
font-size:40px;
font-family:monospace;
visibility:visible;
position:relative;
background-color:#ffffff;
padding:40px;
border:1px solid #000000;
}


.t{
width:70%;
border-bottom:1px solid #cdcdcd;
margin:0px;
font-size:40px;

}
.t2{
width:30%;
border-bottom:1px solid #cdcdcd;
margin:0px;
padding:4px;
padding-left:50px;
font-size:40px;

}

.container::-webkit-scrollbar{display:none;}/* Safari and Chrome */
.container{-ms-overflow-style:none; /* Internet Explorer 10+ */
scrollbar-width: none;  /* Firefox */}

</style>
</head>
<body id="bodyer" style="font-family:monospace;overflow:hidden;margin:0px;padding:0px;">
<script>

var usePHP=true; 
var serverAddress='http://moygen.rf.gd/graph2/';
//var serverAddress='http://172.18.11.218:45267/';
//var serverAddress='http://48.52.212.109:45267/';
var streamSolving=true;
var numPoints=50;
let isLive=serverAddress.indexOf('moygen');
if(isLive>=0){
streamSolving=true;
numPoints=50;
}else{
streamSolving=false;
numPoints=30;
}

var scaleFactor=1;
var EPSILON=1.0e-6;
var Vertex;
var Triangle;
var Edge;
var triangulate;
var edges;
var vertices;
var triangles;
var vertPairs;
var pairString='';
var fourColor=["red","gold","MediumSeaGreen","DeepSkyBlue","white"];
var fourColorShort=['R','Y','G','B','W'];
var savedData=[];
var triColors=[];
var dragging=false;
var dragStart=false;
var altKey=false;
var inset=125;
var vertexToEdit=-1;
var backgroundColor='#f5f5f5';
var dataFileName="default.txt";
var numSavedGraphs=0;
var graphFileNames=[];
var dataSend='';
var dataReceive=null;
var getDataInterval=0;
var stringArr=[];
var pairArr=[];
var segPoints=[];
var segCounter=0;
var settingSegPoints=[];
var curvedLinkStart=-1;
var curvedLinkEnd=-1;
var gettingCurvedLinkStart=false;
var gettingCurvedLinkEnd=false;
var tapMessageShown=false;
var setRandomVerts=true;
var sortedVerts=[];
var counter=0;
var colorSavedGraph=false;
var xray=false;
var sameColorVerts=[];
var highlightSame=true;
var sortString='';
var searcher=[];
var lastSearcher=[];
var nonNeighbor=[];
var numSolves=0;
var solveCounter=0;
var chunkSolveString='';
var allSolvesString='';
var nIndexString='';
var loopingDetected=false;
var solveRemainingPass=0; 
var loopCounter=0;
var tripleCheck=false;
var framesPerSecond=30;
var pauser=false;
var showSolving=true;
var stillSearching=false;
var animId=0;
var rColorGraphDone=false;
var animSV=0;
var stepping=false;
var solved=false;
var loading=true;
var showNumNeigh=false;
var solving=false;
var timeToSolve=0;
var startTime=Date.now();
var endTime=Date.now();
var deltaTime=endTime-startTime;
var lastButton='buildRandomGraph';
var messageTimer=0;
var building=false;
var flexibles=[];
var showFlexibles=true;
var flexibleColor='#db37d9';
var numSolvesCounter=0;
var randomDropping=false;

var gettingLinkStart=false;
var addingVert=false;
var linkStart=-1;
var linkEnd=-1;
var startConnecting=false;
var endConnecting=false;
var delaunay=true;
var flexiblesCount=0;
var diffColorPairsCount=0;
var sameColorPairsCount=0;
var zoomFactor=.8;
var zoomInFactor=1.1;
var zoomOutFactor=.9; 
var zoomingIn=false;
var zoomingOut=false;
var centerX=0;
var centerY=0;
var panning=false;
var lastTouchX=null;
var lastTouchY=null;
var targetRatio=.075;
var defaultRatio=targetRatio;
var vertSizeDecrease=false;
var vertSizeIncrease=false;
var selectedLineWidth=80;

var vertSize=35;
var diam=110;
var maxDiam=120;
var minDiam=56;
var moveRaw=false;
var randOnlySome=.29;

var buildTimer=0;clearTimeout(buildTimer);
var solveTimer=0;clearTimeout(solveTimer);
var numVertsTimer=0;clearTimeout(numVertsTimer);
var animateTimer=0;clearTimeout(animateTimer);

function clamp(a,min,max){
if(a<min){a=min;}else if(a>max){a=max;}
return a;
}//end clamp

function fixAngleRad(a){if(a>Math.PI){a-=Math.PI*2;}else if(a<-Math.PI){a+=Math.PI*2;}return a;}


function getDeltaTime(){
deltaTime=endTime-startTime;
}//end getDeltaTime

function zoom(elm,scale,w,h){
elm.style.transform="scale("+scale+")";
elm.style.transformOrigin="top left";
elm.style.width=(w/scale)+"%";
elm.style.height=(h/scale)+"%";
}//end zoom



</script>

<div id="consoleInputDiv" style="width:1200px;z-index:10000000;position:fixed;left:50px;top:10px;font-size:40px;font-family:monospace;background-color:#ffffff;padding:40px;border:1px solid black;visibility:hidden;height:450px;overflow:scroll;">

<input id="consoleInput" type="text"  value="pairArr" style="font-family:monospace;color:black;font-size:25px;border:1px solid black;zoom:4;word-wrap:break-word;" size="18">
<br>
<input value="Enter" type="button" ontouchstart="da('tester','<br>'+eval(el('consoleInput').value));da('consoler','<br>'+eval(el('consoleInput').value));" style="position:absolute;display:block;font-size:60px;padding:30px;margin-top:12px;bottom:0px;right:0px;">

<div id="consoler"  style="width:1200px;height:300px;display:block;font-size:60px;margin-top:12px;background-color:white;">Enter a Variable</div>
</div>




<div id="tester"  style="color:white;background-color:black;position:absolute;left:70px;top:100px;z-index:10000;font-size:30px;padding:6px;border:6px solid white;display:none;width:1200px;height:1600px;word-wrap:break-word;padding:50px;padding-bottom:0px;padding-top:0px;overflow:scroll;"></div>

<div id="messageHolder" style="position:absolute;left:450px;top:500px;padding:90px;border:12px solid black;display:none;z-index:10000000;background-color:white;">

<div id="message" style="display:block;white-space:nowrap;font-family:monospace;font-weight:bold;color:black;font-size:60px;line-height:70px;text-align:center;">
</div>
</div>


<iframe id="ifr" src="" style="display:none;z-index:1000;position:absolute;top:2000px;left:10px;height:1800px;width:1200px;border:1px solid black;">
</iframe>


<canvas id="canvas" width="440" height="550" style="position:absolute;left:0px;top:0px;z-index:100;"></canvas>





<select id="selectGraph" onchange="clearInterval(waitGraphDataInt);waitGraphDataInt=0;hideMessage(messageTimer);showMessage('Loading Graph...',60000);setRandomVerts=false;dataFileName=graphFileNames[parseInt(this.options[this.selectedIndex].value)];buildAndRender();" style="z-index:10000000;font-size:40px;font-family:monospace;background-color:#ffffff;border:12px solid #000000;display:none;position:absolute;top:100px;left:250px;padding:30px;">
<option disabled selected id="label">Load Graph</option>
</select>



<div id="filenameInputDiv" style="z-index:10000000;position:fixed;left:50px;bottom:1000px;font-size:30px;font-family:monospace;background-color:#ffffff;padding:40px;border:1px solid black;display:none;height:40px">


Filename:
<input id="enterGraphName" type="text"  value="" style="display:inline-block;font-family:monospace;color:black;font-size:30px;border:1px solid black;" size="30">

<br>

<input value="save" type="button" ontouchstart="dataFileName=el('enterGraphName').value+'.txt';el('filenameInputDiv').style.display='none';saveGraphData();"  style="display:inline-block;font-size:30px;margin-top:12px;">

<input value="cancel" type="button" ontouchstart="el('filenameInputDiv').style.display='none';" style="display:inline-block;font-size:30px;margin-top:12px;">

</div>






<div id="expander" ontouchstart="controlPanelOpenClose();" style="text-align:center;right:0px;position:fixed;font-weight:bold;font-size:65px;font-family:monospace;white-space:nowrap;background-color:#ffffff;padding:20px;border:1px solid #000000;bottom:0px;z-index:10000000000;visibility:visible;width:120px">  -  
</div>

<div id="buttonHolder" style="text-align:justify;white-space:nowrap;z-index:1000;position:fixed;background-color:#ffffff;padding:10px;
;overflow:hidden;" ontouchstart="event.preventDefault();">
 


<input id="about" type="button" value="About" ontouchstart="event.preventDefault();activeButton(this.id);showHide('aboutDiv');" class="b">



<input id="streamSolve" type="button" value="stream" 
ontouchstart="event.preventDefault();activeButton('streamSolve');streamSolving=!streamSolving; if(streamSolving){solved=false;for(let v=0;v<vertices.length;v++){vertices[v].c=4;}} showSolvingButton();"    
class="b">



<input id="showSolving" type="button" value="Solving " 
ontouchstart="showSolvingActions();" class="b">


<input id="solve" type="button" value="Solve" 
ontouchstart="solveActions();" class="b">


<input id="step" type="button" value="Step" ontouchstart="stepActions();" class="b">

<input id="verSizeButton" type="button" value="VertSize" ontouchstart="event.preventDefault();activeButton(this.id);showHide('vertSizeControls');" class="b" style="display:inline-block;">



<br>
 
<input id="buildRandomGraph" type="button" value="BuildGraph" ontouchstart="buildGraphActions();" class="b">

<input id="addVertex" type="button" value="AddVert" 
ontouchstart="event.preventDefault();activeButton(this.id);canv.ontouchstart=function(e){e.preventDefault();delaunay=true;mouseAdd_Vertex(e);solved=false;}"    
class="b">



<input id="moveVertex" type="button" value="MoveVert" 
ontouchstart="event.preventDefault();activeButton(this.id);canv.ontouchstart=function(e){e.preventDefault();delaunay=true;el('expander').style.visibility='hidden';dragging=true;dragStart=true;moveRaw=false;getVertexToEdit(e);solved=false;}" class="b">

<input id="deleteVertex" type="button" value="DeleteVert" 
ontouchstart="event.preventDefault();activeButton(this.id);canv.ontouchstart=function(e){e.preventDefault();delaunay=true;getVertexToEdit(e);deleteVertex(e,true);solved=false;}"    
class="b">




<br> 

<input id="colorVerts" type="button" value="ColorVerts" ontouchstart="event.preventDefault();activeButton(this.id);canv.ontouchstart=function(e){e.preventDefault();getVertexToEdit(e);changeVertexColor(e);solved=false;}" class="b">

<input id="numberOfVerts" type="button" value="NumVerts" ontouchstart="event.preventDefault();activeButton(this.id);el('enterNumVerts').value=numPoints;showHideV('numVertsInputDiv');" class="b">

<input id="fpsId" type="button" value="FPS" ontouchstart=" activeButton(this.id);el('enterFPS').value=parseInt(framesPerSecond);showHideV('fpsInputDiv');" class="b">

<input id="timeToSolveId" type="button" value="SolveTime" ontouchstart="event.preventDefault();activeButton(this.id);showMessage('Solved in: '+deltaTime+' ms<br> after '+ numSolvesCounter+' steps',2000);" class="b">




<input id="neighs" type="button" value="Neighs" 
ontouchstart="event.preventDefault();activeButton(this.id);if(showNumNeigh){showNumNeigh=false;}else{showNumNeigh=true;}render();" class="b">


<br>


<input type="button" value="Flexibles" id="flexiblesButton"
ontouchstart="event.preventDefault();activeButton(this.id);showFlexibles=!showFlexibles;render();" class="b" style="display:none;">


<input id="dropRandom" type="button" value="Random" 
ontouchstart="event.preventDefault();activeButton(this.id);buildGraphActions();el('selectGraph').style.display='none';el('filenameInputDiv').style.display='none';randomDropping=true;showMessage('Running Samples',60000);setTimeout('dropRandom();',300);"    
class="b" style="display:inline-block">




<input type="button" value="Console" id="consoleButton"
ontouchstart="event.preventDefault();activeButton(this.id);showHideV('consoleInputDiv');render();" class="b" style="display:none">


<input type="button" value="panZoom" id="panZoomButton"
ontouchstart="event.preventDefault();activeButton('panZoomButton');showHide('panZoomControls');" class="b">



<input type="button" value="rotate" id="scaleButton"
ontouchstart="event.preventDefault();activeButton(this.id);graphRotater();canv.ontouchstart=function(e){graphRotater();}" class="b">


<input type="button" value="save" id="saveGraphButton"
ontouchstart="event.preventDefault();activeButton(this.id);showHide('filenameInputDiv');" class="b" >


<input type="button" value="load" id="loadGraphButton"
ontouchstart="event.preventDefault();activeButton(this.id);streamSolving=false;showSolvingStatus();showHide('selectGraph');" class="b">


<input type="button" value="curvedLink" id="addCurveButton"
ontouchstart="event.preventDefault();activeButton(this.id);if(!tapMessageShown){tapMessageShown=true;showMessage('Tap dotted<br>line between <br>unlinked nodes',3000);}gettingCurvedLinkStart=true;curvedLink();" class="b">

<br>






<!--daa('tester','numPoints:'+numPoints+' --- diam:'+diam+' --- vertSize:'+vertSize+'<br><br>');-->

<br>

<input type="button" value="add" id="addButton"
ontouchstart="event.preventDefault();activeButton(this.id);startConnecting=false;gettingLinkStart=false;endConnecting=false;canv.ontouchstart=function(e){e.preventDefault();delaunay=false;el('expander').style.visibility='hidden';mouseAdd_Vertex(e);solved=false;}" class="b">

<input type="button" value="addLinked" id="addVertButton"
ontouchstart="event.preventDefault();activeButton(this.id);startConnecting=false;gettingLinkStart=true;endConnecting=false;canv.ontouchstart=function(e){e.preventDefault();delaunay=false;el('expander').style.visibility='hidden';getVertexToEdit(e);solved=false;}" class="b">

<input type="button" value="Link" id="linkVertsButton"
ontouchstart="event.preventDefault();activeButton(this.id);gettingLinkStart=false;startConnecting=true;endConnecting=false;canv.ontouchstart=function(e){e.preventDefault();delaunay=false;el('expander').style.visibility='hidden';getVertexToEdit(e);solved=false;}" class="b">

 
<input id="moveVertButton" type="button" value="Move" 
ontouchstart="event.preventDefault();activeButton(this.id);startConnecting=false;endConnecting=false;gettingLinkStart=false;canv.ontouchstart=function(e){e.preventDefault();delaunay=false;el('expander').style.visibility='hidden';dragging=true;dragStart=true;moveRaw=true;getVertexToEdit(e);solved=false;}" class="b">

<input id="deleteVertButton" type="button" value="Delete" 
ontouchstart="event.preventDefault();activeButton(this.id);startConnecting=false;endConnecting=false;gettingLinkStart=false;canv.ontouchstart=function(e){e.preventDefault();delaunay=false;getVertexToEdit(e);deleteVertex(e,false);solved=false;}"    
class="b">


<input type="button" value="Tester" id="testerButton"
ontouchstart="event.preventDefault();activeButton(this.id);showHide('tester');el('tester').scrollTop=el('tester').scrollHeight;" class="b" style="display:none;">

<br>



</div><!--end buttonHolder-->

<div id="numVertsInputDiv" style="font-size:50px;font-family:monospace;visibility:hidden;z-index:1000000;position:fixed;left:100px;bottom:0px;background-color:#ffffff;padding:30px;border:6px solid #000000;">

Number of Vertices:
<input id="enterNumVerts" type="text"  size="3" value="60" style="background-color:black;color:caret-color:white;font-family:monospace;color:white;font-size:70px;padding:10px"
ontouchstart="">

<input id="numVertsApply" value="Apply" type="button" ontouchstart="activeButton(this.id);showMessage('Building Graph',60000);flexibles=[];numPoints=parseInt(el('enterNumVerts').value);graphRenderScaleFactors();el('numVertsInputDiv').style.visibility='hidden';building=true;buildRandomGraphButton();setRandomVerts=true;setTimeout('buildAndRender();',100);"  style="display:inline-block;font-size:50px;padding:10px;">

<input value="cancel" type="button" ontouchstart="el('numVertsInputDiv').style.visibility='hidden';" style="display:inline-block;font-size:50px;padding:10px;">

</div>


<div id="fpsInputDiv" style="font-size:50px;font-family:monospace;visibility:hidden;z-index:1000000;position:fixed;left:100px;bottom:0px;background-color:#ffffff;padding:30px;border:6px solid #000000;">


FPS (1-60):
<input id="enterFPS" type="text"  size="3" value="" style="font-family:monospace;color:black;font-size:50px;padding:10px">

<input value="Apply" type="button" ontouchstart="framesPerSecond=parseInt(el('enterFPS').value);if(framesPerSecond<1){framesPerSecond=1;}else if(framesPerSecond>120){framesPerSecond=120;}el('fpsInputDiv').style.visibility='hidden';"  style="display:inline-block;font-size:50px;padding:10px;">

<input value="cancel" type="button" ontouchstart="el('fpsInputDiv').style.visibility='hidden';" style="display:inline-block;font-size:50px;padding:10px;">

</div>



<div id="panZoomControls" style="font-size:50px;font-family:monospace;z-index:1000000;position:fixed;left:200px;bottom:0px;background-color:#ffffff;padding:80px;padding-top:20px;padding-bottom:20px;border:6px solid #000000;display:none;" ontouchstart="event.preventDefault();">
 
<input id="fitButton" value="FIT" type="button" ontouchstart="event.preventDefault();activeButton('fitButton');graphRotater(0);" style="display:inline-block;font-size:60px;padding:20px;width:200px;">

<input id="zoomOutButton" value=" - " type="button" style="display:inline-block;font-size:60px;padding:20px;font-weight:bold;width:200px;">

<input id="zoomInButton" value=" + " type="button" style="display:inline-block;font-size:60px;padding:20px;width:200px;">

<input id="panButton" value="PAN" type="button"  style="display:inline-block;font-size:60px;padding:20px;width:200px;">

<input value=" X " type="button" ontouchstart="event.preventDefault();el('panZoomControls').style.display='none';" style="display:inline-block;font-size:30px;padding:10px;position:absolute;right:0px;bottom:0px;">
</div>


<div id="vertSizeControls" style="font-size:50px;font-family:monospace;z-index:1000000;position:fixed;left:200px;bottom:0px;background-color:#ffffff;padding:80px;padding-top:20px;padding-bottom:20px;border:6px solid #000000;display:none;" ontouchstart="event.preventDefault();">
 
<input id="resetButton" value="Reset" type="button" ontouchstart="event.preventDefault();activeButton('resetButton');targetRatio=defaultRatio;vertScaler();render();" style="display:inline-block;font-size:60px;padding:20px;width:200px;">

<input id="vertSizeDownButton" value=" - " type="button" style="display:inline-block;font-size:60px;padding:20px;font-weight:bold;width:200px;" ontouchstart="event.preventDefault();vertSizeDecrease=true;" ontouchend="vertSizeDecrease=false;">

<input id="vertSizeUpButton" value=" + " type="button" style="display:inline-block;font-size:60px;padding:20px;width:200px;" ontouchstart="vertSizeIncrease=true;" ontouchend="vertSizeIncrease=false;">

<input value=" X " type="button" ontouchstart="event.preventDefault();el('vertSizeControls').style.display='none';" style="display:inline-block;font-size:30px;padding:10px;position:absolute;right:0px;bottom:0px;">
</div>




<div class="container" id="aboutDiv" style="background-color:white;position:absolute;left:30px;top:30px;z-index:10000;border:2px solid black;display:none;height:70%;overflow:auto;padding:10px;margin:0px;">
<div id="aboutDivHeading" style="border:2px solid black;color:white;background-color:#000000;font-family:monospace;padding:10px;padding-left30px;margin:0px;position:fixed;left:30px;top:30px;z-index:10001;font-size:40px;height:60px">
<b>&nbsp;A javascript program for four coloring planar graphs</b>

</div>
<div style="background-color:#ffffff;font-family:serif;padding:10px;font-size:30px;text-align:left-justify;line-height:34px">
<br><br>
The github files are here:<br>
<a href="https://github.com/thismain/Four-Color-Theorem-Coloring-Tester" target="_blank">https://github.com/thismain/Four-Color-Theorem-Coloring-Tester</a>
<br><br>
The live Desktop demo is here:<br>
<a href="http://moygen.rf.gd/graph2/desktop.html" target="_blank">http://moygen.rf.gd/graph2/desktop.html</a>
<br><br>
The live Mobile demo is here:<br>
<a href="http://moygen.rf.gd/graph2/index.html" target="_blank">http://moygen.rf.gd/graph2/index.html</a>
<br><br>
<img src="http://moygen.rf.gd/graph2/screenshotter.png">
<br><br>
This is a javascript program for four coloring planar graphs. It has solved hundreds of graphs of 600 or fewer vertices. The lowest time to solve for 600 vertices was 28ms, although the average is around 300ms. I use delaunay triangulation, from <a href="https://travellermap.com/tmp/delaunay.js" target="_blank">Joshua Bell's code</a>, to generate random graphs, and these graphs may be modified, either with or without delaunay triangulation. 
<br><br>
The best part of this program, I think, is watching the animation of the algorithm solving the graph at a human observable speed. 
<br><br>
<b>The algorithm:</b><br>
I recently found a faster way. I had been sorting the vertices by number of neighbors, and using high priority colors on vertices of high degree of connectivity, which would get colored first, and low priority colors on vertices of low degree of connectivity, which would get colored last. However, It turns out, it's faster to just go through the vertices as they were set down when building the graph, from the top of the screen to the bottom, applying colors in the same order each time, when they can be applied without conflict.
<br><br>
After the algorithm has gone through the whole graph this way, it then goes back to the vertices for which no color was available. It searches the neighbors of the uncolored vertex for the neighbors with the fewest fellows of their own color. If there are more than one neighbors with only one fellow of the same color, the algorithm chooses the neighbor of the highest priority color. The algorithm assigns the color of that neighbor to the uncolored vertex and then repeats the same process for that neighbor, excluding the vertex which just took its color. 
<br><br>
When the algorithm goes into a loop of following the same circuit over and over, it kicks itself out of the loop with a random choice of either the second or third choice of neighbors from which to take a color, where the neighbors have been sorted by the number of fellows of the same color. 
<br><br>
Finally, the algorithm triple checks the graph for any neighboring vertices of the same color and proceeds in the same manner to fix them.
<br><br>
The reason I made this program is because I wanted to find out why the 4CT is true, and I reasoned that the best way to find that out would be to see why the algorithms that work do work, and how they can be made to work less well and broken. 
<br><br>
I wonder whether a neural network can learn from billions of correctly colored graphs to recognize patterns in strings of permutations of numbers of neighbors and immediately know what colors the vertices can be. So it would solve the graph the way a rubik's cube is solved, rather than searching for the correct solution in real time.
<br><br>
<hr>
<br>
What would a sufficient reason require? Obviously, it would need to explain why five colors are never necessary, but it would also need to show why three colors are sometimes not possible, and what are the conditions that must occur for a three-colorable graph to become a four-colorable one. An analysis of how a graph can, or must, be modified to go from requiring only three colors, to requiring four colors, and also from two to three, and from one to two, would be useful. I'd love to identify and parameterize some property or properties of planar graphs that results in the flexibility we find in assigning colors. But for such a property to be proven to be the operative four-coloring mechanism one would need to show that only the coloring algorithms that exploit this property work, and algorithms that do not exploit this property do not work, and those that only partly make use of this property only partly work. Which task would require that one had first set up the environment for testing several and various algorithms, so as to compare and rate their performance. To this end I imagine identifying the complete set of discrete components which comprise every four coloring algorithm, and from this set of modules choosing, and their parameters adjusting in turn, so as to evaluate the change in effectiveness wrought thereby.
<br><br>
In reality my code is very messy, but still I dream.
<br><br>
What might those modules be? Let's number them:
<br><br>
1) Sorting nodes by numbers of neighbors<br>
2) Assigning the four colors levels of priority<br>
3) Sorting neighbors by number of a color<br>
4) Behavior when no color is available<br>
5) Color transfer from neighbor to uncolored<br> node, or to a conflicted node<br>
6) Loop detection and breaking<br>
7) Self checking the result<br>
8) Order of coloring<br>
9) ...
<br><br>
It turns out to have been unnecessary to worry about complexity increasing with increasing numbers of vertices and with increasing numbers of connections for each node. The hardest graph anyone can contrive will be trivial to color by a sufficient algorithm. There's always enough flexibility in the choice of colors so as to allow for changing colors along a path until a node is encountered that is only neighbored by nodes of two colors, or by one. I think it's worthwhile to mention at the start of anyone's exposure to the 4CT that if four colors are randomly dropped onto one thousand randomly built graphs, the ratio of differently colored neighbors to same colored neighbors averages out to three to one; three differently colored neighbors for every one that is the same color, or 75% different, 25% same.
<br><br>
-----------------
<br><br>

After solving graphs manually and watching the algorithm solve graphs in a similar way, one develops an intuition for the reason the four color theorem is true. But articulating this feeling requires much ratiocination and accounting for all possible cases, not to mention a careful definition of terms along the way, which often interferes with the flow of the logic of one's argument. Then also, any exposition which does not rest upon quantifiable statstical relationships rings hollow. It's easy to suppose that there's a certain minimum degree of flexibility which is common to all four-colored planar graphs, where flexibility is defined as the option to be one or two colors other than one's own, without conflict. But it's not so easy to statistically quantify this minimum degree of flexibility. Everyone can see that conflicted nodes can be resolved by swapping colors along a path toward a flexible node, and it also becomes obvious that this flexibility is deriving from the inevitable isolation of every node from the rest of the graph by its neighbors. But how can one show, without testing every possible kind of case, that this local principle of isolation will always yield enough flexibility to four-color any graph?
<br><br>


</div>

</div>



<div class="container" id="data" style="background-color:white;position:absolute;left:30px;top:30px;z-index:10000;border:2px solid black;display:none;height:70%;overflow:auto;padding:10px;margin:0px;">
<div id="dataHeading" style="border:2px solid black;color:white;background-color:#000000;font-family:monospace;padding:10px;margin:0px;position:fixed;left:30px;top:30px;z-index:10001;font-size:40px;">
<b>Random Drop of Colors: Data for Analysis:</b>

</div>
<div style="background-color:#ffffff;font-family:monospace;padding:10px;">
<br><br><br><br>
<table id="tableId" style="width:100%;"></table>
</div>

</div>

<input type="button" value="show/hide" id="dataShowHideButton" ontouchstart="showHide('data');" style="display:none;text-align:center;color:#bbbbbb;top:12px;right:12px;font-size:35px;color:black;padding-top:5px;padding-bottom:8px;padding-left:8px;padding-right:8px;height:55px;width:245px;background-color:dddddd;border: 2px solid #bbbbbb;position:absolute;font-family:monospace;z-index:10002;"></div>


<script>


function el(a){return document.getElementById(a);}
function da(a,b){if(el(a)){el(a).innerHTML=b;
//el(a).style.display='block';
}}
function daa(a,b){if(el(a)){el(a).innerHTML+=b;
//el(a).style.display='block';
}}
function randRange(min, max){return Math.floor(Math.random() * (max - min + 1)) + min;}
function degToRad(a){return a*Math.PI/180;}
function isThere(a){return(typeof a!=="undefined"&&typeof a!==null&&(a||a==0)&&a!=NaN);}
function els(a){return document.getElementById(a).style;}
function showHide(a){if(els(a).display=='block'){els(a).display='none'}else{els(a).display='block'}}

function showHideV(a){if(els(a).visibility=='visible'){els(a).visibility='hidden'}else{els(a).visibility='visible'}}

//testVars("someVar"someVar,"someOtherVar",someOtherVar);
function testVars(...args){
let stringVars='';
for(let i=0;i<args.length;i++){
if(i==0||i%2==0){
stringVars+=args[i]+': '+args[i+1]+'<br>';
}
}//end i loop
daa('tester',stringVars+'<br>');
}//end testVars


var ww=window.innerWidth;
var hh=window.innerHeight;
var canv=document.getElementById("canvas");
var ctx=canv.getContext('2d');

var cW,cH;
function canvSetSize(){
canv.width=window.innerWidth;
canv.height=window.innerHeight;
cW=canv.width;
cH=canv.height;
canv.style.width=cW+"px";
canv.style.height=cH+"px";
canv.style.left=(ww/2-cW/2)+'px';
}//end canvSetSize

canvSetSize(); 

//showHide('loadGraphButton');
//showHide('saveGraphButton');


el('data').style.width=ww*.93+'px';
el('dataHeading').style.width=ww*.93+'px';
el('aboutDiv').style.width=ww*.93+'px';
el('aboutDivHeading').style.width=ww*.93+'px';

function setDataShowHideButton(){
let dataRect=el('data').getBoundingClientRect();
el('dataShowHideButton').style.right=(ww-dataRect.width-16).toFixed()+'px';
el('dataShowHideButton').style.top=(dataRect.top+6).toFixed()+'px';
el('dataShowHideButton').style.display='block';

}//end setDataShowHideButton




function activeButton(buttonId){
if(lastButton=='zoomInButton'||lastButton=='zoomOutButton'||lastButton=='fitButton'||lastButton=='panButton'){
el(lastButton).style.backgroundColor='#eeeeee';
}else{
el(lastButton).style.backgroundColor='white';
}
el(buttonId).style.backgroundColor='#dbedff';
lastButton=buttonId;
if(lastButton!='dropRandom'){el('dataShowHideButton').style.display='none';el('data').style.display='none';}
if(lastButton!='about'){el('aboutDiv').style.display='none';}
if(lastButton!='curvedLink'&&gettingCurvedLinkEnd){
gettingCurvedLinkStart=false;
gettingCurvedLinkEnd=false;
curvedLinkStart=-1;
curvedLinkEnd=-1;
segPoints[pairArr.length]=null;
settingSegPoints[pairArr.length]=false;
segCounter=0;
render();
}//end if(lastButton!='curvedLink'

}//activeButton




el('messageHolder').style.left=ww*.3+'px';
el('messageHolder').style.top=hh*.3+'px';


var bhStyle=getComputedStyle(el('buttonHolder'));var bhHeight=bhStyle.height;
var cpClosedPos=parseInt(window.innerHeight*2)+'px';
var cpOpenPos='10px';

 
el('buttonHolder').style.width=ww+'px';
el('buttonHolder').style.bottom=cpOpenPos;
//el('expander').style.bottom=parseInt(bhHeight)+30+'px';


function controlPanelOpenClose(){
if(el('buttonHolder').style.bottom==cpClosedPos){
el('buttonHolder').style.bottom=cpOpenPos;
da('expander','-');
}else{
el('buttonHolder').style.bottom=cpClosedPos;
da('expander','+');
}
}//end controlPanelOpenClose



el('fpsInputDiv').style.bottom=parseInt(bhHeight)+100+'px';
el('numVertsInputDiv').style.bottom=parseInt(bhHeight)+100+'px';

var showBoolCounter=1;
function showBools(buttonValue, marker){
if(!marker){marker=showBoolCounter;}
daa('tester',buttonValue+' '+marker+': <br>stepping:'+stepping+'<br> solving:'+solving+' <br> solved:'+solved+' <br>  rColorGraphDone:'+rColorGraphDone+' <br>showSolving: '+showSolving+'<br>-----------------<br>');
el('tester').scrollTop=el('tester').scrollHeight;
showBoolCounter++;
}//end showBools

function showBools2(buttonValue){
if(!marker){marker=showBoolCounter;}
daa('tester',buttonValue+': <br>startConnecting:'+startConnecting+'<br> endConnecting:'+endConnecting+' <br> linkStart:'+linkStart+' <br>  linkEnd:'+linkEnd+' <br>showSolving: '+showSolving+'<br>-----------------<br>');
el('tester').scrollTop=el('tester').scrollHeight;
showBoolCounter++;
}//end showBools

var waitFilenamesInt=0;

function getGraphFilenames(){
graphFileNames=null;
if(usePHP){
el('ifr').src=serverAddress+'filenameReader.php';
waitFilenamesInt=setInterval(function(){
if(isThere(el('ifr').contentWindow.filenames)){
graphFileNames=JSON.parse(el('ifr').contentWindow.filenames);
clearInterval(waitFilenamesInt);
waitFilenamesInt=0;
numSavedGraphs=graphFileNames.length;
initSelectGraph();
}//if(isThere(el('ifr').contentWindow.filenames)){

},50);
}//if usePHP
}//end get graph filenames

function initSelectGraph(){
for(let i=0;i<numSavedGraphs;i++){
let op=document.createElement("option");
op.id='op'+i;
op.value=i;
op.text=graphFileNames[i];
el('selectGraph').appendChild(op);
}//end i loop
//el('op0').selected="selected";
}//end init select graph

var waitGraphDataInt=0;

function getGraphData(){
if(usePHP){

el('ifr').src=serverAddress+"saver.php?loading=1&dataFileName="+dataFileName;
waitGraphDataInt=setInterval("loadGraphData();",1000);

}//usePHP
}//end getGraphData




function loadGraphData(){
canvSetSize();
reSolverReset();
dataReceive=null;
dataReceive=el('ifr').contentWindow.dataSend;
if(isThere(dataReceive)){
clearInterval(waitGraphDataInt);
waitGraphDataInt=0;
hideMessage(messageTimer);

if(dataReceive.indexOf('[')>=0){
delaunay=false;

segPoints=[];
let segPointString='';
let segPointsCopy=[];


if(dataReceive.lastIndexOf('] [[')>=0){

segPointString=dataReceive.substring(0,dataReceive.lastIndexOf('] [[')+1);

segPoints=JSON.parse(segPointString);

segPointsCopy=JSON.parse(JSON.stringify(segPoints));

if(isThere(segPoints)){
dataReceive=
dataReceive.replace(segPointString+' ','');
}
}//end if(dataReceive.


let pairArrString=dataReceive.substring(0,dataReceive.lastIndexOf(']')+1);
pairArr=JSON.parse(pairArrString);

dataReceive=
dataReceive.replace(pairArrString+' ','');

if(isThere(segPointsCopy)){
for(let i=0;i<pairArr.length;i++){
segPoints[i]=null;
for(let m=0;m<segPointsCopy.length;m++){
if(segPointsCopy[m][0].pairIndex==i){
segPoints[i]=JSON.parse(JSON.stringify(segPointsCopy[m]));
}//==
}//end m loop 
}//end i loop
}//if(isThere(segPoints)){


}//if(dataReceive.indexOf('[')>=0){


stringArr=dataReceive.split(" ");

for(let i=0;i<stringArr.length;i+=4){
vertices.push(new Vertex(parseInt(stringArr[i]),parseInt(stringArr[i+1]),parseInt(stringArr[i+2]),parseInt(stringArr[i+3])));

if(delaunay){
triangles=triangulate(vertices);
}
}//end i loop

sortByNeighborCount();
autoRotate();
graphRotater(0); 
dataReceive=null; 
}//end isThere

}//end loadGraphData







function saveGraphData(){
if(usePHP){
let graphData='';
for(let i=0;i<vertices.length;i++){
graphData+=parseInt(vertices[i].x)+' '+parseInt(vertices[i].y)+' '+vertices[i].c+' '+vertices[i].i;
if(i<vertices.length-1){graphData+=' ';}
}//end i loop

if(!delaunay){
removeDuplicatePairs();
let segPointsCopy=[];
for(let i=0;i<segPoints.length;i++){
segPointsCopy[i]=segPoints[i];
}//end i loop
let sp='';
if(isThere(segPointsCopy)){
for(let i=segPointsCopy.length-1;i>=0;i--){
if(!isThere(segPointsCopy[i])){
segPointsCopy.splice(i,1);
}
}//end i loop

for(let i=0;i<segPointsCopy.length;i++){
if(isThere(segPointsCopy[i])){
for(let s=0;s<segPointsCopy[i].length;s++){
segPointsCopy[i][s].x=parseInt(segPointsCopy[i][s].x);
segPointsCopy[i][s].y=parseInt(segPointsCopy[i][s].y);
}//s loop
}//isThere
}//end i loop

sp=JSON.stringify(segPointsCopy)+' ';
}
graphData=sp+JSON.stringify(pairArr)+' '+graphData;
}

/*
let pairArr=[[675,89],[98,2],[8,7]];
let dataSaved=JSON.stringify(pairArr);
pairArr=JSON.parse(dataSaved);
*/


if(!el('op'+numSavedGraphs)){
graphFileNames.push(dataFileName);
el('ifr').src=serverAddress+"saver.php?graphData="+graphData+"&saving=1&dataFileName="+dataFileName;
let op=document.createElement("option");
op.id='op'+numSavedGraphs;
op.value=numSavedGraphs;
op.text=dataFileName;
el('selectGraph').appendChild(op);
numSavedGraphs++;
}//end if(!el
}//usePHP
}//end saveGraphData






function autoRotate(){
let miny=100000;
let minx=100000;
let maxy=-100000;
let maxx=-100000;


for(let i=0;i<segPoints.length;i++){
if(isThere(segPoints[i])){
for(let s=0;s<segPoints[i].length;s++){
if(segPoints[i][s].y<miny){miny=segPoints[i][s].y;}
if(segPoints[i][s].x<minx){minx=segPoints[i][s].x;}

if(segPoints[i][s].y>maxy){maxy=segPoints[i][s].y;}
if(segPoints[i][s].x>maxx){maxx=segPoints[i][s].x;}

}//end s loop
}//if(isThere(segPoints[i]))
}//end i loop


for(let i=0;i<vertices.length;i++){
if(vertices[i].y<miny){miny=vertices[i].y;}
if(vertices[i].x<minx){minx=vertices[i].x;}
if(vertices[i].y>maxy){maxy=vertices[i].y;}
if(vertices[i].x>maxx){maxx=vertices[i].x;}
}//end i loop

let gH=maxy-miny;
let gW=maxx-minx;

if((cW>cH&&gH/gW>1)||(cW<cH&&gH/gW<1)){
graphRotater();}

}// end autoRotate






function graphRotater(angle){
let margin=vertSize*3;


let graphAng=-90*Math.PI/180;
if(isThere(angle)){
graphAng=angle*Math.PI/180;
}


for(let i=0;i<segPoints.length;i++){
if(isThere(segPoints[i])){
for(let s=0;s<segPoints[i].length;s++){
if(isThere(segPoints[i][s])){
let dist=Math.sqrt(segPoints[i][s].y*segPoints[i][s].y+segPoints[i][s].x*segPoints[i][s].x);

let ang=Math.atan2(segPoints[i][s].y,segPoints[i][s].x);
ang+=graphAng; 
segPoints[i][s].y=Math.sin(ang)*dist;
segPoints[i][s].x=Math.cos(ang)*dist;
}//if(isThere(segPoints[i][s])){
}//end s loop
}//if(isThere(segPoints[i]))
}//end i loop



for(let i=0;i<vertices.length;i++){
let dist=Math.sqrt(vertices[i].y*vertices[i].y+vertices[i].x*vertices[i].x)
let ang=Math.atan2(vertices[i].y,vertices[i].x);
ang+=graphAng;
vertices[i].y=Math.sin(ang)*dist;
vertices[i].x=Math.cos(ang)*dist;
}//end i loop



let miny=100000;
let minx=100000;
let maxy=-100000;
let maxx=-100000;


for(let i=0;i<segPoints.length;i++){
if(isThere(segPoints[i])){
for(let s=0;s<segPoints[i].length;s++){
if(segPoints[i][s].y<miny){miny=segPoints[i][s].y;}
if(segPoints[i][s].x<minx){minx=segPoints[i][s].x;}
}//end s loop
}//if(isThere(segPoints[i]))
}//end i loop


for(let i=0;i<vertices.length;i++){
if(vertices[i].y<miny){miny=vertices[i].y;}
if(vertices[i].x<minx){minx=vertices[i].x;}
}//end i loop



for(let i=0;i<segPoints.length;i++){
if(isThere(segPoints[i])){
for(let s=0;s<segPoints[i].length;s++){

segPoints[i][s].y-=miny-margin;
segPoints[i][s].x-=minx-margin;

}//end s loop
}//if(isThere(segPoints[i]))
}//end i loop


for(let i=0;i<vertices.length;i++){
vertices[i].y-=miny-margin;
vertices[i].x-=minx-margin;
}



for(let i=0;i<segPoints.length;i++){
if(isThere(segPoints[i])){
for(let s=0;s<segPoints[i].length;s++){

if(segPoints[i][s].y>maxy){maxy=segPoints[i][s].y;}
if(segPoints[i][s].x>maxx){maxx=segPoints[i][s].x;}

}//end s loop
}//if(isThere(segPoints[i]))
}//end i loop


for(let i=0;i<vertices.length;i++){
if(vertices[i].y>maxy){maxy=vertices[i].y;}
if(vertices[i].x>maxx){maxx=vertices[i].x;}
}//end i loop



let wRatio=(cW-margin)/(maxx+margin);//((maxx+margin)-(minx-margin));
let hRatio=(cH-margin)/(maxy+margin);//((maxy+margin)-(miny-margin));


for(let i=0;i<segPoints.length;i++){
if(isThere(segPoints[i])){
for(let s=0;s<segPoints[i].length;s++){
if(isThere(segPoints[i][s])){
if(wRatio<hRatio){
segPoints[i][s].x*=wRatio;
segPoints[i][s].y*=wRatio;
}else{
segPoints[i][s].x*=hRatio;
segPoints[i][s].y*=hRatio;
}
}//if(isThere(segPoints[i][s])){
}//end s loop
}//if(isThere(segPoints[i]))
}//end i loop




for(let i=0;i<vertices.length;i++){
if(wRatio<hRatio){
vertices[i].x*=wRatio;
vertices[i].y*=wRatio;
}else{
vertices[i].x*=hRatio;
vertices[i].y*=hRatio;
}
}//end i loop

vertScaler();
render();

//testVars("miny",miny,"maxy","minx",minx,"maxx",maxx); 
}//end graphRotater








function graphRenderScaleFactors(){

diam=Math.sqrt(cW*cH/numPoints*randOnlySome);
/*
vertSize=clamp(.25*diam,minVertSize,maxVertSize);
*/
}//graphRenderScaleFactors

graphRenderScaleFactors();





function changeVertexColor(e){
if(isThere(vertices[vertexToEdit])){
vertices[vertexToEdit].c++;
if(vertices[vertexToEdit].c>3){
vertices[vertexToEdit].c=0;
}
render();
}//is There
}// end changeVertexColor


canv.ontouchend=function(e){
event.preventDefault();
if(dragging){vertexToEdit=-1;}
dragging=false;
panning=false;
zoomingOut=false;
zoomingIn=false;
el('expander').style.visibility='visible';
render();
}//end ontouchend



canv.ontouchmove=function(e){
if(dragging){
el('expander').style.visibility='hidden';
if(moveRaw){
moveVertex(e,delaunay=false);
}else{
moveVertex(e,delaunay=true);
}
sortByNeighborCount();
render();
}//if(dragging)
else if(panning){
el('expander').style.visibility='hidden';
panner(e);
}//if(panning)
}//end ontouchmove



function showSolvingActions(){
event.preventDefault();
activeButton('showSolving');
if(!showSolving&&solved&&!stepping){
reSolverReset();
for(let v=0;v<vertices.length;v++){
vertices[v].c=4;}
}//if(!showSolving&&
showSolvingButton();
canv.ontouchstart=function(e){showSolvingActions();}
}//end showSolvingActions


function solveActions(){
event.preventDefault();
activeButton('solve');
stepping=false;
pauser=false;
showSolving=false;
streamSolving=false;
solving=true;
solveButton();
for(let v=0;v<vertices.length;v++){
vertices[v].c=4;} 
startTime=Date.now();
recursiveNeighborSolver();
canv.ontouchstart=function(e){solveActions();}
}//end solveActions



function stepActions(){
event.preventDefault();
activeButton('step');
if(!showSolving&&solved&&!stepping){
reSolverReset();
for(let v=0;v<vertices.length;v++){
vertices[v].c=4;}
}//end if(!showSolving&
solved=false;
stepping=true;
stepper();
showSolving=false;
showSolvingStatus();
canv.ontouchstart=function(e){stepActions();}
}//end stepActions


function buildGraphActions(){
event.preventDefault();
activeButton('buildRandomGraph');
building=true;
showSolving=false;
streamSolving=false;
showSolvingStatus();
showMessage('Building Graph',60000);
buildRandomGraphButton();
setRandomVerts=true;
setTimeout('buildAndRender();',50);
canv.ontouchstart=function(e){buildGraphActions();}
}//buildGraphActions







function moveVertex(e,delaunay){
if(vertexToEdit>=0){
let lastx=vertices[vertexToEdit].x;
let lasty=vertices[vertexToEdit].y;
vertices[vertexToEdit].x=e.touches[0].pageX;
vertices[vertexToEdit].y=e.touches[0].pageY;
let moveDifx=[];
let moveDify=[];
ctx.clearRect(0,0,cW,cH);
if(delaunay){triangles=triangulate(vertices);}

for(let i=0;i<pairArr.length;i++){
if(pairArr[i][0]==vertexToEdit||pairArr[i][1]==vertexToEdit){
if(isThere(segPoints[i])){
moveDifx[i]=vertices[vertexToEdit].x-lastx;
moveDify[i]=vertices[vertexToEdit].y-lasty;
let fac=.98;
let facFac=.7;

let difx0=segPoints[i][1].x-vertices[vertexToEdit].x;
let dify0=segPoints[i][1].y-vertices[vertexToEdit].y;
let distToSeg0=Math.sqrt(difx0*difx0+dify0*dify0);

let difxL=segPoints[i][segPoints[i].length-1].x-vertices[vertexToEdit].x;
let difyL=segPoints[i][segPoints[i].length-1].y-vertices[vertexToEdit].y;
let distToSegLength=Math.sqrt(difxL*difxL+difyL*difyL);

if(distToSeg0<=distToSegLength){//forward loop

for(let s=0;s<segPoints[i].length-1;s++){
moveDifx[i]*=fac;
segPoints[i][s].x+=moveDifx[i];
moveDify[i]*=fac;
segPoints[i][s].y+=moveDify[i];
fac*=facFac;
}//end s loop
 
}else if(distToSeg0>distToSegLength){//backward loop

for(let s=segPoints[i].length-1;s>=0;s--){
moveDifx[i]*=fac;
segPoints[i][s].x+=moveDifx[i];
moveDify[i]*=fac;
segPoints[i][s].y+=moveDify[i];
fac*=facFac;
}//end s loop

}//end if(distToSeg0>distToSegLength){
}//isThere segPoints
}//if(pairArr[i][0]==vertexToEdit||pairArr[i][1]==vertexToEdit){
}//end i loop

render();
}//if(vertexToEdit>=0){
}//end moveVertex


function mouseAdd_Vertex(e){
ctx.clearRect(0,0,cW,cH);
vertices.push(new Vertex(e.touches[0].pageX,e.touches[0].pageY,4,vertices.length+1));
if(delaunay){
triangles=triangulate(vertices);
}
sortByNeighborCount();
render();
}//end mouseAdd_Vertex



function curvedLink(){
curvedLinkEnd=-1;
curvedLinkStart=-1;
segCounter=0;
canv.ontouchstart=function(e){
e.preventDefault();
el('expander').style.visibility='hidden';
delaunay=false;
vertexToEdit=-1;
let alreadyConnected=false;

for(let i=0;i<vertices.length;i++){
ctx.beginPath();
ctx.arc(vertices[i].x, vertices[i].y, vertSize*2, 0, Math.PI * 2, true);
if(ctx.isPointInPath(e.touches[0].pageX, 
e.touches[0].pageY)){
vertexToEdit=i;


ctx.lineWidth=selectedLineWidth*scaleFactor;
ctx.strokeStyle=fourColor[vertices[vertexToEdit].c];
ctx.stroke();


if(gettingCurvedLinkStart){
gettingCurvedLinkStart=false;
gettingCurvedLinkEnd=true;
curvedLinkStart=vertexToEdit;
segPoints[pairArr.length]=[];
segPoints[pairArr.length][segCounter]={
pairIndex:pairArr.length,
x:parseInt(vertices[curvedLinkStart].x),
y:parseInt(vertices[curvedLinkStart].y)
};
settingSegPoints[pairArr.length]=true;
segCounter++;

}else if(gettingCurvedLinkEnd){

curvedLinkEnd=vertexToEdit;
for(let i=0;i<pairArr.length;i++){
if(
(curvedLinkEnd==pairArr[i][0]&&curvedLinkStart==pairArr[i][1])||
(curvedLinkEnd==pairArr[i][1]&&curvedLinkStart==pairArr[i][0])){
alreadyConnected=true;
curvedLinkEnd=-1;
curvedLinkStart=-1;
gettingCurvedLinkStart=true;
segPoints[pairArr.length]=null;
segCounter=0;
showMessage('Already Connected',3000);
}//end if already connected
}//end i loop


if(!alreadyConnected){
gettingCurvedLinkEnd=false;
settingSegPoints[pairArr.length]=false;
segPoints[pairArr.length][segCounter]={
x:parseInt(vertices[curvedLinkEnd].x),
y:parseInt(vertices[curvedLinkEnd].y)
};

 
if(curvedLinkStart>=0&&curvedLinkEnd>=0){
pairArr.push([curvedLinkStart,curvedLinkEnd]);
removeDuplicatePairs();
curvedLinkStart=curvedLinkEnd;
curvedLinkEnd=-1;
segCounter=0;
segPoints[pairArr.length]=[];
segPoints[pairArr.length][segCounter]={
pairIndex:pairArr.length,
x:parseInt(vertices[curvedLinkStart].x),
y:parseInt(vertices[curvedLinkStart].y)
};
settingSegPoints[pairArr.length]=true;
segCounter++;
gettingCurvedLinkEnd=true;

}//if(curvedLinkStart>=
}//end if(gettingCurvedLinkEnd){


}//end if(!alreadyConnected){
}//ctx.isPointInPath
}//i loop

ctx.closePath();

if(!alreadyConnected){
if(settingSegPoints[pairArr.length]){
segPoints[pairArr.length][segCounter]={
x:parseInt(e.touches[0].pageX),
y:parseInt(e.touches[0].pageY)
};
segCounter++;
}//end if(settingSegPoints[pairArr.length]){
}//end if(!alreadyConnected){

sortByNeighborCount();
//render();
}//end function(e)

}//end curvedLink



function getVertexToEdit(e){
e.preventDefault();
vertexToEdit=-1;
for(let i=0;i<vertices.length;i++){
ctx.beginPath();
ctx.arc(vertices[i].x, vertices[i].y, vertSize*2, 0, Math.PI * 2, true);


if(ctx.isPointInPath(e.touches[0].pageX,e.touches[0].pageY)){
vertexToEdit=i;

ctx.lineWidth=selectedLineWidth*scaleFactor;
ctx.strokeStyle=fourColor[vertices[vertexToEdit].c];
ctx.stroke();

if(!delaunay){
if(gettingLinkStart){
linkStart=vertexToEdit;
addingVert=true;
//gettingLinkStart=false;
canv.ontouchstart=function(e){
e.preventDefault();
el('expander').style.visibility='hidden';
if(addingVert){
ctx.clearRect(0,0,cW,cH);
vertices.push(new Vertex(e.touches[0].pageX,e.touches[0].pageY,4,vertices.length));
linkEnd=vertices.length-1;
if(linkStart>=0&&linkEnd>=0&&linkStart!=linkEnd){
pairArr.push([linkStart,linkEnd]);
segPoints.push(null);
removeDuplicatePairs();
linkStart=linkEnd;
}//end if(linkStart
sortByNeighborCount();
render();
//addingVert=false;
}//end adding vert
}//end function(e)

}else if(startConnecting){
addingVert=false;
linkStart=vertexToEdit;
startConnecting=false;
endConnecting=true;

}else if(endConnecting){
addingVert=false;
delaunay=false;
linkEnd=vertexToEdit;

if(linkStart>=0&&linkEnd>=0&&linkStart!=linkEnd){
pairArr.push([linkStart,linkEnd]);
segPoints.push(null);
removeDuplicatePairs();

linkStart=linkEnd;
}
sortByNeighborCount();
//render();
//endConnecting=false;

}//end if(endConnecting){
}//if(!delaunay

if(dragStart){dragStart=false;}

}//ctx.isPointInPath
}//i loop
ctx.closePath();
//testVars("gettingLinkStart",gettingLinkStart,"startConnecting",startConnecting,"endConnecting",endConnecting,"linkStart",linkStart,"linkEnd",linkEnd,"pairArr[pairArr.length-1][0]",pairArr[pairArr.length-1][0],"pairArr[pairArr.length-1][1]",pairArr[pairArr.length-1][1]);
}//end getVertexToEdit





function deleteVertex(e,delaunay){
if(vertexToEdit>=0){
vertices.splice(vertexToEdit,1);
for(let v=0;v<vertices.length;v++){
vertices[v].i=v;}

if(!delaunay){
for(let i=pairArr.length-1;i>=0;i--){
if(vertexToEdit==pairArr[i][0]||vertexToEdit==pairArr[i][1]){
pairArr.splice(i,1);
segPoints.splice(i,1);
}
}//i loop
delaunay=false;
}//!delaunay

//ctx.clearRect(0,0,cW,cH);
if(delaunay){
triangles=triangulate(vertices);
}


for(let j=0;j<pairArr.length;j++){
if(pairArr[j][0]>vertexToEdit){
pairArr[j][0]--;}
if(pairArr[j][1]>vertexToEdit){
pairArr[j][1]--;}
}//j loop


sortByNeighborCount();
render();
}//>=0
}//end deleteVertex




function getVertexPairs(){
if(delaunay){
pairArr=[];
segPoints=[];
settingSegPoints=[];

for(let i=0;i<triangles.length;i++){
pairArr.push([triangles[i].v0.i, triangles[i].v1.i]);
//segPoints.push(null);
pairArr.push([triangles[i].v0.i, triangles[i].v2.i]);
//segPoints.push(null);
pairArr.push([triangles[i].v1.i, triangles[i].v2.i]);
//segPoints.push(null);
}//i loop

}//if(delaunay)

removeDuplicatePairs();
}//end getVertexPairs



//remove duplicate pairs
function removeDuplicatePairs(){
for(let i=pairArr.length-1;i>=1;i--){
for(let j=i-1;j>=0;j--){
if(isThere(pairArr[i])
&&
isThere(pairArr[j])){
if(
(pairArr[i][0]==pairArr[j][0]
&&
pairArr[i][1]==pairArr[j][1])
||
(pairArr[i][0]==pairArr[j][1]
&&
pairArr[i][1]==pairArr[j][0])
){
pairArr.splice(i,1);
segPoints.splice(i,1);
}
}//end isThere
}//end j loop
}//end i loop
}//removeDuplicatePairs



function getNeighbors(){
getVertexPairs();
for(let v=0;v<vertices.length;v++){
vertices[v].n=[];
for(let i=0;i<pairArr.length;i++){
if(
v==pairArr[i][0]
){
vertices[v].n.push(pairArr[i][1]);
}else if(
v==pairArr[i][1]
){
vertices[v].n.push(pairArr[i][0]);
}
if(i==pairArr.length-1){
vertices[v].nCount=vertices[v].n.length;
}
}//end i loop
}//end v loop
}//end get neighbors



function sortByNeighborCount(){
getNeighbors();
sortedVerts=[];
for(let v=0;v<vertices.length;v++){
sortedVerts[v]={nCount:vertices[v].nCount,i:vertices[v].i,n:vertices[v].n};
}
sortedVerts.sort((a,b)=>b.nCount-a.nCount);
}//end sortByNeighborCount



function colorGraph(){
for(let v=0;v<vertices.length;v++){
vertices[v].c=4;}

for(let v=0;v<sortedVerts.length;v++){
for(let c=0;c<4;c++){
let colorAvailable=true;
for(let n=0;n<sortedVerts[v].nCount;n++){
if(isThere(vertices[sortedVerts[v].n[n]])){
if(vertices[sortedVerts[v].n[n]].c==c){
colorAvailable=false;break;
}
}//isThere
}//end n loop
if(colorAvailable){vertices[sortedVerts[v].i].c=c;break;}
}//end c loop
}//end v loop
}//end colorGraph



function solveButton(){
if(solving&&el('solve').value=='Solve'){
el('solve').value='Solving...';
el('solve').style.backgroundColor='#ffd7d4';
}else if(!solving&&el('solve').value=='Solving...'){
el('solve').value='Solve';
el('solve').style.backgroundColor='#dbedff';
}
}//end solveButton



function buildRandomGraphButton(){
if(building&&el('buildRandomGraph').value=='Build Random Graph'){
el('buildRandomGraph').value='Building..........';
el('buildRandomGraph').style.backgroundColor='#ffd7d4';
}else if(!building&&el('buildRandomGraph').value=='Building..........'){
el('buildRandomGraph').value='Build Random Graph';
el('buildRandomGraph').style.backgroundColor='#dbedff';
}
}//end buildRandomGraphButton




function showSolvingButton(){
if((el('showSolving').value=='Solving||'||el('showSolving').value=='Paused \ >')&&showSolving&&!stepping){
pauser=!pauser;}
stepping=false;
solving=false;
showSolving=true;
showSolvingStatus();
if(pauser){
el('showSolving').value='Paused \ >';
el('showSolving').style.backgroundColor='#ffd7d4';
}else if(!pauser||streamSolving){el('showSolving').value='Solving||';}
}//end showSolvingButton




function showSolvingStatus(){
if(showSolving){
el('showSolving').style.backgroundColor='#dbedff';
el('showSolving').value='Solving||';
}else{
el('showSolving').style.backgroundColor='white';
el('showSolving').value='Solving';
}

if(streamSolving){
el('streamSolve').style.backgroundColor='#ffd7d4';
}else{
el('streamSolve').style.backgroundColor='#ffffff';
}
}//end showSolvingStatus


//called once onload

function animInit(){
cancelAnimationFrame(animId);
animId=0;
stepping=false;
rColorGraphDone=false;
solved=false;
showSolvingStatus();
pauser=false;
animSV=0;
animate();
//setTimeout("activeButton('showSolving');showSolvingButton();",500);
}//end animInit


function animate(){
clearTimeout(animateTimer);
animateTimer=setTimeout(function(){
animId=requestAnimationFrame(animate);

if(streamSolving&&loading){solved=false;loading=false;
buildAndRender();activeButton('showSolving');showSolvingButton();
}else if(streamSolving&&solved){solved=false;
setTimeout("buildAndRender();activeButton('showSolving');showSolvingButton();",2000);
}

if(zoomingIn||zoomingOut){setTimeout("zoomer();",20);}


if(vertSizeDecrease){
if(targetRatio>.01){
targetRatio*=.95;vertScaler();render();
}
}

if(vertSizeIncrease){ 
targetRatio*=1.05;vertScaler();render();
}

if(showSolving&&!pauser&&!stepping){
recursiveNeighborSolver();
render();
}//end showSolving&&!&&pauser
},1000/framesPerSecond);//end setTimeout
}//end animate



function stepper(){
showSolving=false;
recursiveNeighborSolver();
render();
}//end stepper



function recursiveNeighborSolver(){

numSolves++; numSolvesCounter=numSolves;
//daa('tester','<br><br>'+numSolves+'  -----------------<br>');

stillSearching=false;
let stringer='';
let errorString='';
let checkCounter=0;

nonNeighbor=[];
for(let s=0;s<lastSearcher.length;s++){
nonNeighbor[s]=lastSearcher[s];
}
searcher=[];
lastSearcher=[];


nextVertex:
for(let v=0;v<vertices.length;v++){
let neighArray=[];
let neighColorCount=[];
let colorAvailable=[true,true,true,true];

if(vertices[v].c==4||vertices[v].searching){
stillSearching=true;

for(let n=0;n<vertices[v].nCount;n++){
if(isThere(vertices[vertices[v].n[n]])){
let nColor=vertices[vertices[v].n[n]].c;
neighArray.push({
i:vertices[v].n[n],
color:nColor
});

colorAvailable[nColor]=false;
}//isThere
}//end n loop

for(let c=0;c<4;c++){
if(colorAvailable[c]&&c!=vertices[v].c){
vertices[v].c=c;
vertices[v].searching=false;
if(showSolving||stepping){render();return;}else{
continue nextVertex;
}
}//if(colorAvailable[c]
}//end c loop

let colorCounter=[];
for(let c=0;c<4;c++){
colorCounter[c]= neighArray.filter((obj)=>obj.color==c).length;

let nIndex=neighArray.filter(x=>x.color===c).map(x=>x.i);


let isNeigh=true;
for(let nn=0;nn<nonNeighbor.length;nn++){
for(let j=0;j<nIndex.length;j++){
if(nonNeighbor[nn]==nIndex[j]){isNeigh=false;}

}//end j loop
}//end nn loop

if(isNeigh){
neighColorCount.push({
nIndex:nIndex,
color:c, 
count:colorCounter[c]
});
}//isNeigh
}//end c loop

neighColorCount.sort((a,b)=>
a.count-b.count
||
a.color-b.color);

let ind=0;
if(loopingDetected){ind=randRange(1,2);
loopCounter++;
if(loopCounter>2){
loopingDetected=false;
}
}

if(isThere(neighColorCount[ind])&&isThere(neighColorCount[ind].nIndex[0])){

vertices[v].c=vertices[neighColorCount[ind].nIndex[0]].c;


for(let j=0;j<neighColorCount[ind].nIndex.length;j++){
searcher.push(neighColorCount[ind].nIndex[j]);

}//end j loop

lastSearcher.push(vertices[v].i);

//daa('tester','<br>vertex index: '+vertices[v].i+' --- neighColorCount[0].nIndex: '+JSON.stringify(neighColorCount[0].nIndex)+'<br><br>');


//for looping detection
for(let i=0;i<neighColorCount[0].nIndex.length;i++){
nIndexString+=neighColorCount[0].nIndex[i]+' ';
}//i loop

chunkSolveString+=vertices[v].i+' '+nIndexString;
allSolvesString+=vertices[v].i+' '+nIndexString;


solveCounter++;
if(solveCounter==2){
solveCounter=0;


let regEx=new RegExp(chunkSolveString,'g');
let matchCount=(allSolvesString.match(regEx)||[]).length;

if(matchCount>1){
loopingDetected=true;
if(numSolves%13==0){
//alert('looping detected');
}
//daa('tester','looping detected '+numSolves);
}

chunkSolveString='';
nIndexString='';
}//end if solveCounter greater than
//end looping detection


stringer+='<br>vertex index: '+vertices[v].i+' --- '+JSON.stringify(neighColorCount)+' -  .nIndex.length: '+neighColorCount[0].nIndex.length+'<br><br>';

}//isThere neighColorCount
}//end if .c==4

//solve remaining same colored pairs
if(v==vertices.length-1&&(!stillSearching||tripleCheck)){

lastSearcher=[];
let foundUnsolved=false;

for(let i=0;i<pairArr.length;i++){
if(isThere(vertices[pairArr[i][0]])&&isThere(vertices[pairArr[i][1]])){
if(
vertices[pairArr[i][0]].c==
vertices[pairArr[i][1]].c
){

vertices[pairArr[i][0]].searching=true;
vertices[pairArr[i][1]].searching=true;
lastSearcher.push(vertices[pairArr[i][0]].i);
lastSearcher.push(vertices[pairArr[i][1]].i);
vertices[pairArr[i][0]].c=0;
vertices[pairArr[i][1]].c=0;

solveRemainingPass++;
foundUnsolved=true;

}//if same color
}//isThere
}//end i loop

if(foundUnsolved){v=0;
}else if(!tripleCheck){
v=0;
checkCounter++;
if(checkCounter>3){
tripleCheck=true;}
}//if !tripleCheck
}//if v==vertices.length-1
//end solve remaining same colored pairs

}//end v loop


for(let v=0;v<vertices.length;v++){
vertices[v].searching=false;
for(let s=0;s<searcher.length;s++){
if(searcher[s]==vertices[v].i){
vertices[v].searching=true;
}
}//end s loop

if(v==vertices.length-1){

el('tester').scrollTop=el('tester').scrollHeight;

if(stillSearching==false){
endTime=Date.now();
deltaTime=endTime-startTime;
//alert('all solved');
if(showSolving||stepping){showMessage('All Solved',2000);
stepping=false;
}
if(solving){
showMessage('Solved in: '+deltaTime+' ms',2000);
solving=false;solveButton();
}
rColorGraphDone=false;
solved=true;
animSV=0;
showSolving=false;
showSolvingStatus();
pairString='';
numSolves=0;
solveCounter=0;
chunkSolveString='';
loopingDetected=false;
nIndexString='';
solveRemainingPass=0;
tripleCheck=false;

render();
return;
}else if(stillSearching==true){


if(numSolves==40){
animSV=0;
}else if(numSolves==100){
tripleCheck=false;
checkCounter=0;
}else if(numSolves==10000){

alert('still solving after numSolves:'+numSolves+' so...returning.');
return;
}

if(!showSolving&&!pauser&&!stepping){
recursiveNeighborSolver();
}
}//if stillSearching
}//if(v==vertices.length-1){
}//end v loop
}//end recursiveNeighborSolver


function showMessage(messageString,time){
el('messageHolder').style.display='block';
el('messageHolder').ontouchstart=function(e){el('messageHolder').style.display='none';}
da('message',messageString);
messageTimer=setTimeout("el('messageHolder').style.display='none';",time);
}//end show message

function hideMessage(timerId){
clearTimeout(timerId);
el('messageHolder').style.display='none';
}//hide message


function reSolverReset(){

solving=false;
solved=true;
animSV=0;
showSolving=false;
showSolvingStatus();
pairString='';
numSolves=0;
solveCounter=0;
chunkSolveString='';
loopingDetected=false;
nIndexString='';
solveRemainingPass=0;
tripleCheck=false;
pairString='';
da('tester','');
allSolvesString='';
}//end resolver reset


function getFlexibles(){
flexibles=[];

for(let v=0;v<vertices.length;v++){
flexibles[v]={
avail:false,
i: vertices[v].i,
colorsAvailable:[]
};
if(vertices[vertices[v].i].c!=4){
let colorAvailable=[true,true,true,true];
for(let c=0;c<4;c++){
for(let n=0;n<vertices[v].nCount;n++){
if(isThere(vertices[vertices[v].n[n]])){
if(
(vertices[v].c==c)||
(vertices[vertices[v].n[n]].c==c)){
colorAvailable[c]=false;
break;//next color
}
}//isThere
}//end n loop

if(colorAvailable[c]){
vertices[v].isFlexible=true;
flexibles[v].avail=true;
flexibles[v].colorsAvailable.push(fourColorShort[c]);
}

}//end c loop
}//!=4
}//end v loop

flexiblesCount=
flexibles.filter((obj)=>obj.avail==true).length;

}//end getFlexibles



function buildAndRender(){
canvSetSize();
vertices=[];
triangles=[];
pairArr=[];
segPoints=[];
settingSegPoints=[];
pairString='';
numSolves=0;
solveCounter=0;
chunkSolveString='';
allSolvesString='';
loopingDetected=false;
nIndexString='';
solveRemainingPass=0;
tripleCheck=false;
rColorGraphDone=false;
solved=false;
solving=false;
showSolving=false;
linkStart=-1;
linkEnd=-1;
delaunay=true;

let radius=diam*.5;
let offset=.5*radius;
let onlySome=0;
let pointCounter=0;
let resizeCanv=false;

if(setRandomVerts){
for(let y=diam;y<cH-radius;y+=diam){
if(pointCounter>=numPoints){break;}
for(let x=radius*1.7;x<cW-radius;x+=diam){
let randOffX=randRange(-offset,offset);
let randOffY=randRange(-offset,offset);
onlySome=randRange(1,30);
if(onlySome>20){
vertices.push(new Vertex(x+randOffX,y+randOffY,4,pointCounter,0,[],false));
pointCounter++;
triangles=triangulate(vertices);

if(pointCounter>=numPoints){break;}
}//onlySome
}//end x loop
}//end y loop

vertScaler();

sortByNeighborCount();
if(!showSolving){
render();
}

}else if(!setRandomVerts&&!randomDropping){
getGraphData();

}//end if(!setRandomVerts

building=false;
//activeButton('buildRandomGraph');
if(setRandomVerts&&!randomDropping){
buildRandomGraphButton();
hideMessage(messageTimer);
}

}// end buildAndRender





var fonter=30;
function render(){
 
for(let v=0;v<vertices.length;v++){
vertices[v].i=v;}


if(showFlexibles){getFlexibles();}

//drawBackground
ctx.beginPath();
ctx.globalAlpha=1;
ctx.fillStyle=backgroundColor;//d6d651
ctx.fillRect(0, 0, cW, cH);
ctx.closePath();

//drawFrame that saves to image
ctx.globalAlpha=.4;
ctx.lineWidth=4;
ctx.strokeStyle='black';
ctx.strokeRect(0, 0, cW, cH);
ctx.lineWidth=2;
//end drawFrame


if(delaunay){
//draw triangles
ctx.globalAlpha=1;
let i=0;
triangles.forEach(function(triangle){
ctx.beginPath();
ctx.moveTo(triangle.v0.x, triangle.v0.y);
ctx.lineTo(triangle.v1.x, triangle.v1.y);
ctx.lineTo(triangle.v2.x, triangle.v2.y);
ctx.closePath();
ctx.strokeStyle="black";
ctx.lineWidth=1;
ctx.stroke();
//ctx.fillStyle='transparent';//triColors[i];
//ctx.fill();
i++;
});//end triangles foreach

}//!custom



if(!delaunay){
ctx.globalAlpha=1;


if(settingSegPoints[pairArr.length]&&isThere(segPoints[pairArr.length])){

for(let s=0;s<segPoints[pairArr.length].length;s++){
ctx.beginPath();
ctx.arc(segPoints[pairArr.length][s].x, segPoints[pairArr.length][s].y, vertSize, 0, Math.PI * 2, true);
ctx.closePath();
ctx.fillStyle='white';
ctx.fill();
ctx.strokeStyle='black';
ctx.lineWidth=1;
ctx.stroke();
}//end s loop
}//if settingSegPoints[pairArr.length]


for(let i=0;i<pairArr.length;i++){
if(isThere(vertices[pairArr[i][0]])&&isThere(vertices[pairArr[i][1]])){

if(isThere(segPoints[i])&&!settingSegPoints[i]){

ctx.beginPath();
ctx.moveTo(segPoints[i][0].x, segPoints[i][0].y);

for(let s=1;s<segPoints[i].length-2;s++){
let xc=(segPoints[i][s].x+segPoints[i][s+1].x)/2;
let yc=(segPoints[i][s].y+segPoints[i][s+1].y)/2;
ctx.quadraticCurveTo(
segPoints[i][s].x, 
segPoints[i][s].y, 
xc, yc);
}//end s loop

// Connect the last two points
ctx.quadraticCurveTo(
segPoints[i][segPoints[i].length-2].x,
segPoints[i][segPoints[i].length-2].y,
segPoints[i][segPoints[i].length-1].x,
segPoints[i][segPoints[i].length-1].y
);

//ctx.closePath();


}else if(!isThere(segPoints[i])){

 
ctx.beginPath();

ctx.moveTo(
vertices[pairArr[i][0]].x, 
vertices[pairArr[i][0]].y);

ctx.lineTo(
vertices[pairArr[i][1]].x,
vertices[pairArr[i][1]].y);
ctx.closePath();

}//if(!isThere(segPoints[i])){


ctx.strokeStyle='black';
ctx.lineWidth=1;
ctx.stroke();

}//if(isThere(vertices[pairArr[i][0]])&&
}//end i loop
}//if !delaunay



//highlight same color vertices link


if(highlightSame){

sameColorVerts=[];
for(let i=0;i<pairArr.length;i++){
sameColorVerts[i]=false;
}

for(let i=0;i<pairArr.length;i++){
if(isThere(vertices[pairArr[i][0]])&&isThere(vertices[pairArr[i][1]])){
if(vertices[pairArr[i][0]].c==vertices[pairArr[i][1]].c){
sameColorVerts[i]=true;
}//end if
}//isThere
}//end i loop


for(let i=0;i<pairArr.length;i++){

if(sameColorVerts[i]&&!isThere(segPoints[i])){

ctx.beginPath();
ctx.moveTo(vertices[pairArr[i][0]].x, vertices[pairArr[i][0]].y);
ctx.lineTo(vertices[pairArr[i][1]].x, vertices[pairArr[i][1]].y);
ctx.closePath();
ctx.strokeStyle="black";
ctx.lineWidth=5*scaleFactor;
ctx.stroke();


}else if(sameColorVerts[i]&&isThere(segPoints[i])&&!settingSegPoints[i]){


ctx.beginPath();
ctx.moveTo(segPoints[i][0].x, segPoints[i][0].y);

for(let s=1;s<segPoints[i].length-2;s++){
let xc=(segPoints[i][s].x+segPoints[i][s+1].x)/2;
let yc=(segPoints[i][s].y+segPoints[i][s+1].y)/2;
ctx.quadraticCurveTo(
segPoints[i][s].x, 
segPoints[i][s].y, 
xc, yc);
}//end s loop

// Connect the last two points
ctx.quadraticCurveTo(
segPoints[i][segPoints[i].length-2].x,
segPoints[i][segPoints[i].length-2].y,
segPoints[i][segPoints[i].length-1].x,
segPoints[i][segPoints[i].length-1].y
);

//ctx.closePath();
ctx.strokeStyle="black";
ctx.lineWidth=5*scaleFactor;
ctx.stroke();
}//}else if(sameColorVerts[i]&&isThere(segPoints[i])&&!settingSegPoints[i]){{
}//end i loop

}//end if highlightSame




//draw vertices as circles
let ci=0;
this.vertices.forEach(function(vertex){
ctx.beginPath();
ctx.strokeStyle="black";
ctx.lineWidth=1;
ctx.arc(vertex.x, vertex.y, vertSize, 0, Math.PI * 2, true);
ctx.stroke();
ctx.closePath();

if(xray){
ctx.fillStyle='transparent';
}else{
ctx.fillStyle=fourColor[vertices[ci].c];
}
ctx.fill();


fonter=parseInt(30*scaleFactor);

if(showFlexibles&&flexibles[ci].avail){
ctx.fillStyle='black';
for(let c=0;c<flexibles[ci].colorsAvailable.length;c++){
let coff=c*parseInt(15*scaleFactor);
ctx.fillText(flexibles[ci
].colorsAvailable[c],vertex.x+parseInt(vertSize*1.3)+coff,vertex.y+parseInt(vertSize*1.1));
}//end c loop
ctx.strokeStyle='black';
let flexLine=10*scaleFactor;
flexLine=clamp(flexLine,0,14);
ctx.lineWidth=parseInt(flexLine);
}else{
ctx.strokeStyle='black';
let regLine=1*scaleFactor;
regLine=clamp(regLine,.5,2);
ctx.lineWidth=parseInt(regLine);
}
ctx.stroke();



if(vertices[ci].c==4){
ctx.fillStyle='black';
}else{
ctx.fillStyle='white';
}

ctx.font=fonter+"px Monospace";

let xOff=0;
let yOff=0;

if(vertex.i>99){
xOff=parseInt(28*(scaleFactor));
yOff=parseInt(8*(scaleFactor));
}else if(vertex.i>9){
xOff=parseInt(18*(scaleFactor));
yOff=parseInt(8*(scaleFactor));
}else if(vertex.i<=9){
xOff=parseInt(8*(scaleFactor));
yOff=parseInt(8*(scaleFactor));
}


if(showNumNeigh){
if(vertex.nCount>9){
xOff=parseInt(18*(scaleFactor));
yOff=parseInt(8*(scaleFactor));
}else if(vertex.nCount<=9){
xOff=parseInt(8*(scaleFactor));
yOff=parseInt(8*(scaleFactor));
}
ctx.fillText(vertex.nCount,vertex.x-xOff,vertex.y+yOff);
}else{
ctx.fillText(vertex.i,vertex.x-xOff,vertex.y+yOff);
}


ci++;
});//end vertices foreach

//testVars("gettingLinkStart",gettingLinkStart,"startConnecting",startConnecting,"endConnecting",endConnecting,"addingVert",addingVert,"linkStart",linkStart,"linkEnd",linkEnd);

}//end render






//Vertex object constructor; //returns {x:x,y:y,c:c,i:i,n:n,nCount:nCount,searching:searching}

function Vertex(x,y,c,i,n,nCount,searching,inSameColorPair,isFlexible){ 
this.x=x;
this.y=y;
this.c=c;//color
this.i=i;//index
this.n=n;//neighbors
this.nCount=nCount;//neighbors count
this.searching=searching;
this.inSameColorPair=inSameColorPair;
this.isFlexible=isFlexible;
}//end Vertex

      
//Triangle object constructor
//returns {v0:Vertex, v1:Vertex, v2:Vertex, center:Vertex, radius:number, radius_squared:number}

function Triangle(v0, v1, v2){ 
this.v0=v0;
this.v1=v1;
this.v2=v2;
//calculate circumcircle;we always do this when we build a new triangle object, so why not put it here in the constructor, instead of putting it somewhere else and calling it from here?
let A=this.v1.x - this.v0.x;
let B=this.v1.y - this.v0.y;
let C=this.v2.x - this.v0.x;
let D=this.v2.y - this.v0.y;
let E=A * (this.v0.x + this.v1.x) + B * (this.v0.y + this.v1.y);
let F=C * (this.v0.x + this.v2.x) + D * (this.v0.y + this.v2.y);
let G=2.0 * (A * (this.v2.y - this.v1.y) - B * (this.v2.x - this.v1.x));
let dx, dy;
if(Math.abs(G)<EPSILON){
let minx=Math.min(this.v0.x, this.v1.x, this.v2.x);
let miny=Math.min(this.v0.y, this.v1.y, this.v2.y);
let maxx=Math.max(this.v0.x, this.v1.x, this.v2.x);
let maxy=Math.max(this.v0.y, this.v1.y, this.v2.y);
this.center=new Vertex((minx + maxx) / 2, (miny + maxy) / 2, 4);
dx=this.center.x - minx;
dy=this.center.y - miny;
}else{
let cx=(D * E - B * F) / G;
let cy=(A * F - C * E) / G;
this.center=new Vertex(cx, cy, 4);
dx=this.center.x - this.v0.x;
dy=this.center.y - this.v0.y;
}
this.radius_squared=dx * dx + dy * dy;
this.radius=Math.sqrt(this.radius_squared);
//end calculate circumcircle;
}//end Triangle

//Edge object constructor; 
//returns {v0:Vertex,v1:vertex,equals:function,inverse:function}
function Edge(v0, v1){ 
this.v0=v0;
this.v1=v1;
this.equals=function(other){return (this.v0 === other.v0 && this.v1 === other.v1);};
this.inverse=function(){return new Edge(this.v1, this.v0);};
}//end edge


function triangulate(vertices){
pairString='';
let triangles=[];
let minx, miny, maxx, maxy;
vertices.forEach(function(vertex){
if(minx === undefined || vertex.x<minx){ minx=vertex.x;}
if(miny === undefined || vertex.y<miny){ miny=vertex.y;}
if(maxx === undefined || vertex.x > maxx){ maxx=vertex.x;}
if(maxy === undefined || vertex.y > maxy){ maxy=vertex.y;}
});
let dx=(maxx - minx) * 10;
let dy=(maxy - miny) * 10;
let stv0=new Vertex(minx - dx, miny - dy * 3, 4);
let stv1=new Vertex(minx - dx, maxy + dy, 4);
let stv2=new Vertex(maxx + dx * 3, maxy + dy, 4);
let st=new Triangle(stv0, stv1, stv2);
triangles.push(st);

let ci=0;
vertices.forEach(function(vertex){
vertex.i=ci;
ci++;

edges=[];
triangles=triangles.filter(function(triangle){
let dx=triangle.center.x - vertex.x;
let dy=triangle.center.y - vertex.y;
let dist_squared=dx * dx + dy * dy;
let inCirc=(dist_squared <= triangle.radius_squared);
if(inCirc){
edges.push(new Edge(triangle.v0, triangle.v1));
edges.push(new Edge(triangle.v1, triangle.v2));
edges.push(new Edge(triangle.v2, triangle.v0));
return false;
}else{
return true;
}
});

let uniqueEdgesArray=[];


for(let i=0;i<edges.length;++i){
let edge1=edges[i];

let unique=true;
for(let j=0;j<edges.length;++j){
if(i === j){continue;}
let edge2=edges[j];
if(edge1.equals(edge2) || edge1.inverse().equals(edge2)){unique=false;break;}
} //end j loop
if(unique){
uniqueEdgesArray.push(edge1);
}
}//end i loop
edges=uniqueEdgesArray;

edges.forEach(function(edge){
triangles.push(new Triangle(edge.v0, edge.v1, vertex));
});//end foreach edges
});//end foreach vertices


triangles=triangles.filter(function(triangle){
return !(triangle.v0 == st.v0 || triangle.v0 == st.v1 || triangle.v0 == st.v2 ||
triangle.v1 == st.v0 || triangle.v1 == st.v1 || triangle.v1 == st.v2 ||
triangle.v2 == st.v0 || triangle.v2 == st.v1 || triangle.v2 == st.v2);
});


return triangles;
}//end triangulate




function countOccurrences(arr,property,targetValue,conditionProperty, conditionValue){
return arr.reduce((count,obj)=>{
if(obj[property]===targetValue &&obj[conditionProperty]===conditionValue){
    return count+1;
    }
    return count;
  }, 0);
}





function dropRandom(){

let sampleSize=5;

let sumVertCount=0;
let avgVertCount=0;

let sumFlexCount=0;
let avgFlexCount=0;

let sumVertFlexRatios=0;
let avgVertFlexRatios=0;


let sumDiffColorPairsCount=0;
let avgDiffColorPairsCount=0;

let sumSameColorPairsCount=0;
let avgSameColorPairsCount=0;

let avgDiffSamePairsRatio=0;
let sumDiffSamePairsRatio=0;

let sumPairCount=0;
let avgPairCount=0;

let sumSameFlexibleCount=0;
let avgSameFlexibleCount=0;

let sumVertsInSameColorPairCount=0;
let avgVertsInSameColorPairCount=0;

let vertsInSameColorPairCount=0;

let sumNeighsPerVertex=0;
let avgNeighsPerVertex=0;

let sumColorsPerFlexible=0;
let avgColorsPerFlexible=0;

let maxNeighs=0;
let minNeighs=1000;

for(let r=0;r<sampleSize;r++){
buildAndRender();


let sameColorPairsCount=0;
let diffColorPairsCount=0;
let neighsPerVertex=0;
let colorsPerFlexible=0;

sumVertCount+=vertices.length;
sumPairCount+=pairArr.length;

maxNeighs=0;

for(let v=0;v<vertices.length;v++){
vertices[v].c=randRange(0,3);
neighsPerVertex+=vertices[v].nCount;
if(vertices[v].nCount>maxNeighs){
maxNeighs=vertices[v].nCount;
}
if(vertices[v].nCount<minNeighs){
minNeighs=vertices[v].nCount;
}

//render();
}//end v loop


neighsPerVertex/=vertices.length;
sumNeighsPerVertex+=neighsPerVertex;


for(let j=0;j<pairArr.length;j++){
if(vertices[pairArr[j][0]].c==vertices[pairArr[j][1]].c){
vertices[pairArr[j][0]].inSameColorPair=true;
vertices[pairArr[j][1]].inSameColorPair=true;
sameColorPairsCount++;
}else{
diffColorPairsCount++;
}
}//end j loop


render();
getFlexibles();


for(let f=0;f<flexibles.length;f++){
if(flexibles[f].avail){
colorsPerFlexible+=flexibles[f].colorsAvailable.length;
}//if(flex
}//f loop
sumColorsPerFlexible+=colorsPerFlexible/flexiblesCount;

sumFlexCount+=flexiblesCount;
sumVertFlexRatios+=(vertices.length/flexiblesCount);

sumDiffSamePairsRatio+=(diffColorPairsCount/sameColorPairsCount);

sumSameColorPairsCount+=sameColorPairsCount;
sumDiffColorPairsCount+=diffColorPairsCount;

let sameFlexibleCount=countOccurrences(vertices, 'isFlexible',true,'inSameColorPair',true);
sumSameFlexibleCount+=sameFlexibleCount;



vertsInSameColorPairCount=vertices.filter((obj)=>obj.inSameColorPair==true).length;
sumVertsInSameColorPairCount+=vertsInSameColorPairCount;


}//end r loop

avgColorsPerFlexible=(sumColorsPerFlexible/sampleSize).toFixed(3);

avgNeighsPerVertex=(sumNeighsPerVertex/sampleSize).toFixed(0);

avgVertsInSameColorPairCount=(sumVertsInSameColorPairCount/sampleSize).toFixed(0);


avgSameFlexibleCount=(sumSameFlexibleCount/sampleSize).toFixed(0);

avgPairCount=(sumPairCount/sampleSize).toFixed(0);

avgSameColorPairsCount=(sumSameColorPairsCount
/sampleSize).toFixed(0);

avgDiffColorPairsCount=(sumDiffColorPairsCount
/sampleSize).toFixed(0);

avgDiffSamePairsRatio=(sumDiffSamePairsRatio/sampleSize).toFixed(2);

avgVertCount=(sumVertCount/sampleSize).toFixed(0);
avgPercentVertsInSameColorPair=((avgVertsInSameColorPairCount/avgVertCount)*100).toFixed(0);
avgFlexCount=(sumFlexCount/sampleSize).toFixed(0);
avgVertFlexRatio=(sumVertFlexRatios/sampleSize).toFixed(2);

let avgVertPairPercent=((avgVertCount/avgPairCount)*100).toFixed(0);
let avgVertPairRatio=(avgVertCount/avgPairCount).toFixed(2);
let avgPairsPerVertex=(avgPairCount/avgVertCount).toFixed(2)

el('data').style.display='block';

let dat=[
[`number of graphs sampled:`,sampleSize], 
[`avg # vertices:`,avgVertCount],
[`avg # pairs:`,avgPairCount],
['avg ratio pairs/verts:',avgPairsPerVertex+` x more pairs`],
['avg ratio verts/pairs:',avgVertPairRatio+' ('+avgVertPairPercent+'% of pairs)'],
['avg # neighbors per vertex, max, min:',avgNeighsPerVertex+', '+maxNeighs+', '+minNeighs],
[`avg # flexibles(can be alt. color(s)):`,avgFlexCount],
[`avg ratio flexibles/vertices:`,
(1/avgVertFlexRatio).toFixed(2)+` (`+((1/avgVertFlexRatio)*100).toFixed(0)+`% of verts)`],
[`avg ratio vertices/flexibles:`,avgVertFlexRatio+` x more verts`],
[`avg # different color pairs:`,avgDiffColorPairsCount],
[`avg # same color pairs:`,avgSameColorPairsCount],
[`avg ratio diff/same pairs:`,avgDiffSamePairsRatio+` times more diff`],
[`avg ratio same/diff pairs:`,(1/avgDiffSamePairsRatio).toFixed(2)+` (`+((1/avgDiffSamePairsRatio)*100).toFixed(0)+`% of same)`],
[`avg % of pairs which are different colors:`,((avgDiffColorPairsCount/avgPairCount)*100).toFixed(0)+`%`],
[`avg % of pairs which are same colors:`,((avgSameColorPairsCount/avgPairCount)*100).toFixed(0)+`%`],
[`avg # verts in at least one same color pair:`,avgVertsInSameColorPairCount+` (`+avgPercentVertsInSameColorPair+`% of all verts)`],
[`avg # flexible verts in same color pairs:`,avgSameFlexibleCount+` (`+((avgSameFlexibleCount/avgFlexCount)*100).toFixed(0)+`% of all flexibles)`],
[`avg % verts in same color pairs which are flexible:`,((avgSameFlexibleCount/avgVertsInSameColorPairCount)*100).toFixed(0)+`%`],
[`avg # alternate colors per flexible:`,avgColorsPerFlexible]
];


let stringer2=`<table style="width:100%;"`;
for(let d=0;d<dat.length;d++){
stringer2+=
`<tr><td class="t">`+
dat[d][0]
+`</td><td class="t2">`+
dat[d][1]
;
}//end d loop
stringer2+=`</td></tr></table>`;

da('tableId',stringer2);
activeButton('dropRandom');
setTimeout('setDataShowHideButton();',100);
hideMessage(messageTimer);
randomDropping=false;
}//dropRandom





document.body.onload=function(){
canv.ontouchstart=function(e){
//showSolvingActions();
}
cancelAnimationFrame(animId);
buildAndRender();
animInit();
getGraphFilenames();
}//end onload

zoom(el('filenameInputDiv'),2,80,20);
zoom(el('numVertsInputDiv'),2,80,20);
zoom(el('fpsInputDiv'),2,80,20);



el('zoomOutButton').ontouchstart=function(e){
activeButton('zoomOutButton');
event.preventDefault();
zoomingIn=false;
zoomingOut=true;
zoomer(true);
canv.ontouchstart=function(e){
centerX=e.touches[0].pageX;
centerY=e.touches[0].pageY;
zoomingIn=false;
zoomingOut=true;
e.preventDefault();
zoomer();
}//ontouchstart
el('zoomOutButton').ontouchend=function(e){
e.preventDefault();
zoomingOut=false;zoomingIn=false;
}//ontouchend
}//ontouchstart



el('zoomInButton').ontouchstart=function(e){
activeButton('zoomInButton');
event.preventDefault();
zoomingIn=true;
zoomingOut=false;
zoomer(true);
canv.ontouchstart=function(e){
centerX=e.touches[0].pageX;
centerY=e.touches[0].pageY;
zoomingIn=true;
zoomingOut=false;
e.preventDefault();
zoomer();
}//canv.ontouchstart
el('zoomInButton').ontouchend=function(e){
e.preventDefault();
zoomingOut=false;
zoomingIn=false;
}//el('zoomInButton').ontouchend
}//el('zoomInButton').ontouchstart



el('panButton').ontouchstart=function(e){
event.preventDefault();
activeButton('panButton');
zoomingOut=false;
zoomingIn=false;
panning=true;
canv.ontouchstart=function(e){
event.preventDefault();
activeButton('panButton');
panning=true;
zoomingOut=false;
zoomingIn=false;
lastTouchX=e.touches[0].pageX;
lastTouchY=e.touches[0].pageY;
panner(e);
}//ontouchstart
}//el('panButton').ontouchstart

function panner(e){  
for(let i=0;i<vertices.length;i++){
vertices[i].x+=e.touches[0].pageX-lastTouchX;
vertices[i].y+=e.touches[0].pageY-lastTouchY;
}//end i loop
for(let i=0;i<segPoints.length;i++){
if(isThere(segPoints[i])){
for(let s=0;s<segPoints[i].length;s++){

segPoints[i][s].x+=e.touches[0].pageX-lastTouchX;
segPoints[i][s].y+=e.touches[0].pageY-lastTouchY;
}//end s loop
}//if(isThere(segPoints[i]))
}//end i loop
lastTouchX=e.touches[0].pageX; 
lastTouchY=e.touches[0].pageY;
render();
}//panner





function vertScaler(){

let miny=100000;
let minx=100000;
let maxy=-100000;
let maxx=-100000;


for(let i=0;i<segPoints.length;i++){
if(isThere(segPoints[i])){
for(let s=0;s<segPoints[i].length;s++){
if(segPoints[i][s].y<miny){miny=segPoints[i][s].y;}
if(segPoints[i][s].x<minx){minx=segPoints[i][s].x;}
}//end s loop
}//if(isThere(segPoints[i]))
}//end i loop


for(let i=0;i<vertices.length;i++){
if(vertices[i].y<miny){miny=vertices[i].y;}
if(vertices[i].x<minx){minx=vertices[i].x;}
}//end i loop


let segPointsTotalLength=0;
for(let i=0;i<segPoints.length;i++){
if(isThere(segPoints[i])){
for(let s=0;s<segPoints[i].length;s++){
if(segPoints[i][s].y>maxy){maxy=segPoints[i][s].y;}
if(segPoints[i][s].x>maxx){maxx=segPoints[i][s].x;}
segPointsTotalLength++;
}//end s loop
}//if(isThere(segPoints[i]))
}//end i loop

let vertsTotalLength=0;
for(let i=0;i<vertices.length;i++){

if(vertices[i].y>maxy){maxy=vertices[i].y;}
if(vertices[i].x>maxx){maxx=vertices[i].x;}
vertsTotalLength++;

}//end i loop


let totalNumVerts=vertsTotalLength+segPointsTotalLength;

let graphArea=(maxx-minx)*(maxy-miny);

let totalVertsArea=totalNumVerts*
((vertSize*2)*(vertSize*2));


//targetRatio=.075;
vertSize=Math.sqrt(graphArea*targetRatio/totalNumVerts)*.5;

//targetRatio=totalVertsArea/graphArea;

//testVars("targetRatio",targetRatio,"graphArea",graphArea,"totalNumVerts",totalNumVerts,"vertSize",vertSize,"totalVertsArea",totalVertsArea);

//testVars("scaleFactor",scaleFactor,"vertSize",vertSize,"totalVertsArea",totalVertsArea,"graphArea",graphArea,"currentRatioVertsAreaToGraphArea",currentRatioVertsAreaToGraphArea,"totalNumVerts",totalNumVerts);

scaleFactor=vertSize*.03;
}//end vertScaler








function zoomer(onGraphCenter){
let zoomFactor=1;

if(zoomingIn){
zoomFactor=1.05;
}else if(zoomingOut){
zoomFactor=.95;
}

if(onGraphCenter){
let vstring='';
let sumX=0;
let sumY=0;
for(let i=0;i<vertices.length;i++){
vertices[i].x=vertices[i].x;
vertices[i].y=vertices[i].y;
sumX+=vertices[i].x;
sumY+=vertices[i].y;
}//end i loop



let segPointsTotalLength=0;
for(let i=0;i<segPoints.length;i++){
if(isThere(segPoints[i])){
for(let s=0;s<segPoints[i].length;s++){
if(isThere(segPoints[i][s])){
segPoints[i][s].x=segPoints[i][s].x;
segPoints[i][s].y=segPoints[i][s].y;
sumX+=segPoints[i][s].x;
sumY+=segPoints[i][s].y;
segPointsTotalLength++;
}//end if(isThere)
}//end s loop
}//end if(isThere)
}//end i loop

let totalLength=
vertices.length+segPointsTotalLength;

centerX=sumX/totalLength;
centerY=sumY/totalLength;
}//end onGraphCenter

for(let i=0;i<vertices.length;i++){
if(isThere(vertices[i])){
let subX=vertices[i].x-centerX;
let subY=vertices[i].y-centerY;

let angToVert=Math.atan2(subY,subX);
let distToVert=Math.sqrt(subX*subX+subY*subY);

vertices[i].x=centerX+Math.cos(angToVert)*(distToVert*zoomFactor);
vertices[i].y=centerY+Math.sin(angToVert)*(distToVert*zoomFactor);
}//isThere

}//end i loop


for(let i=0;i<segPoints.length;i++){
if(isThere(segPoints[i])){
for(let s=0;s<segPoints[i].length;s++){
if(isThere(segPoints[i][s])){
let subX=segPoints[i][s].x-centerX;
let subY=segPoints[i][s].y-centerY;
let angToVert=Math.atan2(subY,subX);
let distToVert=Math.sqrt(subX*subX+subY*subY);
segPoints[i][s].x=centerX+Math.cos(angToVert)*(distToVert*zoomFactor);
segPoints[i][s].y=centerY+Math.sin(angToVert)*(distToVert*zoomFactor);
}//end if(isThere)
}//end s loop
}//end if(isThere)
}//end i loop

vertScaler();
render();

}//end zoomer()



</script>

</body>
</html>
<html>
<head>
<meta name="viewport" content="width=device-width,initial-scale=.25"></meta>
<script src="redirectToDesktop.js"></script>
<style>
.b{
font-size:40px;
font-family:monospace;
visibility:visible;
position:relative;
background-color:#ffffff;
padding:40px;
border:1px solid #000000;
}


.t{
width:70%;
border-bottom:1px solid #cdcdcd;
margin:0px;
font-size:40px;

}
.t2{
width:30%;
border-bottom:1px solid #cdcdcd;
margin:0px;
padding:4px;
padding-left:50px;
font-size:40px;

}

.container::-webkit-scrollbar{display:none;}/* Safari and Chrome */
.container{-ms-overflow-style:none; /* Internet Explorer 10+ */
scrollbar-width: none;  /* Firefox */}

</style>
</head>
<body id="bodyer" style="font-family:monospace;overflow:hidden;margin:0px;padding:0px;">
<script>
var streamSolving=true;
var usePHP=false;
var serverAddress='http://0.0.0.0:45267/';
var EPSILON=1.0e-6;
var Vertex;
var Triangle;
var Edge;
var triangulate;
var edges;
var vertices;
var triangles;
var vertPairs;
var pairString='';
var fourColor=["red","gold","MediumSeaGreen","DeepSkyBlue","white"];
var fourColorShort=['R','Y','G','B','W'];
var savedData=[];
var triColors=[];
var dragging=false;
var altKey=false;
var inset=125;
var vertexToEdit=-1;
var backgroundColor='#f5f5f5';
var dataFileName="default.txt";
var numSavedGraphs=0;
var graphFileNames=[];
var dataSend='';
var dataReceive=null;
var getDataInterval=0;
var stringArr=[];
var pairArr=[];
var setRandomVerts=true;
var sortedVerts=[];
var counter=0;
var colorSavedGraph=false;
var xray=false;
var sameColorVerts=[];
var highlightSame=true;
var sortString='';
var searcher=[];
var lastSearcher=[];
var nonNeighbor=[];
var numSolves=0;
var solveCounter=0;
var chunkSolveString='';
var allSolvesString='';
var nIndexString='';
var loopingDetected=false;
var solveRemainingPass=0;
var loopCounter=0;
var tripleCheck=false;
var framesPerSecond=30;
var pauser=false;
var showSolving=false;
var stillSearching=false;
var animId=0;
var rColorGraphDone=false;
var animSV=0;
var stepping=false;
var solved=false;
var showNumNeigh=false;
var solving=false;
var timeToSolve=0;
var startTime=Date.now();
var endTime=Date.now();
var deltaTime=endTime-startTime;
var lastButton='buildRandomGraph';
var messageTimer=0;
var building=false;
var flexibles=[];
var showFlexibles=true;
var flexibleColor='#db37d9';
var numSolvesCounter=0;

var gettingLinkStart=false;
var addingVert=false;
var linkStart=-1;
var linkEnd=-1;
var startConnecting=false;
var endConnecting=false;
var delaunay=true;
var flexiblesCount=0;
var diffColorPairsCount=0;
var sameColorPairsCount=0;


var numPoints=60;//50,70,160,300
var vertSize=30;//30,30,27,24
var diam=110;//120,110,80,60
var maxVertSize=31;
var minVertSize=24;
var maxDiam=120;
var minDiam=56;
var moveRaw=false;
var randOnlySome=.29;

function clamp(a,min,max){
if(a<min){a=min;}else if(a>max){a=max;}
return a;
}//end clamp





function getDeltaTime(){
deltaTime=endTime-startTime;
}//end getDeltaTime

function zoom(elm,scale,w,h){
elm.style.transform="scale("+scale+")";
elm.style.transformOrigin="top left";
elm.style.width=(w/scale)+"%";
elm.style.height=(h/scale)+"%";
}//end zoom



</script>

</div>


<div id="tester"  style="color:white;background-color:black;position:absolute;left:70px;top:800px;z-index:10000;font-size:40px;padding:6px;border:6px solid white;display:none;width:1200px;height:600px;word-wrap:break-word;padding:50px;padding-bottom:0px;padding-top:0px;overflow:scroll;"></div>

<div id="messageHolder" style="position:absolute;left:450px;top:500px;padding:90px;border:12px solid black;display:none;z-index:1000000;background-color:white;">

<div id="message" style="display:block;white-space:nowrap;font-family:monospace;font-weight:bold;color:black;font-size:60px;">
</div>
</div>


<iframe id="ifr" src="" style="display:none;z-index:1000;position:absolute;top:2000px;left:10px;height:1800px;width:1200px;border:1px solid black;">
</iframe>


<canvas id="canvas" width="440" height="550" style="position:absolute;left:0px;top:0px;z-index:100;"></canvas>





<select id="selectGraph" onchange="setRandomVerts=false;dataFileName=graphFileNames[parseInt(this.options[this.selectedIndex].value)];buildAndRender();" style="z-index:10000000;font-size:40px;font-family:monospace;background-color:#ffffff;border:1px solid #000000;visibility:hidden;position:absolute;top:100px;left:250px;padding:30px;">
<option disabled selected id="label">Load Graph</option>
</select>



<div id="filenameInputDiv" style="z-index:10000000;position:fixed;left:50px;bottom:1000px;font-size:30px;font-family:monospace;background-color:#ffffff;padding:40px;border:1px solid black;visibility:hidden;height:40px">


Filename:
<input id="enterGraphName" type="text"  value="" style="display:inline-block;font-family:monospace;color:black;font-size:30px;border:1px solid black;" size="30">

<br>

<input value="save" type="button" ontouchstart="dataFileName=el('enterGraphName').value+'.txt';el('filenameInputDiv').style.visibility='hidden';saveGraphData();"  style="display:inline-block;font-size:30px;margin-top:12px;">

<input value="cancel" type="button" ontouchstart="el('filenameInputDiv').style.visibility='hidden';" style="display:inline-block;font-size:30px;margin-top:12px;">

</div>






<div id="expander" ontouchstart="controlPanelOpenClose();" style="text-align:center;right:0px;position:fixed;font-weight:bold;font-size:65px;font-family:monospace;white-space:nowrap;background-color:#ffffff;padding:20px;border:1px solid #000000;bottom:0px;z-index:10000000000;visibility:visible;width:120px">  -  
</div>

<div id="buttonHolder" style="text-align:justify;white-space:nowrap;z-index:1000;position:fixed;background-color:#ffffff;padding:10px;
;overflow:hidden;">
 


<input id="about" type="button" value="About" ontouchstart="event.preventDefault();activeButton(this.id);showHide('aboutDiv');" class="b">



<input id="streamSolve" type="button" value="stream" 
ontouchstart="event.preventDefault();activeButton('streamSolve');streamSolving=!streamSolving; if(streamSolving){solved=false;for(let v=0;v<vertices.length;v++){vertices[v].c=4;}} showSolvingButton();"    
class="b">



<input id="showSolving" type="button" value="Show Solving" 
ontouchstart="showSolvingActions();" class="b">


<input id="solve" type="button" value="Solve" 
ontouchstart="solveActions();" class="b">


<input id="step" type="button" value="Step" ontouchstart="stepActions();" class="b">



<br>

<input id="buildRandomGraph" type="button" value="Build Graph" ontouchstart="event.preventDefault();activeButton(this.id);building=true;showMessage('Building Graph',60000);buildRandomGraphButton();setRandomVerts=true;setTimeout('buildAndRender();',50);canv.ontouchstart=function(e){setRandomVerts=true;buildAndRender();};" class="b">

<input id="addVertex" type="button" value="Add Vert" 
ontouchstart="event.preventDefault();activeButton(this.id);delaunay=true;canv.ontouchstart=function(e){delaunay=true;mouseAdd_Vertex(e);solved=false;}"    
class="b">



<input id="moveVertex" type="button" value="Move Vert" 
ontouchstart="event.preventDefault();activeButton(this.id);delaunay=true;canv.ontouchstart=function(e){delaunay=true;el('expander').style.visibility='hidden';dragging=true;moveRaw=false;getVertexToEdit(e);solved=false;}" class="b">

<input id="deleteVertex" type="button" value="Delete Vert" 
ontouchstart="event.preventDefault();activeButton(this.id);delaunay=true;canv.ontouchstart=function(e){delaunay=true;getVertexToEdit(e);deleteVertex(e,true);solved=false;}"    
class="b">




<br>

<input id="colorVerts" type="button" value="ColorVerts" ontouchstart="event.preventDefault();activeButton(this.id);canv.ontouchstart=function(e){getVertexToEdit(e);changeVertexColor(e);solved=false;}" class="b">

<input id="numberOfVerts" type="button" value="Number of Verts" ontouchstart="event.preventDefault();activeButton(this.id);el('enterNumVerts').value=numPoints;showHideV('numVertsInputDiv');" class="b">

<input id="fpsId" type="button" value="FPS" ontouchstart=" activeButton(this.id);el('enterFPS').value=parseInt(framesPerSecond);showHideV('fpsInputDiv');" class="b">

<input id="timeToSolveId" type="button" value="TimeToSolve" ontouchstart="event.preventDefault();activeButton(this.id);showMessage('Solved in: '+deltaTime+' ms<br> after '+ numSolvesCounter+' steps',2000);" class="b">

<br>

<input id="neighs" type="button" value="Neighs" 
ontouchstart="event.preventDefault();activeButton(this.id);if(showNumNeigh){showNumNeigh=false;}else{showNumNeigh=true;}render();" class="b">



<input type="button" value="Tester" id="testerButton"
ontouchstart="event.preventDefault();activeButton(this.id);showHide('tester');el('tester').scrollTop=el('tester').scrollHeight;" class="b">

<input type="button" value="loadGraph" id="loadGraphButton"
ontouchstart="event.preventDefault();activeButton(this.id);showHideV('selectGraph');" class="b" style="display:none;">


<input type="button" value="saveGraph" id="saveGraphButton"
ontouchstart="event.preventDefault();activeButton(this.id);showHideV('filenameInputDiv');" class="b" style="display:none;">

<input type="button" value="Flexibles" id="flexiblesButton"
ontouchstart="event.preventDefault();activeButton(this.id);showFlexibles=!showFlexibles;render();" class="b">

<input type="button" value="Console" id="consoleButton"
ontouchstart="event.preventDefault();activeButton(this.id);showHideV('consoleInputDiv');render();" class="b">

<input id="dropRandom" type="button" value="Random Drop" 
ontouchstart="event.preventDefault();activeButton(this.id);showMessage('Running Samples',60000);setTimeout('dropRandom();',20);"    
class="b">




<div id="consoleInputDiv" style="z-index:10000000;position:fixed;left:50px;top:10px;font-size:40px;font-family:monospace;background-color:#ffffff;padding:40px;border:1px solid black;visibility:hidden;height:450px;overflow:scroll;">

<input id="consoleInput" type="text"  value="pairArr" style="font-family:monospace;color:black;font-size:25px;border:1px solid black;zoom:4;word-wrap:break-word;wifth:200px" size="20">
<br>
<input value="Enter" type="button" ontouchstart="da('tester','<br>'+eval(el('consoleInput').value));da('consoler','<br>'+eval(el('consoleInput').value));" style="position:absolute;display:block;font-size:60px;padding:30px;margin-top:12px;bottom:0px;right:0px;">

<div id="consoler"  style="width:100px;height:300px;display:block;font-size:60px;margin-top:12px;background-color:white;word-wrap:break-word;">Enter a Variable</div>




</div>


<!--daa('tester','numPoints:'+numPoints+' --- diam:'+diam+' --- vertSize:'+vertSize+'<br><br>');-->

<br>

<input type="button" value="add" id="addButton"
ontouchstart="event.preventDefault();activeButton(this.id);gettingLinkStart=false;delaunay=false;canv.ontouchstart=function(e){delaunay=false;el('expander').style.visibility='hidden';mouseAdd_Vertex(e);solved=false;}" class="b">

<input type="button" value="addLinked" id="addVertButton"
ontouchstart="event.preventDefault();activeButton(this.id);delaunay=false;gettingLinkStart=true;canv.ontouchstart=function(e){delaunay=false;el('expander').style.visibility='hidden';getVertexToEdit(e);solved=false;}" class="b">

<input type="button" value="Link" id="linkVertsButton"
ontouchstart="event.preventDefault();activeButton(this.id);gettingLinkStart=false;startConnecting=true;delaunay=false;canv.ontouchstart=function(e){delaunay=false;el('expander').style.visibility='hidden';getVertexToEdit(e);solved=false;}" class="b">



<input id="moveVertButton" type="button" value="Move" 
ontouchstart="event.preventDefault();activeButton(this.id);delaunay=false;canv.ontouchstart=function(e){delaunay=false;el('expander').style.visibility='hidden';dragging=true;moveRaw=true;getVertexToEdit(e);solved=false;}" class="b">

<input id="deleteVertButton" type="button" value="Delete" 
ontouchstart="event.preventDefault();activeButton(this.id);delaunay=false;canv.ontouchstart=function(e){delaunay=false;getVertexToEdit(e);deleteVertex(e,false);solved=false;}"    
class="b">




</div><!--end buttonHolder-->

<div id="numVertsInputDiv" style="font-size:50px;font-family:monospace;visibility:hidden;z-index:1000000;position:fixed;left:100px;bottom:0px;background-color:#ffffff;padding:30px;border:6px solid #000000;">

Number of Vertices:
<input id="enterNumVerts" type="text"  size="3" value="60" style="background-color:black;color:caret-color:white;font-family:monospace;color:white;font-size:70px;padding:10px"
ontouchstart="">

<input id="numVertsApply" value="Apply" type="button" ontouchstart="activeButton(this.id);showMessage('Building Graph',60000);flexibles=[];numPoints=parseInt(el('enterNumVerts').value);graphRenderScaleFactors();el('numVertsInputDiv').style.visibility='hidden';building=true;buildRandomGraphButton();setRandomVerts=true;setTimeout('buildAndRender();',100);"  style="display:inline-block;font-size:50px;padding:10px;">

<input value="cancel" type="button" ontouchstart="el('numVertsInputDiv').style.visibility='hidden';" style="display:inline-block;font-size:50px;padding:10px;">

</div>


<div id="fpsInputDiv" style="font-size:50px;font-family:monospace;visibility:hidden;z-index:1000000;position:fixed;left:100px;bottom:0px;background-color:#ffffff;padding:30px;border:6px solid #000000;">


FPS (1-60):
<input id="enterFPS" type="text"  size="3" value="" style="font-family:monospace;color:black;font-size:50px;padding:10px">

<input value="Apply" type="button" ontouchstart="framesPerSecond=parseInt(el('enterFPS').value);if(framesPerSecond<1){framesPerSecond=1;}else if(framesPerSecond>120){framesPerSecond=120;}el('fpsInputDiv').style.visibility='hidden';"  style="display:inline-block;font-size:50px;padding:10px;">

<input value="cancel" type="button" ontouchstart="el('fpsInputDiv').style.visibility='hidden';" style="display:inline-block;font-size:50px;padding:10px;">

</div>







<div class="container" id="aboutDiv" style="background-color:white;position:absolute;left:30px;top:30px;z-index:10000;border:2px solid black;display:none;height:70%;overflow:auto;padding:10px;margin:0px;">
<div id="aboutDivHeading" style="border:2px solid black;color:white;background-color:#000000;font-family:monospace;padding:10px;padding-left30px;margin:0px;position:fixed;left:30px;top:30px;z-index:10001;font-size:40px;height:60px">
<b>&nbsp;A javascript program for four coloring any graph</b>

</div>
<div style="background-color:#ffffff;font-family:monospace;padding:10px;font-size:13px;text-align:justify;line-height:48px">
<br><br>
The github files are here:<br>
<a href="https://github.com/thismain/Four-Color-Theorem-Coloring-Tester" target="_blank">https://github.com/thismain/Four-Color-Theorem-Coloring-Tester</a>
<br><br>
The live Desktop demo is here:<br>
<a href="http://moygen.rf.gd/graph2/desktop.html" target="_blank">http://moygen.rf.gd/graph2/desktop.html</a>
<br><br>
The live Mobile demo is here:<br>
<a href="http://moygen.rf.gd/graph2/index.html" target="_blank">http://moygen.rf.gd/graph2/index.html</a>
<br><br>
<img src="http://moygen.rf.gd/graph2/screenshotter.png">
<br><br>
This is a javascript program for four coloring any graph. Although it would be difficult to test on every possible graph, it has solved hundreds of 600 or fewer vertices. The lowest time to solve for 600 vertices was 39ms, though the average is around 300ms. I use delaunay triangulation, from <a href="https://travellermap.com/tmp/delaunay.js" target="_blank">Joshua Bell's code</a>, to generate random graphs, and these graphs may be modified, either with or without delaunay triangulation. 
<br><br>
The best part of this program, I think, is watching the animation of the algorithm solving the graph at a human observable speed. 
<br><br>
<b>The algorithm:</b><br>
I recently found a faster way. I had been sorting the vertices by number of neighbors, and using high priority colors on vertices of high degree of connectivity, which would get colored first, and low priority colors on vertices of low degree of connectivity, which would get colored last. However, It turns out, it's faster to just go through the vertices as they were set down when building the graph, from the top of the screen to the bottom, applying colors in the same order each time, when they can be applied without conflict.
<br><br>
After the algorithm has gone through the whole graph this way, it then goes back to the vertices for which no color was available. It searches the neighbors of the uncolored vertex for the neighbors with the fewest fellows of their own color. If there are more than one neighbors with only one fellow of the same color, the algorithm chooses the neighbor of the highest priority color. The algorithm assigns the color of that neighbor to the uncolored vertex and then repeats the same process for that neighbor, excluding the vertex which just took its color. 
<br><br>
When the algorithm goes into a loop of following the same circuit over and over, it kicks itself out of the loop with a random choice of either the second or third choice of neighbors from which to take a color, where the neighbors have been sorted by the number of fellows of the same color. 
<br><br>
Finally, the algorithm triple checks the graph for any neighboring vertices of the same color and proceeds in the same manner to fix them.
<br><br>
The reason I made this program is because I wanted to find out why the 4CT is true, and I reasoned that the best way to find that out would be to see why the algorithms that work do work, and how they can be made to work less well and broken. 
<br><br>
I wonder whether a neural network can learn from billions of correctly colored graphs to recognize patterns in strings of permutations of numbers of neighbors and immediately know what colors the vertices can be. So it would solve the graph the way a rubik's cube is solved, rather than searching for the correct solution in real time.
<br><br>
<hr>
<br>
What would a sufficient reason require? Obviously, it would need to explain why five colors are never necessary, but it would also need to show why three colors are sometimes not possible, and what are the conditions that must occur for a three-colorable graph to become a four-colorable one. An analysis of how a graph can, or must, be modified to go from requiring only three colors, to requiring four colors, and also from two to three, and from one to two, would be useful. I'd love to identify and parameterize some property or properties of planar graphs that results in the flexibility we find in assigning colors. But for such a property to be proven to be the operative four-coloring mechanism one would need to show that only the coloring algorithms that exploit this property work, and algorithms that do not exploit this property do not work, and those that only partly make use of this property only partly work. Which task would require that one had first set up the environment for testing several and various algorithms, so as to compare and rate their performance. To this end I imagine identifying the complete set of discrete components which comprise every four coloring algorithm, and from this set of modules choosing, and their parameters adjusting in turn, so as to evaluate the change in effectiveness wrought thereby.
<br><br>
In reality my code is very messy, but still I dream.
<br><br>
What might those modules be? Let's number them:
<br><br>
1) Sorting nodes by numbers of neighbors<br>
2) Assigning the four colors levels of priority<br>
3) Sorting neighbors by number of a color<br>
4) Behavior when no color is available<br>
5) Color transfer from neighbor to uncolored<br> node, or to a conflicted node<br>
6) Loop detection and breaking<br>
7) Self checking the result<br>
8) Order of coloring<br>
9) ...
<br><br>
It turns out to have been unnecessary to worry about complexity increasing with increasing numbers of vertices and with increasing numbers of connections for each node. The hardest graph anyone can contrive will be trivial to color by a sufficient algorithm. There's always enough flexibility in the choice of colors so as to allow for changing colors along a path until a node is encountered that is only neighbored by nodes of two colors, or by one. I think it's worthwhile to mention at the start of anyone's exposure to the 4CT that if four colors are randomly dropped onto one thousand randomly built graphs, the ratio of differently colored neighbors to same colored neighbors averages out to three to one; three differently colored neighbors for every one that is the same color, or 75% different, 25% same.
<br><br>


</div>

</div>



<div class="container" id="data" style="background-color:white;position:absolute;left:30px;top:30px;z-index:10000;border:2px solid black;display:none;height:70%;overflow:auto;padding:10px;margin:0px;">
<div id="dataHeading" style="border:2px solid black;color:white;background-color:#000000;font-family:monospace;padding:10px;margin:0px;position:fixed;left:30px;top:30px;z-index:10001;font-size:40px;">
<b>Random Drop of Colors: Data for Analysis:</b>

</div>
<div style="background-color:#ffffff;font-family:monospace;padding:10px;">
<br><br><br><br>
<table id="tableId" style="width:100%;"></table>
</div>

</div>

<div id="dataShowHideButton" ontouchstart="showHide('data');" style="display:none;text-align:center;color:#bbbbbb;top:12px;right:12px;font-size:35px;color:black;padding-top:5px;padding-bottom:4px;padding-left:8px;padding-right:8px;height:45px;width:245px;background-color:dddddd;border: 2px solid #bbbbbb;position:absolute;font-family:monospace;z-index:10002;">show/hide</div>


<script>


function el(a){return document.getElementById(a);}
function da(a,b){if(el(a)){el(a).innerHTML=b;
//el(a).style.display='block';
}}
function daa(a,b){if(el(a)){el(a).innerHTML+=b;
//el(a).style.display='block';
}}
function randRange(min, max){return Math.floor(Math.random() * (max - min + 1)) + min;}
function degToRad(a){return a*Math.PI/180;}
function isThere(a){return(typeof a!=="undefined"&&typeof a!==null&&(a||a==0));}
function els(a){return document.getElementById(a).style;}
function showHide(a){if(els(a).display=='block'){els(a).display='none'}else{els(a).display='block'}}

function showHideV(a){if(els(a).visibility=='visible'){els(a).visibility='hidden'}else{els(a).visibility='visible'}}

var ww=window.innerWidth;
var hh=window.innerHeight;
var canv=document.getElementById("canvas");
var ctx=canv.getContext('2d');
canv.width=window.innerWidth;
canv.height=window.innerHeight;
var cW=canv.width;
var cH=canv.height;
canv.style.width=cW+"px";
canv.style.height=cH+"px";
canv.style.left=(ww/2-cW/2)+'px';

//showHide('loadGraphButton');
//showHide('saveGraphButton');


el('data').style.width=ww*.93+'px';
el('dataHeading').style.width=ww*.93+'px';
el('aboutDiv').style.width=ww*.93+'px';
el('aboutDivHeading').style.width=ww*.93+'px';

function setDataShowHideButton(){
let dataRect=el('data').getBoundingClientRect();
el('dataShowHideButton').style.right=(ww-dataRect.width-16).toFixed()+'px';
el('dataShowHideButton').style.top=(dataRect.top+6).toFixed()+'px';
el('dataShowHideButton').style.display='block';
//alert((ww-dataRect.width).toFixed());
}//end setDataShowHideButton


function graphRenderScaleFactors(){
diam=Math.sqrt(cW*cH/numPoints*randOnlySome);
vertSize=clamp(.25*diam,minVertSize,maxVertSize);
}//graphRenderScaleFactors

graphRenderScaleFactors();


function activeButton(buttonId){
el(lastButton).style.backgroundColor='white';
el(buttonId).style.backgroundColor='#dbedff';
lastButton=buttonId;
if(lastButton!='dropRandom'){el('dataShowHideButton').style.display='none';el('data').style.display='none';}
if(lastButton!='about'){el('aboutDiv').style.display='none';}
}//activeButton



el('messageHolder').style.left=ww*.3+'px';
el('messageHolder').style.top=hh*.3+'px';


var bhStyle=getComputedStyle(el('buttonHolder'));var bhHeight=bhStyle.height;
var cpClosedPos=parseInt(window.innerHeight*2)+'px';
var cpOpenPos='10px';


el('buttonHolder').style.width=ww+'px';
el('buttonHolder').style.bottom=cpOpenPos;
//el('expander').style.bottom=parseInt(bhHeight)+30+'px';


function controlPanelOpenClose(){
if(el('buttonHolder').style.bottom==cpClosedPos){
el('buttonHolder').style.bottom=cpOpenPos;
da('expander','-');
}else{
el('buttonHolder').style.bottom=cpClosedPos;
da('expander','+');
}
}//end controlPanelOpenClose



el('fpsInputDiv').style.bottom=parseInt(bhHeight)+100+'px';
el('numVertsInputDiv').style.bottom=parseInt(bhHeight)+100+'px';

var showBoolCounter=1;
function showBools(buttonValue, marker){
if(!marker){marker=showBoolCounter;}
daa('tester',buttonValue+' '+marker+': <br>stepping:'+stepping+'<br> solving:'+solving+' <br> solved:'+solved+' <br>  rColorGraphDone:'+rColorGraphDone+' <br>showSolving: '+showSolving+'<br>-----------------<br>');
el('tester').scrollTop=el('tester').scrollHeight;
showBoolCounter++;
}//end showBools


function getGraphFilenames(){
if(usePHP){
el('ifr').src=serverAddress+'filenameReader.php';
setTimeout(function(){
graphFileNames=JSON.parse(el('ifr').contentWindow.filenames);

numSavedGraphs=graphFileNames.length;
initSelectGraph();
},500);
}//if usePHP
}//end get graph filenames

function initSelectGraph(){
for(let i=0;i<numSavedGraphs;i++){
let op=document.createElement("option");
op.id='op'+i;
op.value=i;
op.text=graphFileNames[i];
el('selectGraph').appendChild(op);
}//end i loop
//el('op0').selected="selected";
}//end init select graph

function getGraphData(){
if(usePHP){
el('ifr').src=serverAddress+"saver.php?loading=1&dataFileName="+dataFileName;
setTimeout("loadGraphData();",500);
}//usePHP
}//end getGraphData

function loadGraphData(){
dataReceive=el('ifr').contentWindow.dataSend;
if(!isThere(dataReceive)){
getGraphData();
}else{

if(dataReceive.indexOf('[')>=0){
delaunay=false;
}

if(!delaunay){
let pairArrString=
dataReceive.substring(0,dataReceive.lastIndexOf(']')+1.);

pairArr=JSON.parse(pairArrString);
dataReceive=
dataReceive.replace(pairArrString+' ','');
}//end if !delaunay

stringArr=dataReceive.split(" ");

for(let i=0;i<stringArr.length;i+=4){
vertices.push(new Vertex(parseInt(stringArr[i]),parseInt(stringArr[i+1]),parseInt(stringArr[i+2]),parseInt(stringArr[i+3])));
if(delaunay){
triangles=triangulate(vertices);
}
}//end i loop

if(delaunay){
sortByNeighborCount();
}
//if(colorSavedGraph){colorGraph();}
render();
dataReceive='';
}//end isThere
}//end loadGraphData


function saveGraphData(){
if(usePHP){
let graphData='';
for(let i=0;i<vertices.length;i++){
graphData+=parseInt(vertices[i].x)+' '+parseInt(vertices[i].y)+' '+vertices[i].c+' '+vertices[i].i+' ';
}//end i loop

if(!delaunay){
graphData=
JSON.stringify(pairArr)+' '+graphData;
}

/*
let pairArr=[[675,89],[98,2],[8,7]];
let dataSaved=JSON.stringify(pairArr);
pairArr=JSON.parse(dataSaved);
*/


if(!el('op'+numSavedGraphs)){
graphFileNames.push(dataFileName);
el('ifr').src=serverAddress+"saver.php?graphData="+graphData+"&saving=1&dataFileName="+dataFileName;
let op=document.createElement("option");
op.id='op'+numSavedGraphs;
op.value=numSavedGraphs;
op.text=dataFileName;
el('selectGraph').appendChild(op);
numSavedGraphs++;
}//end if(!el
}//usePHP
}//end saveGraphData


function changeVertexColor(e){
if(isThere(vertices[vertexToEdit])){
vertices[vertexToEdit].c++;
if(vertices[vertexToEdit].c>3){
vertices[vertexToEdit].c=0;
}
render();
}//is There
}// end changeVertexColor


canv.ontouchend=function(e){
dragging=false;
el('expander').style.visibility='visible';
render();
vertexToEdit=-1;
}//end ontouchend



canv.ontouchmove=function(e){
if(dragging){
el('expander').style.visibility='hidden';
if(moveRaw){
moveVertex(e,delaunay=false);
}else{
moveVertex(e,delaunay=true);
}
sortByNeighborCount();
render();
}
}//end ontouchmove


function showSolvingActions(){
event.preventDefault();
canv.ontouchstart=function(e){
showSolvingActions();
}
activeButton('showSolving');
if(!showSolving&&solved&&!stepping){
reSolverReset();
for(let v=0;v<vertices.length;v++){
vertices[v].c=4;}
}//if(!showSolving&&
showSolvingButton();
}//end showSolvingActions


function solveActions(){
event.preventDefault();
canv.ontouchstart=function(e){
solveActions();
}
activeButton('solve');
stepping=false;
pauser=false;
showSolving=false;
streamSolving=false;
solving=true;
solveButton();
for(let v=0;v<vertices.length;v++){
vertices[v].c=4;} 
startTime=Date.now();
recursiveNeighborSolver();
}//end solveActions



function stepActions(){
event.preventDefault();
canv.ontouchstart=function(e){
stepActions();
}
activeButton('step');
if(!showSolving&&solved&&!stepping){
reSolverReset();
for(let v=0;v<vertices.length;v++){
vertices[v].c=4;}
}//end if(!showSolving&
solved=false;
stepping=true;
stepper();
showSolving=false;

showSolvingStatus();
}//end stepActions

canv.ontouchstart=function(e){
showSolvingActions();
}


function moveVertex(e,delaunay){
if(vertexToEdit>=0){
vertices[vertexToEdit].x=e.touches[0].pageX;
vertices[vertexToEdit].y=e.touches[0].pageY;
ctx.clearRect(0,0,cW,cH);
if(delaunay){
triangles=triangulate(vertices);
}
render();
}
}//end moveVertex


function mouseAdd_Vertex(e){
ctx.clearRect(0,0,cW,cH);
vertices.push(new Vertex(e.touches[0].pageX,e.touches[0].pageY,4,vertices.length+1));
if(delaunay){
triangles=triangulate(vertices);
}
sortByNeighborCount();
render();
}//end mouseAdd_Vertex



function getVertexToEdit(e){
vertexToEdit=-1;
for(let i=0;i<vertices.length;i++){
ctx.beginPath();
ctx.arc(vertices[i].x, vertices[i].y, vertSize*2, 0, Math.PI * 2, true);
if(ctx.isPointInPath(e.touches[0].pageX, e.touches[0].pageY)){
vertexToEdit=i;

if(!delaunay){
if(gettingLinkStart){
linkStart=vertexToEdit;
addingVert=true;
//gettingLinkStart=false;
canv.ontouchstart=function(e){
el('expander').style.visibility='hidden';
if(addingVert){
ctx.clearRect(0,0,cW,cH);
vertices.push(new Vertex(e.touches[0].pageX,e.touches[0].pageY,4,vertices.length));
linkEnd=vertices.length-1;
if(linkStart>=0&&linkEnd>=0){
pairArr.push([linkStart,linkEnd]);
linkStart=linkEnd;
}
sortByNeighborCount();
render();
//addingVert=false;
}
}//end function(e)

}else if(startConnecting){
addingVert=false;
linkStart=vertexToEdit;
startConnecting=false;
endConnecting=true;

}else if(endConnecting){
addingVert=false;
delaunay=false;
linkEnd=vertexToEdit;
if(linkStart>=0&&linkEnd>=0){
pairArr.push([linkStart,linkEnd]);
removeDuplicatePairs();
linkStart=linkEnd;
}
sortByNeighborCount();
render();
//endConnecting=false;
}
}//if(!delaunay

ctx.lineWidth='240';
ctx.strokeStyle=fourColor[vertices[vertexToEdit].c];
if(!endConnecting){
ctx.stroke();
}
}//ctx.isPointInPath
}//i loop
ctx.closePath();
}//end getVertexToEdit



function deleteVertex(e,delaunay){
if(vertexToEdit>=0){
vertices.splice(vertexToEdit,1);
for(let v=0;v<vertices.length;v++){
vertices[v].i=v;}

if(!delaunay){
for(let i=pairArr.length-1;i>=0;i--){
if(vertexToEdit==pairArr[i][0]||vertexToEdit==pairArr[i][1]){
pairArr.splice(i,1);
}
}//i loop
delaunay=false;
}//!delaunay

//ctx.clearRect(0,0,cW,cH);
if(delaunay){
triangles=triangulate(vertices);
}


for(let j=0;j<pairArr.length;j++){
if(pairArr[j][0]>vertexToEdit){
pairArr[j][0]--;}
if(pairArr[j][1]>vertexToEdit){
pairArr[j][1]--;}
}//j loop


sortByNeighborCount();
render();
}//>=0
}//end deleteVertex




function getVertexPairs(){
if(delaunay){
pairArr=[];
for(let i=0;i<triangles.length;i++){
pairArr.push([triangles[i].v0.i, triangles[i].v1.i]);
pairArr.push([triangles[i].v0.i, triangles[i].v2.i]);
pairArr.push([triangles[i].v1.i, triangles[i].v2.i]);
}//i loop

}
/*
else if(!delaunay){
if(linkStart>=0&&linkEnd>=0){
pairArr.push([linkStart,linkEnd]);
}//if(linkStart
}//end if !delaunay

*/

removeDuplicatePairs();

}//end getVertexPairs


//remove duplicate pairs
function removeDuplicatePairs(){
for(let i=pairArr.length-1;i>=1;i--){
for(let j=i-1;j>=0;j--){
if(isThere(pairArr[i])
&&
isThere(pairArr[j])){
if(
(pairArr[i][0]==pairArr[j][0]
&&
pairArr[i][1]==pairArr[j][1])
||
(pairArr[i][0]==pairArr[j][1]
&&
pairArr[i][1]==pairArr[j][0])
){
pairArr.splice(i,1);
}
}//end isThere
}//end j loop
}//end i loop
}//removeDuplicatePairs



function getNeighbors(){
getVertexPairs();
for(let v=0;v<vertices.length;v++){
vertices[v].n=[];
for(let i=0;i<pairArr.length;i++){
if(
v==pairArr[i][0]
){
vertices[v].n.push(pairArr[i][1]);
}else if(
v==pairArr[i][1]
){
vertices[v].n.push(pairArr[i][0]);
}
if(i==pairArr.length-1){
vertices[v].nCount=vertices[v].n.length;
}
}//end i loop
}//end v loop
}//end get neighbors



function sortByNeighborCount(){
getNeighbors();
sortedVerts=[];
for(let v=0;v<vertices.length;v++){
sortedVerts[v]={nCount:vertices[v].nCount,i:vertices[v].i,n:vertices[v].n};
}
sortedVerts.sort((a,b)=>b.nCount-a.nCount);
}//end sortByNeighborCount



function colorGraph(){
for(let v=0;v<vertices.length;v++){
vertices[v].c=4;}

for(let v=0;v<sortedVerts.length;v++){
for(let c=0;c<4;c++){
let colorAvailable=true;
for(let n=0;n<sortedVerts[v].nCount;n++){
if(isThere(vertices[sortedVerts[v].n[n]])){
if(vertices[sortedVerts[v].n[n]].c==c){
colorAvailable=false;break;
}
}//isThere
}//end n loop
if(colorAvailable){vertices[sortedVerts[v].i].c=c;break;}
}//end c loop
}//end v loop
}//end colorGraph



function solveButton(){
if(solving&&el('solve').value=='Solve'){
el('solve').value='Solving...';
el('solve').style.backgroundColor='#ffd7d4';
}else if(!solving&&el('solve').value=='Solving...'){
el('solve').value='Solve';
el('solve').style.backgroundColor='#dbedff';
}
}//end solveButton



function buildRandomGraphButton(){
if(building&&el('buildRandomGraph').value=='Build Random Graph'){
el('buildRandomGraph').value='Building..........';
el('buildRandomGraph').style.backgroundColor='#ffd7d4';
}else if(!building&&el('buildRandomGraph').value=='Building..........'){
el('buildRandomGraph').value='Build Random Graph';
el('buildRandomGraph').style.backgroundColor='#dbedff';
}
}//end buildRandomGraphButton




function showSolvingButton(){
if((el('showSolving').value=='Solving...||'||el('showSolving').value=='Paused...\ > ')&&showSolving&&!stepping){
pauser=!pauser;}
stepping=false;
solving=false;
showSolving=true;
showSolvingStatus();
if(pauser){
el('showSolving').value='Paused...\ > ';
el('showSolving').style.backgroundColor='#ffd7d4';
}else if(!pauser||streamSolving){el('showSolving').value='Solving...||';}
}//end showSolvingButton




function showSolvingStatus(){
if(showSolving){
el('showSolving').style.backgroundColor='#dbedff';
el('showSolving').value='Solving...||';
}else{
el('showSolving').style.backgroundColor='white';
el('showSolving').value='Show Solving';
}

if(streamSolving){
el('streamSolve').style.backgroundColor='#ffd7d4';
}else{
el('streamSolve').style.backgroundColor='#ffffff';
}
}//end showSolvingStatus


//called once onload

function animInit(){
cancelAnimationFrame(animId);
animId=0;
stepping=false;
rColorGraphDone=false;
solved=false;
showSolvingStatus();
pauser=false;
animSV=0;
animate();
setTimeout("activeButton('showSolving');showSolvingButton();",500);
}//end animInit


function animate(){
setTimeout(function(){
animId=requestAnimationFrame(animate);

if(streamSolving&&solved){solved=false;
setTimeout("buildAndRender();activeButton('showSolving');showSolvingButton();",2000);
}


if(showSolving&&!pauser&&!stepping){
recursiveNeighborSolver();
render();
}//end showSolving&&!&&pauser
},1000/framesPerSecond);//end setTimeout
}//end animate



function stepper(){
showSolving=false;
recursiveNeighborSolver();
render();
}//end stepper



function recursiveNeighborSolver(){

numSolves++; numSolvesCounter=numSolves;
//daa('tester','<br><br>'+numSolves+'  -----------------<br>');

stillSearching=false;
let stringer='';
let errorString='';
let checkCounter=0;

nonNeighbor=[];
for(let s=0;s<lastSearcher.length;s++){
nonNeighbor[s]=lastSearcher[s];
}
searcher=[];
lastSearcher=[];


nextVertex:
for(let v=0;v<vertices.length;v++){
let neighArray=[];
let neighColorCount=[];
let colorAvailable=[true,true,true,true];

if(vertices[v].c==4||vertices[v].searching){
stillSearching=true;

for(let n=0;n<vertices[v].nCount;n++){
if(isThere(vertices[vertices[v].n[n]])){
let nColor=vertices[vertices[v].n[n]].c;
neighArray.push({
i:vertices[v].n[n],
color:nColor
});

colorAvailable[nColor]=false;
}//isThere
}//end n loop

for(let c=0;c<4;c++){
if(colorAvailable[c]&&c!=vertices[v].c){
vertices[v].c=c;
vertices[v].searching=false;
if(showSolving||stepping){render();return;}else{
continue nextVertex;
}
}//if(colorAvailable[c]
}//end c loop

let colorCounter=[];
for(let c=0;c<4;c++){
colorCounter[c]= neighArray.filter((obj)=>obj.color==c).length;

let nIndex=neighArray.filter(x=>x.color===c).map(x=>x.i);


let isNeigh=true;
for(let nn=0;nn<nonNeighbor.length;nn++){
for(let j=0;j<nIndex.length;j++){
if(nonNeighbor[nn]==nIndex[j]){isNeigh=false;}

}//end j loop
}//end nn loop

if(isNeigh){
neighColorCount.push({
nIndex:nIndex,
color:c, 
count:colorCounter[c]
});
}//isNeigh
}//end c loop

neighColorCount.sort((a,b)=>
a.count-b.count
||
a.color-b.color);

let ind=0;
if(loopingDetected){ind=randRange(1,2);
loopCounter++;
if(loopCounter>2){
loopingDetected=false;
}
}

if(isThere(neighColorCount[ind])&&isThere(neighColorCount[ind].nIndex[0])){

vertices[v].c=vertices[neighColorCount[ind].nIndex[0]].c;


for(let j=0;j<neighColorCount[ind].nIndex.length;j++){
searcher.push(neighColorCount[ind].nIndex[j]);

}//end j loop

lastSearcher.push(vertices[v].i);

//daa('tester','<br>vertex index: '+vertices[v].i+' --- neighColorCount[0].nIndex: '+JSON.stringify(neighColorCount[0].nIndex)+'<br><br>');


//for looping detection
for(let i=0;i<neighColorCount[0].nIndex.length;i++){
nIndexString+=neighColorCount[0].nIndex[i]+' ';
}//i loop

chunkSolveString+=vertices[v].i+' '+nIndexString;
allSolvesString+=vertices[v].i+' '+nIndexString;


solveCounter++;
if(solveCounter==2){
solveCounter=0;


let regEx=new RegExp(chunkSolveString,'g');
let matchCount=(allSolvesString.match(regEx)||[]).length;

if(matchCount>1){
loopingDetected=true;
if(numSolves%13==0){
//alert('looping detected');
}
//daa('tester','looping detected '+numSolves);
}

chunkSolveString='';
nIndexString='';
}//end if solveCounter greater than
//end looping detection


stringer+='<br>vertex index: '+vertices[v].i+' --- '+JSON.stringify(neighColorCount)+' -  .nIndex.length: '+neighColorCount[0].nIndex.length+'<br><br>';

}//isThere neighColorCount
}//end if .c==4

//solve remaining same colored pairs
if(v==vertices.length-1&&(!stillSearching||tripleCheck)){

lastSearcher=[];
let foundUnsolved=false;

for(let i=0;i<pairArr.length;i++){
if(isThere(vertices[pairArr[i][0]])&&isThere(vertices[pairArr[i][1]])){
if(
vertices[pairArr[i][0]].c==
vertices[pairArr[i][1]].c
){

vertices[pairArr[i][0]].searching=true;
vertices[pairArr[i][1]].searching=true;
lastSearcher.push(vertices[pairArr[i][0]].i);
lastSearcher.push(vertices[pairArr[i][1]].i);
vertices[pairArr[i][0]].c=0;
vertices[pairArr[i][1]].c=0;

solveRemainingPass++;
foundUnsolved=true;

}//if same color
}//isThere
}//end i loop

if(foundUnsolved){v=0;
}else if(!tripleCheck){
v=0;
checkCounter++;
if(checkCounter>3){
tripleCheck=true;}
}//if !tripleCheck
}//if v==vertices.length-1
//end solve remaining same colored pairs

}//end v loop


for(let v=0;v<vertices.length;v++){
vertices[v].searching=false;
for(let s=0;s<searcher.length;s++){
if(searcher[s]==vertices[v].i){
vertices[v].searching=true;
}
}//end s loop

if(v==vertices.length-1){

el('tester').scrollTop=el('tester').scrollHeight;

if(stillSearching==false){
endTime=Date.now();
deltaTime=endTime-startTime;
//alert('all solved');
if(showSolving||stepping){showMessage('All Solved',2000);}
if(solving){
showMessage('Solved in: '+deltaTime+' ms',2000);
solving=false;solveButton();
}
rColorGraphDone=false;
solved=true;
animSV=0;
showSolving=false;
showSolvingStatus();
pairString='';
numSolves=0;
solveCounter=0;
chunkSolveString='';
loopingDetected=false;
nIndexString='';
solveRemainingPass=0;
tripleCheck=false;

render();
return;
}else if(stillSearching==true){


if(numSolves==40){
animSV=0;
}else if(numSolves==100){
tripleCheck=false;
checkCounter=0;
}else if(numSolves==5000){

alert('still solving after numSolves:'+numSolves+' so...returning.');
return;
}

if(!showSolving&&!pauser&&!stepping){
recursiveNeighborSolver();
}
}//if stillSearching
}//if(v==vertices.length-1){
}//end v loop
}//end recursiveNeighborSolver


function showMessage(messageString,time){
el('messageHolder').style.display='block';
da('message',messageString);
messageTimer=setTimeout("el('messageHolder').style.display='none';",time);
}//end show message

function hideMessage(timerId){
clearTimeout(timerId);
el('messageHolder').style.display='none';
}//hide message


function reSolverReset(){
solving=false;
solved=true;
animSV=0;
showSolving=false;
showSolvingStatus();
pairString='';
numSolves=0;
solveCounter=0;
chunkSolveString='';
loopingDetected=false;
nIndexString='';
solveRemainingPass=0;
tripleCheck=false;
pairString='';
da('tester','');
allSolvesString='';
}//end resolver reset


function getFlexibles(){
flexibles=[];

for(let v=0;v<vertices.length;v++){
flexibles[v]={
avail:false,
i: vertices[v].i,
colorsAvailable:[]
};
if(vertices[vertices[v].i].c!=4){
let colorAvailable=[true,true,true,true];
for(let c=0;c<4;c++){
for(let n=0;n<vertices[v].nCount;n++){
if(isThere(vertices[vertices[v].n[n]])){
if(
(vertices[v].c==c)||
(vertices[vertices[v].n[n]].c==c)){
colorAvailable[c]=false;
break;//next color
}
}//isThere
}//end n loop

if(colorAvailable[c]){
vertices[v].isFlexible=true;
flexibles[v].avail=true;
flexibles[v].colorsAvailable.push(fourColorShort[c]);
}

}//end c loop
}//!=4
}//end v loop

flexiblesCount=
flexibles.filter((obj)=>obj.avail==true).length;

}//end getFlexibles



function buildAndRender(){
vertices=[];
triangles=[];
pairArr=[];
pairString='';
//da('tester','');
numSolves=0;
solveCounter=0;
chunkSolveString='';
allSolvesString='';
loopingDetected=false;
nIndexString='';
solveRemainingPass=0;
tripleCheck=false;
rColorGraphDone=false;
solved=false;
solving=false;
showSolving=false;
linkStart=-1;
linkEnd=-1;
delaunay=true;

let radius=diam*.5;
let offset=.5*radius;
let onlySome=0;
let pointCounter=0;

if(setRandomVerts){
for(let y=diam;y<cH-radius;y+=diam){
if(pointCounter>=numPoints){break;}
for(let x=radius*1.7;x<cW-radius;x+=diam){
let randOffX=randRange(-offset,offset);
let randOffY=randRange(-offset,offset);
onlySome=randRange(1,30);
if(onlySome>20){
vertices.push(new Vertex(x+randOffX,y+randOffY,4,pointCounter,0,[],false));
pointCounter++;
triangles=triangulate(vertices);

if(pointCounter>=numPoints){break;}
}//onlySome
}//end x loop
}//end y loop


sortByNeighborCount();
if(!showSolving){
render();
}

}else if(!setRandomVerts){
getGraphData();
}

building=false;
//activeButton('buildRandomGraph');
buildRandomGraphButton();
hideMessage(messageTimer);
}// end buildAndRender





var renderCount=0;

function render(){
for(let v=0;v<vertices.length;v++){
vertices[v].i=v;}


if(showFlexibles){getFlexibles();}

//drawBackground
ctx.beginPath();
ctx.globalAlpha=1;
ctx.fillStyle='white';
ctx.fillRect(0, 0, cW, cH);
ctx.globalAlpha=1;
ctx.fillStyle=backgroundColor;//d6d651
ctx.fillRect(0, 0, cW, cH);
ctx.closePath();

//drawFrame that saves to image
ctx.globalAlpha=.4;
ctx.lineWidth=4;
ctx.strokeStyle='black';
ctx.strokeRect(0, 0, cW, cH);
ctx.lineWidth=2;
//end drawFrame


if(delaunay){
//draw triangles
ctx.globalAlpha=1;
let i=0;
triangles.forEach(function(triangle){
ctx.beginPath();
ctx.moveTo(triangle.v0.x, triangle.v0.y);
ctx.lineTo(triangle.v1.x, triangle.v1.y);
ctx.lineTo(triangle.v2.x, triangle.v2.y);
ctx.closePath();
ctx.strokeStyle="black";
ctx.lineWidth=1;
ctx.stroke();
//ctx.fillStyle='transparent';//triColors[i];
//ctx.fill();
i++;
});//end triangles foreach

}//!custom

if(!delaunay){
ctx.globalAlpha=1;



for(let i=0;i<pairArr.length;i++){
if(isThere(vertices[pairArr[i][0]])&&isThere(vertices[pairArr[i][1]])){

ctx.beginPath();

ctx.moveTo(
vertices[pairArr[i][0]].x, 
vertices[pairArr[i][0]].y);


ctx.lineTo(
vertices[pairArr[i][1]].x, vertices[pairArr[i][1]].y);

ctx.closePath();
ctx.strokeStyle='black';
ctx.lineWidth=1;
ctx.stroke();
}//isThere
}//end i loop
}//if !delaunay



//highlight same color vertices link


if(highlightSame){

sameColorVerts=[];
for(let i=0;i<pairArr.length;i++){
sameColorVerts[i]=false;
}

for(let i=0;i<pairArr.length;i++){
if(isThere(vertices[pairArr[i][0]])&&isThere(vertices[pairArr[i][1]])){
if(vertices[pairArr[i][0]].c==vertices[pairArr[i][1]].c){
sameColorVerts[i]=true;
}//end if
}//isThere
}//end i loop


for(let i=0;i<pairArr.length;i++){

if(sameColorVerts[i]){

ctx.beginPath();
ctx.moveTo(vertices[pairArr[i][0]].x, vertices[pairArr[i][0]].y);
ctx.lineTo(vertices[pairArr[i][1]].x, vertices[pairArr[i][1]].y);
ctx.closePath();
ctx.strokeStyle="black";
ctx.lineWidth=5;
ctx.stroke();

}//end if same color

}//end i loop

}//end if highlightSame

    

//draw vertices as circles
let ci=0;
this.vertices.forEach(function(vertex){
ctx.beginPath();
ctx.arc(vertex.x, vertex.y, vertSize, 0, Math.PI * 2, true);
ctx.closePath();

if(xray){
ctx.fillStyle='transparent';
}else{
ctx.fillStyle=fourColor[vertices[ci].c];
}
ctx.fill();

if(vertices[ci].c==4){
ctx.fillStyle='black';
}else{
ctx.fillStyle='white';
}
ctx.font="26px Monospace";
let xOff=12;
if(vertex.i>99){xOff=24;}
if(showNumNeigh){
ctx.fillText(vertex.nCount,vertex.x-12,vertex.y+8);
}else{
ctx.fillText(vertex.i,vertex.x-xOff,vertex.y+8);
}

if(showFlexibles&&flexibles[ci].avail){
ctx.fillStyle='black';
for(let c=0;c<flexibles[ci].colorsAvailable.length;c++){
let coff=c*15;
ctx.fillText(flexibles[ci
].colorsAvailable[c],vertex.x+12+coff,vertex.y+58);
}//end c loop
ctx.strokeStyle='black';
ctx.lineWidth=14;
}else{
ctx.strokeStyle='black';
ctx.lineWidth=1;
}
ctx.stroke();

ci++;
});//end vertices foreach

renderCount++;
}//end render




//Vertex object constructor; //returns {x:x,y:y,c:c,i:i,n:n,nCount:nCount,searching:searching}

function Vertex(x,y,c,i,n,nCount,searching,inSameColorPair,isFlexible){ 
this.x=x;
this.y=y;
this.c=c;//color
this.i=i;//index
this.n=n;//neighbors
this.nCount=nCount;//neighbors count
this.searching=searching;
this.inSameColorPair=inSameColorPair;
this.isFlexible=isFlexible;
}//end Vertex

      
//Triangle object constructor
//returns {v0:Vertex, v1:Vertex, v2:Vertex, center:Vertex, radius:number, radius_squared:number}

function Triangle(v0, v1, v2){ 
this.v0=v0;
this.v1=v1;
this.v2=v2;
//calculate circumcircle;we always do this when we build a new triangle object, so why not put it here in the constructor, instead of putting it somewhere else and calling it from here?
let A=this.v1.x - this.v0.x;
let B=this.v1.y - this.v0.y;
let C=this.v2.x - this.v0.x;
let D=this.v2.y - this.v0.y;
let E=A * (this.v0.x + this.v1.x) + B * (this.v0.y + this.v1.y);
let F=C * (this.v0.x + this.v2.x) + D * (this.v0.y + this.v2.y);
let G=2.0 * (A * (this.v2.y - this.v1.y) - B * (this.v2.x - this.v1.x));
let dx, dy;
if(Math.abs(G)<EPSILON){
let minx=Math.min(this.v0.x, this.v1.x, this.v2.x);
let miny=Math.min(this.v0.y, this.v1.y, this.v2.y);
let maxx=Math.max(this.v0.x, this.v1.x, this.v2.x);
let maxy=Math.max(this.v0.y, this.v1.y, this.v2.y);
this.center=new Vertex((minx + maxx) / 2, (miny + maxy) / 2, 4);
dx=this.center.x - minx;
dy=this.center.y - miny;
}else{
let cx=(D * E - B * F) / G;
let cy=(A * F - C * E) / G;
this.center=new Vertex(cx, cy, 4);
dx=this.center.x - this.v0.x;
dy=this.center.y - this.v0.y;
}
this.radius_squared=dx * dx + dy * dy;
this.radius=Math.sqrt(this.radius_squared);
//end calculate circumcircle;
}//end Triangle

//Edge object constructor; 
//returns {v0:Vertex,v1:vertex,equals:function,inverse:function}
function Edge(v0, v1){ 
this.v0=v0;
this.v1=v1;
this.equals=function(other){return (this.v0 === other.v0 && this.v1 === other.v1);};
this.inverse=function(){return new Edge(this.v1, this.v0);};
}//end edge


function triangulate(vertices){
pairString='';
let triangles=[];
let minx, miny, maxx, maxy;
vertices.forEach(function(vertex){
if(minx === undefined || vertex.x<minx){ minx=vertex.x;}
if(miny === undefined || vertex.y<miny){ miny=vertex.y;}
if(maxx === undefined || vertex.x > maxx){ maxx=vertex.x;}
if(maxy === undefined || vertex.y > maxy){ maxy=vertex.y;}
});
let dx=(maxx - minx) * 10;
let dy=(maxy - miny) * 10;
let stv0=new Vertex(minx - dx, miny - dy * 3, 4);
let stv1=new Vertex(minx - dx, maxy + dy, 4);
let stv2=new Vertex(maxx + dx * 3, maxy + dy, 4);
let st=new Triangle(stv0, stv1, stv2);
triangles.push(st);

let ci=0;
vertices.forEach(function(vertex){
vertex.i=ci;
ci++;

edges=[];
triangles=triangles.filter(function(triangle){
let dx=triangle.center.x - vertex.x;
let dy=triangle.center.y - vertex.y;
let dist_squared=dx * dx + dy * dy;
let inCirc=(dist_squared <= triangle.radius_squared);
if(inCirc){
edges.push(new Edge(triangle.v0, triangle.v1));
edges.push(new Edge(triangle.v1, triangle.v2));
edges.push(new Edge(triangle.v2, triangle.v0));
return false;
}else{
return true;
}
});

let uniqueEdgesArray=[];


for(let i=0;i<edges.length;++i){
let edge1=edges[i];

let unique=true;
for(let j=0;j<edges.length;++j){
if(i === j){continue;}
let edge2=edges[j];
if(edge1.equals(edge2) || edge1.inverse().equals(edge2)){unique=false;break;}
} //end j loop
if(unique){
uniqueEdgesArray.push(edge1);
}
}//end i loop
edges=uniqueEdgesArray;

edges.forEach(function(edge){
triangles.push(new Triangle(edge.v0, edge.v1, vertex));
});//end foreach edges
});//end foreach vertices


triangles=triangles.filter(function(triangle){
return !(triangle.v0 == st.v0 || triangle.v0 == st.v1 || triangle.v0 == st.v2 ||
triangle.v1 == st.v0 || triangle.v1 == st.v1 || triangle.v1 == st.v2 ||
triangle.v2 == st.v0 || triangle.v2 == st.v1 || triangle.v2 == st.v2);
});


return triangles;
}//end triangulate




function countOccurrences(arr,property,targetValue,conditionProperty, conditionValue){
return arr.reduce((count,obj)=>{
if(obj[property]===targetValue &&obj[conditionProperty]===conditionValue){
    return count+1;
    }
    return count;
  }, 0);
}





function dropRandom(){



let sampleSize=5;

let sumVertCount=0;
let avgVertCount=0;

let sumFlexCount=0;
let avgFlexCount=0;

let sumVertFlexRatios=0;
let avgVertFlexRatios=0;


let sumDiffColorPairsCount=0;
let avgDiffColorPairsCount=0;

let sumSameColorPairsCount=0;
let avgSameColorPairsCount=0;

let avgDiffSamePairsRatio=0;
let sumDiffSamePairsRatio=0;

let sumPairCount=0;
let avgPairCount=0;

let sumSameFlexibleCount=0;
let avgSameFlexibleCount=0;

let sumVertsInSameColorPairCount=0;
let avgVertsInSameColorPairCount=0;

let vertsInSameColorPairCount=0;

let sumNeighsPerVertex=0;
let avgNeighsPerVertex=0;

let sumColorsPerFlexible=0;
let avgColorsPerFlexible=0;

let maxNeighs=0;
let minNeighs=1000;

for(let r=0;r<sampleSize;r++){
buildAndRender();


let sameColorPairsCount=0;
let diffColorPairsCount=0;
let neighsPerVertex=0;
let colorsPerFlexible=0;

sumVertCount+=vertices.length;
sumPairCount+=pairArr.length;

maxNeighs=0;

for(let v=0;v<vertices.length;v++){
vertices[v].c=randRange(0,3);
neighsPerVertex+=vertices[v].nCount;
if(vertices[v].nCount>maxNeighs){
maxNeighs=vertices[v].nCount;
}
if(vertices[v].nCount<minNeighs){
minNeighs=vertices[v].nCount;
}

//render();
}//end v loop




neighsPerVertex/=vertices.length;
sumNeighsPerVertex+=neighsPerVertex;


for(let j=0;j<pairArr.length;j++){
if(vertices[pairArr[j][0]].c==vertices[pairArr[j][1]].c){
vertices[pairArr[j][0]].inSameColorPair=true;
vertices[pairArr[j][1]].inSameColorPair=true;
sameColorPairsCount++;
}else{
diffColorPairsCount++;
}
}//end j loop




render();
getFlexibles();


for(let f=0;f<flexibles.length;f++){
if(flexibles[f].avail){
colorsPerFlexible+=flexibles[f].colorsAvailable.length;
}//if(flex
}//f loop
sumColorsPerFlexible+=colorsPerFlexible/flexiblesCount;

sumFlexCount+=flexiblesCount;
sumVertFlexRatios+=(vertices.length/flexiblesCount);

sumDiffSamePairsRatio+=(diffColorPairsCount/sameColorPairsCount);

sumSameColorPairsCount+=sameColorPairsCount;
sumDiffColorPairsCount+=diffColorPairsCount;

let sameFlexibleCount=countOccurrences(vertices, 'isFlexible',true,'inSameColorPair',true);
sumSameFlexibleCount+=sameFlexibleCount;




vertsInSameColorPairCount=vertices.filter((obj)=>obj.inSameColorPair==true).length;
sumVertsInSameColorPairCount+=vertsInSameColorPairCount;


}//end r loop

avgColorsPerFlexible=(sumColorsPerFlexible/sampleSize).toFixed(3);

avgNeighsPerVertex=(sumNeighsPerVertex/sampleSize).toFixed(0);

avgVertsInSameColorPairCount=(sumVertsInSameColorPairCount/sampleSize).toFixed(0);


avgSameFlexibleCount=(sumSameFlexibleCount/sampleSize).toFixed(0);

avgPairCount=(sumPairCount/sampleSize).toFixed(0);

avgSameColorPairsCount=(sumSameColorPairsCount
/sampleSize).toFixed(0);

avgDiffColorPairsCount=(sumDiffColorPairsCount
/sampleSize).toFixed(0);

avgDiffSamePairsRatio=(sumDiffSamePairsRatio/sampleSize).toFixed(2);

avgVertCount=(sumVertCount/sampleSize).toFixed(0);
avgPercentVertsInSameColorPair=((avgVertsInSameColorPairCount/avgVertCount)*100).toFixed(0);
avgFlexCount=(sumFlexCount/sampleSize).toFixed(0);
avgVertFlexRatio=(sumVertFlexRatios/sampleSize).toFixed(2);

let avgVertPairPercent=((avgVertCount/avgPairCount)*100).toFixed(0);
let avgVertPairRatio=(avgVertCount/avgPairCount).toFixed(2);
let avgPairsPerVertex=(avgPairCount/avgVertCount).toFixed(2)

el('data').style.display='block';

let dat=[
[`number of graphs sampled:`,sampleSize], 
[`avg # vertices:`,avgVertCount],
[`avg # pairs:`,avgPairCount],
['avg ratio pairs/verts:',avgPairsPerVertex+` x more pairs`],
['avg ratio verts/pairs:',avgVertPairRatio+' ('+avgVertPairPercent+'% of pairs)'],
['avg # neighbors per vertex, max, min:',avgNeighsPerVertex+', '+maxNeighs+', '+minNeighs],
[`avg # flexibles(can be alt. color(s)):`,avgFlexCount],
[`avg ratio flexibles/vertices:`,
(1/avgVertFlexRatio).toFixed(2)+` (`+((1/avgVertFlexRatio)*100).toFixed(0)+`% of verts)`],
[`avg ratio vertices/flexibles:`,avgVertFlexRatio+` x more verts`],
[`avg # different color pairs:`,avgDiffColorPairsCount],
[`avg # same color pairs:`,avgSameColorPairsCount],
[`avg ratio diff/same pairs:`,avgDiffSamePairsRatio+` times more diff`],
[`avg ratio same/diff pairs:`,(1/avgDiffSamePairsRatio).toFixed(2)+` (`+((1/avgDiffSamePairsRatio)*100).toFixed(0)+`% of same)`],
[`avg % of pairs which are different colors:`,((avgDiffColorPairsCount/avgPairCount)*100).toFixed(0)+`%`],
[`avg % of pairs which are same colors:`,((avgSameColorPairsCount/avgPairCount)*100).toFixed(0)+`%`],
[`avg # verts in at least one same color pair:`,avgVertsInSameColorPairCount+` (`+avgPercentVertsInSameColorPair+`% of all verts)`],
[`avg # flexible verts in same color pairs:`,avgSameFlexibleCount+` (`+((avgSameFlexibleCount/avgFlexCount)*100).toFixed(0)+`% of all flexibles)`],
[`avg % verts in same color pairs which are flexible:`,((avgSameFlexibleCount/avgVertsInSameColorPairCount)*100).toFixed(0)+`%`],
[`avg # alternate colors per flexible:`,avgColorsPerFlexible]
];


let stringer2=`<table style="width:100%;"`;
for(let d=0;d<dat.length;d++){
stringer2+=
`<tr><td class="t">`+
dat[d][0]
+`</td><td class="t2">`+
dat[d][1]
;
}//end d loop
stringer2+=`</td></tr></table>`;

da('tableId',stringer2);
activeButton('dropRandom');
setTimeout('setDataShowHideButton();',100);
hideMessage('messageTimer');
}//dropRandom





document.body.onload=function(){
cancelAnimationFrame(animId);
buildAndRender();
animInit();
getGraphFilenames();
}//end onload

zoom(el('filenameInputDiv'),2,80,20);
zoom(el('numVertsInputDiv'),2,80,20);
zoom(el('fpsInputDiv'),2,80,20);
//zoom(el('buttonHolder'),.25,100,100);
//zoom(el('bodyer'),.25,100,100);




</script>

</body>
</html>
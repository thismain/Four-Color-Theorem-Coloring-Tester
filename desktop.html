<html>
<head>
<meta name="viewport" content="width=device-width,initial-scale=.25"></meta>
<!--<script src="redirectToMobile.js"></script>-->
<style>
.b{
font-size:18px;
font-family:monospace;
visibility:visible;
position:relative;
background-color:#ffffff;
padding:11px;
border:1px solid #000000;
margin-right:-4px;
margin-left:-4px;
display:inline-block;
}



.t{
width:25%;
border-bottom:1px solid #cdcdcd;
margin:0px;
font-size:22px;
}
.t2{
width:75%;
border-bottom:1px solid #cdcdcd;
margin:0px;
padding:4px;
padding-left:50px;
font-size:22px;
}

.container::-webkit-scrollbar{display:none;}/* Safari and Chrome */
.container{-ms-overflow-style:none; /* Internet Explorer 10+ */
scrollbar-width: none;  /* Firefox */}

</style>
</head>
<body id="bodyer" style="font-family:monospace;overflow:hidden;margin:0px;padding:0px;">
<script>
var usePHP=false;
var serverAddress='http://0.0.0.0:45267/';
var EPSILON=1.0e-6;
var Vertex;
var Triangle;
var Edge;
var triangulate;
var edges;
var vertices;
var triangles;
var vertPairs;
var pairString='';
var fourColor=["red","gold","MediumSeaGreen","DeepSkyBlue","white"];
var fourColorShort=['R','Y','G','B','W'];
var savedData=[];
var triColors=[];
var dragging=false;
var altKey=false;
var inset=125;
var vertexToEdit=-1;
var backgroundColor='#f5f5f5';
var dataFileName="default.txt";
var numSavedGraphs=0;
var graphFileNames=[];
var dataSend='';
var dataReceive=null;
var getDataInterval=0;
var stringArr=[];
var pairArr=[];
var setRandomVerts=true;
var sortedVerts=[];
var counter=0;
var colorSavedGraph=false;
var xray=false;
var sameColorVerts=[];
var highlightSame=true;
var sortString='';
var searcher=[];
var lastSearcher=[];
var nonNeighbor=[];
var numSolves=0;
var solveCounter=0;
var chunkSolveString='';
var allSolvesString='';
var nIndexString='';
var loopingDetected=false;
var solveRemainingPass=0;
var loopCounter=0;
var tripleCheck=false;
var framesPerSecond=30;
var pauser=false;
var showSolving=true;
var stillSearching=false;
var animId=0;
var rColorGraphDone=false;
var animSV=0;
var stepping=false;
var solved=false;
var loading=true;
var showNumNeigh=false;
var solving=false;
var timeToSolve=0;
var startTime=Date.now();
var endTime=Date.now();
var deltaTime=endTime-startTime;
var lastButton='buildRandomGraph';
var messageTimer=0;
var building=false;
var flexibles=[];
var showFlexibles=true;
var flexibleColor='#db37d9';
var numSolvesCounter=0;
var flexiblesCount=0;
var diffColorPairsCount=0;
var sameColorPairsCount=0;

var gettingLinkStart=false;
var addingVert=false;
var linkStart=-1;
var linkEnd=-1;
var startConnecting=false;
var endConnecting=false;
var delaunay=true;
var moveRaw=false;
var streamSolving=true;
var buildTimer=0;clearTimeout(buildTimer);
var solveTimer=0;clearTimeout(solveTimer);
var numVertsTimer=0;clearTimeout(numVertsTimer);
var animateTimer=0;clearTimeout(animateTimer);
var typing=false;

function getDeltaTime(){
deltaTime=endTime-startTime;
}//end getDeltaTime

function zoom(elm,scale,w,h){
elm.style.transform="scale("+scale+")";
elm.style.transformOrigin="top left";
elm.style.width=(w/scale)+"%";
elm.style.height=(h/scale)+"%";
}//end zoom



</script>

</div>

<div id="testerHolder" style="background-color:black;position:absolute;left:40px;top:40px;z-index:10000;border:6px solid white;display:none;height:70%;overflow:auto;">

<div id="tester" style="color:#00ff00;font-size:25px;word-wrap:break-word;padding:50px;padding-bottom:0px;padding-top:20px;overflow:auto;">
</div>
<div onmousedown="showHide('testerHolder');" style="text-align:center;color:#bbbbbb;bottom:0px;right:0px;font-size:20px;color:black;padding:10px;height:20px;width:20px;background-color:#dddddd;border: 2px solid #bbbbbb;position:absolute;font-family:monospace;">x</div>
</div>

<div id="messageHolder" style="position:absolute;left:450px;top:500px;padding:60px;border:12px solid black;display:none;z-index:1000000;background-color:white;">

<div id="message" style="display:block;white-space:nowrap;font-family:monospace;font-weight:bold;color:black;font-size:40px;">
</div>
</div>


<iframe id="ifr" src="" style="display:none;z-index:1000;position:absolute;top:2000px;left:10px;height:1800px;width:1200px;border:1px solid black;">
</iframe>


<canvas id="canvas" width="440" height="550" style="position:absolute;left:0px;top:0px;z-index:100;"></canvas>


<div class="container" id="shortcutKeys" style="background-color:white;position:absolute;left:30px;top:30px;z-index:10000;border:2px solid black;display:none;overflow:auto;padding:10px;margin:0px;">
<div id="shortcutKeysHeading" style="border:2px solid black;color:white;background-color:#000000;font-family:monospace;padding:10px;margin:0px;position:fixed;left:30px;top:30px;z-index:10001;font-size:40px;">
<b>Shortcut Keys:</b>

<div onmousedown="showHide('shortcutKeys');" style="text-align:center;color:#bbbbbb;top:6px;right:6px;font-size:20px;color:black;padding-bottom:8px;padding-left:8px;padding-right:8px;height:18px;width:18px;background-color:#dddddd;border: 2px solid #bbbbbb;position:absolute;font-family:monospace;">x</div>
</div>
<div style="background-color:#ffffff;font-family:monospace;padding:10px;display:block;">
<br><br>
<table>
<tr><td class="d">
    [P]: Show Solving </td><td class="t2">Renders each step of the 4-coloring algorithm as it solves the graph
</td></tr>
<tr><td class="t">[S]: Solve </td><td class="t2">Renders result of solve and displays time in milliseconds
</td></tr>
<tr><td class="t">[V]: Step </td><td class="t2">Advance one step of algorithm solving at a time 
</td></tr>
<tr><td class="t">[B]: Build Random Graph </td><td class="t2">Build a random graph with delaunay triangulation
</td></tr>
<tr><td class="t">[H]: Show/Hide Buttons </td><td class="t2">Show/Hide buttons for all functions
</td></tr>
<tr><td class="t">[A]: Add Vertex </td><td class="t2">Click on graph to add a vertex with delaunay triangulation connecting it to surrounding Vertices
</td></tr>
<tr><td class="t">[M]: Move Vertex </td><td class="t2">Click on a vertex and drag it to move it with delaunay triangulation adjusting connections 
</td></tr>
<tr><td class="t">[D]: Delete Vertex </td><td class="t2">Click on a vertex to delete it with delaunay triangulation modifying surrounding connections
</td></tr>
<tr><td class="t">[C] Color Vertex </td><td class="t2">Click on a vertex to change the color in cycles of red, yellow, green and blue
</td></tr>
<tr><td class="t">[N] Number of Vertices</td><td class="t2">Set number of vertices
</td></tr>
<tr><td class="t">[F] Frames Per Second</td><td class="t2">Set frames per second of animation when showing Solving
</td></tr>
<tr><td class="t">[T] Time to Solve</td><td class="t2">Display time to solve in milliseconds and number of steps
</td></tr>
<tr><td class="t">[G] Number of Neighbors</td><td class="t2">Display numbers of neighbors on each vertex
</td></tr>
<tr><td class="t">[X] Flexibles</td><td class="t2">Highlight the vertices which can be another color and list possible colors
</td></tr>
<tr><td class="t">[O] Console</td><td class="t2">Enter a variable and hit enter to see the value of a global variable
</td></tr>
<tr><td class="t">[1] Add Vertex<br>(no delaunay)</td><td class="t2">Click the graph to add a vertex without delaunay triangulation
</td></tr>
<tr><td class="t">[2] Add a Linked Vertex<br>(no delaunay)</td><td class="t2">Click a starting vertex and then a free space to add a linked vertex without delaunay triangulation
</td></tr>
<tr><td class="t">[3] Link Vertices<br>(no delaunay)</td><td class="t2">Click a vertex to which to link, and then another vertex to link them, without delaunay triangulation
</td></tr>
<tr><td class="t">[4] Move a Vertex<br>(no delaunay)</td><td class="t2">Click a vertex and drag to move a vertex without delaunay triangulation
</td></tr>
<tr><td class="t">[5] Delete a Vertex<br>(no delaunay)</td><td class="t2">Click a vertex to delete it without any delaunay triangulation
</td></tr>
<tr><td class="t">[W] Toggle Fullscreen</td><td class="t2">Toggle Fullscreen
</td></tr>
<tr><td class="t">[Y] Tester Display</td><td class="t2">In the source javascript, use da('tester',variable); to overwrite tester; use daa... to append writes
</td></tr>
<tr><td class="t">[K] Shortcut Keys</td><td class="t2">Toggle shortcut key list with descriptions
</td></tr></table>
</div>

</div>



<select id="selectGraph" onchange="setRandomVerts=false;dataFileName=graphFileNames[parseInt(this.options[this.selectedIndex].value)];buildAndRender();" style="z-index:10000000;font-size:40px;font-family:monospace;background-color:#ffffff;border:1px solid #000000;visibility:hidden;position:absolute;top:100px;left:250px;padding:30px;">
<option disabled selected id="label">Load Graph</option>
</select>



<div id="filenameInputDiv" style="z-index:10000000;position:fixed;left:50px;bottom:1000px;font-size:30px;font-family:monospace;background-color:#ffffff;padding:40px;border:1px solid black;visibility:hidden;height:40px">


Filename:
<input id="enterGraphName" type="text"  value="" style="display:inline-block;font-family:monospace;color:black;font-size:30px;border:1px solid black;" size="30">

<br>

<input value="save" type="button" onmousedown="dataFileName=el('enterGraphName').value+'.txt';el('filenameInputDiv').style.visibility='hidden';saveGraphData();"  style="display:inline-block;font-size:30px;margin-top:12px;">

<input value="cancel" type="button" onmousedown="el('filenameInputDiv').style.visibility='hidden';" style="display:inline-block;font-size:30px;margin-top:12px;">

</div>







<div id="buttonHolder" style="text-align:left;white-space:wrap;z-index:1000;position:fixed;background-color:#ffffff;padding:6px;bottom:10px;overflow:hidden;display:block;"><div id="buttonHolderInner" style="width:100%;">
 
<input id="about" type="button" value="About" onmousedown="event.preventDefault();activeButton(this.id);showHide('aboutDiv');" class="b">


<input id="streamSolve" type="button" value="stream" 
onmousedown="event.preventDefault();activeButton('streamSolve');streamSolving=!streamSolving; if(streamSolving){solved=false;for(let v=0;v<vertices.length;v++){vertices[v].c=4;}} showSolvingButton();"    
class="b">



<input id="showSolving" type="button" value="Show Solving" onmousedown="showSolvingActions();" class="b" title="[P] or spacebar">


<input id="solve" type="button" value="Solve" 
onmousedown="solveActions();" class="b" title="[S]">


<input id="step" type="button" value="Step" onmousedown="stepActions();" class="b" title="[ V ]">



<input id="buildRandomGraph" type="button" value="Build Graph" onmousedown="event.preventDefault();activeButton(this.id);el('showSolving').value='Show Solving';showSolving=false;building=true;streamSolving=false;showSolvingStatus();showMessage('Building Graph',60000);buildRandomGraphButton();setRandomVerts=true;clearTimeout(buildTimer);buildTimer=setTimeout('buildAndRender();',50);canv.onmousedown=function(e){setRandomVerts=true;buildAndRender();};" class="b" title="[B]">


<input id="addVertex" type="button" value="Add Vert" 
onmousedown="event.preventDefault();activeButton(this.id);delaunay=true;canv.onmousedown=function(e){delaunay=true;mouseAdd_Vertex(e);solved=false;}"    
class="b" title="[A]">



<input id="moveVertex" type="button" value="Move Vert" 
onmousedown="event.preventDefault();activeButton(this.id);delaunay=true;canv.onmousedown=function(e){delaunay=true;el('expander').style.visibility='hidden';dragging=true;moveRaw=false;getVertexToEdit(e);solved=false;}" class="b" title="[M]">

<input id="deleteVertex" type="button" value="Delete Vert" 
onmousedown="event.preventDefault();activeButton(this.id);delaunay=true;canv.onmousedown=function(e){delaunay=true;getVertexToEdit(e);deleteVertex(e,true);solved=false;}"    
class="b" title="[D]">


<input id="colorVerts" type="button" value="Color Vert" onmousedown="event.preventDefault();activeButton(this.id);canv.onmousedown=function(e){getVertexToEdit(e);changeVertexColor(e);solved=false;}" class="b" title="[C]">


<input id="numberOfVerts" type="button" value="Num Verts" onmousedown="event.preventDefault();activeButton(this.id);el('enterNumVerts').value=numPoints;showHideV('numVertsInputDiv');" class="b" title="[N]">

<input id="fpsId" type="button" value="FPS" onmousedown=" activeButton(this.id);el('enterFPS').value=parseInt(framesPerSecond);showHideV('fpsInputDiv');" class="b" title="[F]">

<input id="timeToSolveId" type="button" value="TimeToSolve" onmousedown="event.preventDefault();activeButton(this.id);showMessage('Solved in: '+deltaTime+' ms<br> after '+ numSolvesCounter+' steps',2000);" class="b" title="[T]">

<input id="neighs" type="button" value="Neighs" 
onmousedown="event.preventDefault();activeButton(this.id);if(showNumNeigh){showNumNeigh=false;}else{showNumNeigh=true;}render();" class="b" title="[G]">


<input type="button" value="Tester" id="testerButton"
onmousedown="event.preventDefault();activeButton(this.id);showHide('testerHolder');el('tester').scrollTop=el('tester').scrollHeight;" class="b" title="[Y]">

<input type="button" value="loadGraph" id="loadGraphButton"
onmousedown="event.preventDefault();activeButton(this.id);showHideV('selectGraph');" class="b" style="display:none;">


<input type="button" value="saveGraph" id="saveGraphButton"
onmousedown="event.preventDefault();activeButton(this.id);showHideV('filenameInputDiv');" class="b" style="display:none;">


<input type="button" value="Flexibles" id="flexiblesButton"
onmousedown="event.preventDefault();activeButton(this.id);showFlexibles=!showFlexibles;render();" class="b" title="[X]">

<input type="button" value="Console" id="consoleButton"
onmousedown="event.preventDefault();activeButton(this.id);showHideV('consoleInputDiv');render();" class="b" title="[O]">



<input id="dropRandom" type="button" value="Random" 
onmousedown="event.preventDefault();activeButton(this.id);showMessage('Running Samples',60000);setTimeout('dropRandom();',20);"    
class="b">





<div id="consoleInputDiv" style="z-index:10000000;position:fixed;left:50px;top:20px;width:90%;font-size:40px;font-family:monospace;background-color:#ffffff;padding:15px;border:1px solid black;visibility:hidden;height:450px;overflow:auto;">

<input id="consoleInput" type="text"  value="pairArr" style="font-family:monospace;color:black;font-size:40px;border:1px solid black;display:inline-block;padding:15px;" size="35" onmousedown="typing=true;">

<input value="Enter" type="button" onmousedown="typing=false;da('tester','<br>'+eval(el('consoleInput').value));da('consoler','<br>'+eval(el('consoleInput').value));" style="display:inline-block;font-size:45px;padding:15px;">

<div id="consoler"  style="width:100%;height:200px;display:block;font-size:30px;margin-top:12px;background-color:white;word-wrap:break-word;">Enter a Variable</div>

<div onmousedown="typing=false;showHideV('consoleInputDiv');" style="text-align:center;color:#bbbbbb;top:6px;right:6px;font-size:20px;color:black;padding-right:8px;padding-left:8px;padding-bottom:8px;height:20px;width:20px;background-color:#dddddd;border: 2px solid #bbbbbb;position:absolute;font-family:monospace;">x</div>
</div>


<!--daa('tester','numPoints:'+numPoints+' --- diam:'+diam+' --- vertSize:'+vertSize+'<br><br>');-->

<!--<br>-->

<input type="button" value="add" id="addButton"
onmousedown="event.preventDefault();activeButton(this.id);gettingLinkStart=false;delaunay=false;canv.onmousedown=function(e){delaunay=false;el('expander').style.visibility='hidden';mouseAdd_Vertex(e);solved=false;}" class="b" title="[1]">

<input type="button" value="addLinked" id="addLinkedButton"
onmousedown="event.preventDefault();activeButton(this.id);delaunay=false;gettingLinkStart=true;canv.onmousedown=function(e){delaunay=false;el('expander').style.visibility='hidden';getVertexToEdit(e);solved=false;}" class="b" title="[2]">

<input type="button" value="Link" id="linkVertsButton"
onmousedown="event.preventDefault();activeButton(this.id);gettingLinkStart=false;startConnecting=true;delaunay=false;canv.onmousedown=function(e){delaunay=false;el('expander').style.visibility='hidden';getVertexToEdit(e);solved=false;}" class="b" title="[3]">


<input id="moveVertButton" type="button" value="Move" 
onmousedown="event.preventDefault();activeButton(this.id);delaunay=false;canv.onmousedown=function(e){delaunay=false;el('expander').style.visibility='hidden';dragging=true;moveRaw=true;getVertexToEdit(e);solved=false;}" class="b" title="[4]">

<input id="deleteVertButton" type="button" value="Delete" 
onmousedown="event.preventDefault();activeButton(this.id);delaunay=false;canv.onmousedown=function(e){delaunay=false;getVertexToEdit(e);deleteVertex(e,false);solved=false;}"    
class="b" title="[5]">


<input id="keysButton" type="button" value="Keys" 
onmousedown="event.preventDefault();activeButton(this.id);showHide('shortcutKeys');"    
class="b" title="[K]">


</div>
<div style="width:44px;">



</div>
</div><!--end buttonHolder-->

<input type="button" value="K" id="shortcuts" onmousedown="showHide('shortcutKeys');" style="color:#000000;text-align:center;right:0px;position:fixed;font-weight:bold;font-size:20px;font-family:monospace;white-space:nowrap;background-color:#ffffff;padding:6px;border:1px solid #000000;bottom:72px;z-index:1000000000;visibility:visible;width:40px;height:34px;margin:0px;" title="[K]">

<input type="button" value="[]" id="fullscreen" onmousedown="toggleFullScreen();" style="color:#000000;text-align:center;right:0px;position:fixed;font-weight:bold;font-size:16px;font-family:monospace;white-space:nowrap;background-color:#ffffff;padding:8px;border:1px solid #000000;right:0px;bottom:34px;z-index:1000000000;visibility:visible;width:40px;height:36px;margin:0px;vertical-align:top;" title="[W]">

<input type="button" value="-" id="expander" onmousedown="controlPanelOpenClose();" style="color:#000000;text-align:center;right:0px;position:fixed;font-weight:bold;font-size:20px;font-family:monospace;white-space:nowrap;background-color:#ffffff;padding:6px;border:1px solid #000000;bottom:0px;z-index:100000000000;visibility:visible;width:40px;height:32px;margin:0px;" title="[H]">


<div id="numVertsInputDiv" style="font-size:50px;font-family:monospace;visibility:hidden;z-index:1000000;position:fixed;left:100px;bottom:0px;background-color:#ffffff;padding:30px;border:6px solid #000000;">

Number of Vertices:
<input id="enterNumVerts" type="text"  size="3" value="60" style="background-color:black;color:caret-color:white;font-family:monospace;color:white;font-size:70px;padding:10px"
onmousedown="typing=true;">

<input id="numVertsApply" value="Apply" type="button" onmousedown="typing=false;activeButton(this.id);flexibles=[];numPoints=parseInt(el('enterNumVerts').value);graphRenderScaleFactors();el('numVertsInputDiv').style.visibility='hidden';building=true;buildRandomGraphButton();setRandomVerts=true;clearTimeout(numVertsTimer);numVertsTimer=setTimeout('buildAndRender();',100);"  style="display:inline-block;font-size:50px;padding:10px;">

<input value="cancel" type="button" onmousedown="typing=false;el('numVertsInputDiv').style.visibility='hidden';" style="display:inline-block;font-size:50px;padding:10px;">

</div>


<div id="fpsInputDiv" style="font-size:50px;font-family:monospace;visibility:hidden;z-index:1000000;position:fixed;left:100px;bottom:0px;background-color:#ffffff;padding:30px;border:6px solid #000000;">


FPS (1-60):
<input id="enterFPS" type="text"  size="3" value="" style="font-family:monospace;color:black;font-size:50px;padding:10px" onmousedown="typing=true;">

<input value="Apply" type="button" onmousedown="typing=false;framesPerSecond=parseInt(el('enterFPS').value);if(framesPerSecond<1){framesPerSecond=1;}else if(framesPerSecond>120){framesPerSecond=120;}el('fpsInputDiv').style.visibility='hidden';"  style="display:inline-block;font-size:50px;padding:10px;">

<input value="cancel" type="button" onmousedown="typing=false;el('fpsInputDiv').style.visibility='hidden';" style="display:inline-block;font-size:50px;padding:10px;">

</div>




<div class="container" id="aboutDiv" style="background-color:white;position:absolute;left:30px;top:30px;z-index:10000;border:2px solid black;display:none;height:80%;overflow:auto;padding-left:40px;padding-top:20px;padding-bottom:20px;padding-right:60px;margin:0px;">
<div id="aboutDivHeading" style="border:2px solid black;color:white;background-color:#000000;font-family:monospace;padding-right:60px;padding-left:40px;padding-top:20px;padding-bottom:20px;margin:0px;position:fixed;left:30px;top:30px;z-index:10001;font-size:30px;">
<b>&nbsp;A Javascript Program for Four Coloring any Graph</b>


<div onmousedown="showHide('aboutDiv');" style="text-align:center;color:#bbbbbb;top:6px;right:6px;font-size:20px;color:black;padding-bottom:8px;padding-left:8px;padding-right:8px;height:18px;width:18px;background-color:#dddddd;border: 2px solid #bbbbbb;position:absolute;font-family:monospace;">x</div>

</div>
<div style="background-color:#ffffff;font-family:monospace;padding:10px;font-size:23px;text-align:justify;line-height:30px">
<br><br><br>
The github files are here:<br>
<a href="https://github.com/thismain/Four-Color-Theorem-Coloring-Tester" target="_blank">https://github.com/thismain/Four-Color-Theorem-Coloring-Tester</a>
<br><br>
The live Desktop demo is here:<br>
<a href="http://moygen.rf.gd/graph2/desktop.html" target="_blank">http://moygen.rf.gd/graph2/desktop.html</a>
<br><br>
The live Mobile demo is here:<br>
<a href="http://moygen.rf.gd/graph2/index.html" target="_blank">http://moygen.rf.gd/graph2/index.html</a>
<br><br>
<img id="screenshot" src="http://moygen.rf.gd/graph2/screenshotter.png">
<br><br>
This is a javascript program for four coloring any graph. Although it would be difficult to test on every possible graph, it has solved hundreds of 600 or fewer vertices. The lowest time to solve for 600 vertices was 28ms, though the average is around 300ms. I use delaunay triangulation, from <a href="https://travellermap.com/tmp/delaunay.js" target="_blank">Joshua Bell's code</a>, to generate random graphs, and these graphs may be modified, either with or without delaunay triangulation. 
<br><br>
The best part of this program, I think, is watching the animation of the algorithm solving the graph at a human observable speed. 
<br><br>
<b>The algorithm:</b><br>
I recently found a faster way. I had been sorting the vertices by number of neighbors, and using high priority colors on vertices of high degree of connectivity, which would get colored first, and low priority colors on vertices of low degree of connectivity, which would get colored last. However, It turns out, it's faster to just go through the vertices as they were set down when building the graph, from the top of the screen to the bottom, applying colors in the same order each time, when they can be applied without conflict.
<br><br>
After the algorithm has gone through the whole graph this way, it then goes back to the vertices for which no color was available. It searches the neighbors of the uncolored vertex for the neighbors with the fewest fellows of their own color. If there are more than one neighbors with only one fellow of the same color, the algorithm chooses the neighbor of the highest priority color. The algorithm assigns the color of that neighbor to the uncolored vertex and then repeats the same process for that neighbor, excluding the vertex which just took its color. 
<br><br>
When the algorithm goes into a loop of following the same circuit over and over, it kicks itself out of the loop with a random choice of either the second or third choice of neighbors from which to take a color, where the neighbors have been sorted by the number of fellows of the same color. 
<br><br>
Finally, the algorithm triple checks the graph for any neighboring vertices of the same color and proceeds in the same manner to fix them.
<br><br>
The reason I made this program is because I wanted to find out why the 4CT is true, and I reasoned that the best way to find that out would be to see why the algorithms that work do work, and how they can be made to work less well and broken. 
<br><br>
I wonder whether a neural network can learn from billions of correctly colored graphs to recognize patterns in strings of permutations of numbers of neighbors and immediately know what colors the vertices can be. So it would solve the graph the way a rubik's cube is solved, rather than searching for the correct solution in real time.
<br><br>
<hr>
<br>
What would a sufficient reason require? Obviously, it would need to explain why five colors are never necessary, but it would also need to show why three colors are sometimes not possible, and what are the conditions that must occur for a three-colorable graph to become a four-colorable one. An analysis of how a graph can, or must, be modified to go from requiring only three colors, to requiring four colors, and also from two to three, and from one to two, would be useful. I'd love to identify and parameterize some property or properties of planar graphs that results in the flexibility we find in assigning colors. But for such a property to be proven to be the operative four-coloring mechanism one would need to show that only the coloring algorithms that exploit this property work, and algorithms that do not exploit this property do not work, and those that only partly make use of this property only partly work. Which task would require that one had first set up the environment for testing several and various algorithms, so as to compare and rate their performance. To this end I imagine identifying the complete set of discrete components which comprise every four coloring algorithm, and from this set of modules choosing, and their parameters adjusting in turn, so as to evaluate the change in effectiveness wrought thereby.
<br><br>
In reality my code is very messy, but still I dream.
<br><br>
What might those modules be? Let's number them:
<br><br>
1) Sorting nodes by numbers of neighbors<br>
2) Assigning the four colors levels of priority<br>
3) Sorting neighbors by number of a color<br>
4) Behavior when no color is available<br>
5) Color transfer from neighbor to uncolored<br> node, or to a conflicted node<br>
6) Loop detection and breaking<br>
7) Self checking the result<br>
8) Order of coloring<br>
9) ...
<br><br>
It turns out to have been unnecessary to worry about complexity increasing with increasing numbers of vertices and with increasing numbers of connections for each node. The hardest graph anyone can contrive will be trivial to color by a sufficient algorithm. There's always enough flexibility in the choice of colors so as to allow for changing colors along a path until a node is encountered that is only neighbored by nodes of two colors, or by one. I think it's worthwhile to mention at the start of anyone's exposure to the 4CT that if four colors are randomly dropped onto one thousand randomly built graphs, the ratio of differently colored neighbors to same colored neighbors averages out to three to one; three differently colored neighbors for every one that is the same color, or 75% different, 25% same.
<br><br>


</div>

</div>



<div class="container" id="data" style="background-color:white;position:absolute;left:30px;top:30px;z-index:10000;border:2px solid black;display:none;height:70%;overflow:auto;padding:10px;margin:0px;">
<div id="dataHeading" style="border:2px solid black;color:white;background-color:#000000;font-family:monospace;padding:10px;margin:0px;position:fixed;left:30px;top:30px;z-index:10001;font-size:30px;">
<b>Random Drop of Colors: Data for Analysis:</b>

</div>
<div style="background-color:#ffffff;font-family:monospace;padding:10px;">
<br><br><br>
<table id="tableId" style="width:100%;"></table>
</div>

</div>

<div id="dataShowHideButton" onmousedown="showHide('data');if(el('data').style.display=='block'){el('dataShowHideButton').innerHTML='-';}else{el('dataShowHideButton').innerHTML='+';}" style="display:none;text-align:center;color:#bbbbbb;top:12px;right:12px;font-size:30px;color:black;padding-top:1px;padding-bottom:5px;padding-left:8px;padding-right:8px;height:30px;width:30px;background-color:#dddddd;border: 2px solid #bbbbbb;position:absolute;font-family:monospace;z-index:100002;">-</div>

<script>


function el(a){return document.getElementById(a);}
function da(a,b){if(el(a)){el(a).innerHTML=b;
//el(a).style.display='block';
}}
function daa(a,b){if(el(a)){el(a).innerHTML+=b;
//el(a).style.display='block';
}}
function randRange(min, max){return Math.floor(Math.random() * (max - min + 1)) + min;}
function degToRad(a){return a*Math.PI/180;}
function isThere(a){return(typeof a!=="undefined"&&typeof a!==null&&(a||a==0));}
function els(a){return document.getElementById(a).style;}
function showHide(a){if(els(a).display=='block'){els(a).display='none'}else{els(a).display='block'}}

function showHideV(a){if(els(a).visibility=='visible'){els(a).visibility='hidden'}else{els(a).visibility='visible'}}

function activeButton(buttonId){
el(lastButton).style.backgroundColor='white';
el(buttonId).style.backgroundColor='#dbedff';
lastButton=buttonId;
if(lastButton!='dropRandom'){
el('dataShowHideButton').style.display='none';
el('data').style.display='none';}
if(lastButton!='about'){el('aboutDiv').style.display='none';}
}//activeButton

window.onresize=function(){init();};


function setDataShowHideButton(){
let dataRect=el('data').getBoundingClientRect();
el('dataShowHideButton').style.right=parseInt(ww-dataRect.width-16)+'px';
el('dataShowHideButton').style.top=parseInt(dataRect.top+6)+'px';
el('dataShowHideButton').style.display='block';
//alert(el('dataShowHideButton').style.right);
}//end setDataShowHideButton

var canv=document.getElementById("canvas");
var ctx=canv.getContext('2d');
var cW,cH,ww,hh;

function init(){
ww=window.innerWidth;
hh=window.innerHeight;
canv.width=window.innerWidth;
canv.height=window.innerHeight;
cW=canv.width;
cH=canv.height;
canv.style.width=cW+"px";
canv.style.height=cH+"px";
canv.style.left=(ww/2-cW/2)+'px';

el('data').style.width=ww*.95+'px';
el('dataHeading').style.width=ww*.95+'px';
el('aboutDiv').style.width=ww*.85+'px';
el('aboutDivHeading').style.width=ww*.85+'px';
el('screenshot').style.width=ww*.85+'px';


let rect=el('buttonHolder').getBoundingClientRect();
el('shortcutKeys').style.height=parseInt(rect.top-rect.height)+'px';
el('aboutDiv').style.height=parseInt(rect.top-rect.height)+'px';

el('shortcutKeys').style.width=ww*.93+'px';
el('shortcutKeysHeading').style.width=ww*.93+'px';



el('messageHolder').style.left=ww*.5-220+'px';
el('messageHolder').style.top=hh*.23+'px';

let bhStyle=getComputedStyle(el('buttonHolder'));
let bhHeight=bhStyle.height;
el('buttonHolder').style.width=ww+'px';
el('buttonHolderInner').style.width=ww-48+'px';
//el('expander').style.bottom=parseInt(bhHeight)+20+'px';

el('fpsInputDiv').style.bottom=parseInt(bhHeight)+100+'px';
el('numVertsInputDiv').style.bottom=parseInt(bhHeight)+100+'px';

el('testerHolder').style.width=ww*.5+'px';
el('consoleInputDiv').style.width=ww*.9+'px';

cancelAnimationFrame(animId);
buildAndRender();
animInit();
getGraphFilenames();
//controlPanelOpenClose();
}//end init

init();

function controlPanelOpenClose(){
if(el('buttonHolder').style.display=='none'){
el('buttonHolder').style.display='block';
da('expander','-');
}else{
el('buttonHolder').style.display='none';
da('expander','+');
}
}//end controlPanelOpenClose


function showBools(buttonValue){
da('tester',buttonValue+'<br>numSolves:'+numSolves+'<br>foundUnsolved:'+foundUnsolved+'<br>animSV:'+animSV+'<br>pauser:'+pauser+'<br>tripleCheck:'+tripleCheck+'<br>checkCounter:'+checkCounter+'<br>stillSearching:'+stillSearching+'<br> solved:'+solved+' <br>  rColorGraphDone:'+rColorGraphDone+' <br>showSolving: '+showSolving+'<br>-----------------<br>');
el('tester').scrollTop=el('tester').scrollHeight;
}//end showBools


function getGraphFilenames(){
if(usePHP){
el('ifr').src=serverAddress+'filenameReader.php';
setTimeout(function(){
graphFileNames=JSON.parse(el('ifr').contentWindow.filenames);

numSavedGraphs=graphFileNames.length;
initSelectGraph();
},500);
}//if usePHP
}//end get graph filenames

function initSelectGraph(){
for(let i=0;i<numSavedGraphs;i++){
let op=document.createElement("option");
op.id='op'+i;
op.value=i;
op.text=graphFileNames[i];
el('selectGraph').appendChild(op);
}//end i loop
//el('op0').selected="selected";
}//end init select graph

function getGraphData(){
if(usePHP){
el('ifr').src=serverAddress+"saver.php?loading=1&dataFileName="+dataFileName;
setTimeout("loadGraphData();",500);
}//usePHP
}//end getGraphData

function loadGraphData(){
dataReceive=el('ifr').contentWindow.dataSend;
if(!isThere(dataReceive)){
getGraphData();
}else{

if(dataReceive.indexOf('[')>=0){
delaunay=false;
}

if(!delaunay){
let pairArrString=
dataReceive.substring(0,dataReceive.lastIndexOf(']')+1.);

pairArr=JSON.parse(pairArrString);
dataReceive=
dataReceive.replace(pairArrString+' ','');
}//end if !delaunay

stringArr=dataReceive.split(" ");

for(let i=0;i<stringArr.length;i+=4){
vertices.push(new Vertex(parseInt(stringArr[i]),parseInt(stringArr[i+1]),parseInt(stringArr[i+2]),parseInt(stringArr[i+3])));
if(delaunay){
triangles=triangulate(vertices);
}
}//end i loop

if(delaunay){
sortByNeighborCount();
}
//if(colorSavedGraph){colorGraph();}
render();
dataReceive='';
}//end isThere
}//end loadGraphData


function saveGraphData(){
if(usePHP){
let graphData='';
for(let i=0;i<vertices.length;i++){
graphData+=parseInt(vertices[i].x)+' '+parseInt(vertices[i].y)+' '+vertices[i].c+' '+vertices[i].i+' ';
}//end i loop

if(!delaunay){
graphData=
JSON.stringify(pairArr)+' '+graphData;
}

/*
let pairArr=[[675,89],[98,2],[8,7]];
let dataSaved=JSON.stringify(pairArr);
pairArr=JSON.parse(dataSaved);
*/


if(!el('op'+numSavedGraphs)){
graphFileNames.push(dataFileName);
el('ifr').src=serverAddress+"saver.php?graphData="+graphData+"&saving=1&dataFileName="+dataFileName;
let op=document.createElement("option");
op.id='op'+numSavedGraphs;
op.value=numSavedGraphs;
op.text=dataFileName;
el('selectGraph').appendChild(op);
numSavedGraphs++;
}//end if(!el
}//usePHP
}//end saveGraphData


function changeVertexColor(e){
if(isThere(vertices[vertexToEdit])){
vertices[vertexToEdit].c++;
if(vertices[vertexToEdit].c>3){
vertices[vertexToEdit].c=0;
}
render();
}//is There
}// end changeVertexColor


canv.onmouseup=function(e){
dragging=false;
el('expander').style.visibility='visible';
render();
vertexToEdit=-1;
}//end onmouseup



canv.onmousemove=function(e){
if(dragging){
el('expander').style.visibility='hidden';
if(moveRaw){
moveVertex(e,delaunay=false);
}else{
moveVertex(e,delaunay=true);
}
sortByNeighborCount();
render();
}
}//end onmousemove





function showSolvingActions(){
event.preventDefault();
canv.onmousedown=function(e){
showSolvingActions();}
activeButton('showSolving');
if(!showSolving&&solved&&!stepping){
reSolverReset();
for(let v=0;v<vertices.length;v++){
vertices[v].c=4;}
}//if(!showSolving&&
showSolvingButton();
}//end showSolvingActions


function solveActions(){
event.preventDefault();
canv.onmousedown=function(e){
solveActions();}
activeButton('solve');
stepping=false;
pauser=false;
showSolving=false;
streamSolving=false;
solving=true;
solveButton();
for(let v=0;v<vertices.length;v++){
vertices[v].c=4;} 
startTime=Date.now();
recursiveNeighborSolver();
}//end solveActions



function stepActions(){
event.preventDefault();
canv.onmousedown=function(e){
stepActions();}
activeButton('step');
if(!showSolving&&solved&&!stepping){
reSolverReset();
for(let v=0;v<vertices.length;v++){
vertices[v].c=4;}
}//end if(!showSolving&
solved=false;
stepping=true;
stepper();
showSolving=false;
showSolvingStatus();
}//end stepActions



canv.onmousedown=function(e){
showSolvingActions();
}



function moveVertex(e,delaunay){
if(vertexToEdit>=0){
vertices[vertexToEdit].x=e.pageX;
vertices[vertexToEdit].y=e.pageY;
ctx.clearRect(0,0,cW,cH);
if(delaunay){
triangles=triangulate(vertices);
}
render();
}
}//end moveVertex


function mouseAdd_Vertex(e){
ctx.clearRect(0,0,cW,cH);
vertices.push(new Vertex(e.pageX,e.pageY,4,vertices.length+1));
if(delaunay){
triangles=triangulate(vertices);
}
sortByNeighborCount();
render();
}//end mouseAdd_Vertex



function getVertexToEdit(e){
vertexToEdit=-1;
for(let i=0;i<vertices.length;i++){
ctx.beginPath();
ctx.arc(vertices[i].x, vertices[i].y, vertSize*2, 0, Math.PI * 2, true);
if(ctx.isPointInPath(e.pageX, e.pageY)){
vertexToEdit=i;

if(!delaunay){
if(gettingLinkStart){
linkStart=vertexToEdit;
addingVert=true;
//gettingLinkStart=false;
canv.onmousedown=function(e){
el('expander').style.visibility='hidden';
if(addingVert){
ctx.clearRect(0,0,cW,cH);
vertices.push(new Vertex(e.pageX,e.pageY,4,vertices.length));
linkEnd=vertices.length-1;
if(linkStart>=0&&linkEnd>=0){
pairArr.push([linkStart,linkEnd]);
linkStart=linkEnd;
}
sortByNeighborCount();
render();
//addingVert=false;
}
}//end function(e)

}else if(startConnecting){
addingVert=false;
linkStart=vertexToEdit;
startConnecting=false;
endConnecting=true;

}else if(endConnecting){
addingVert=false;
delaunay=false;
linkEnd=vertexToEdit;
if(linkStart>=0&&linkEnd>=0){
pairArr.push([linkStart,linkEnd]);
removeDuplicatePairs();
linkStart=linkEnd;
}
sortByNeighborCount();
render();
//endConnecting=false;
}
}//if(!delaunay

ctx.lineWidth='20';
ctx.strokeStyle=fourColor[vertices[vertexToEdit].c];
if(!endConnecting){
ctx.stroke();
}
}//ctx.isPointInPath
}//i loop
ctx.closePath();
}//end getVertexToEdit



function deleteVertex(e,delaunay){
if(vertexToEdit>=0){
vertices.splice(vertexToEdit,1);
for(let v=0;v<vertices.length;v++){
vertices[v].i=v;}

if(!delaunay){
for(let i=pairArr.length-1;i>=0;i--){
if(vertexToEdit==pairArr[i][0]||vertexToEdit==pairArr[i][1]){
pairArr.splice(i,1);
}
}//i loop
delaunay=false;
}//!delaunay

//ctx.clearRect(0,0,cW,cH);
if(delaunay){
triangles=triangulate(vertices);
}


for(let j=0;j<pairArr.length;j++){
if(pairArr[j][0]>vertexToEdit){
pairArr[j][0]--;}
if(pairArr[j][1]>vertexToEdit){
pairArr[j][1]--;}
}//j loop


sortByNeighborCount();
render();
}//>=0
}//end deleteVertex




function getVertexPairs(){
if(delaunay){
pairArr=[];
for(let i=0;i<triangles.length;i++){
pairArr.push([triangles[i].v0.i, triangles[i].v1.i]);
pairArr.push([triangles[i].v0.i, triangles[i].v2.i]);
pairArr.push([triangles[i].v1.i, triangles[i].v2.i]);
}//i loop
}//if(delaunay){

removeDuplicatePairs();
}//end getVertexPairs


//remove duplicate pairs
function removeDuplicatePairs(){
for(let i=pairArr.length-1;i>=1;i--){
for(let j=i-1;j>=0;j--){
if(isThere(pairArr[i])
&&
isThere(pairArr[j])){
if(
(pairArr[i][0]==pairArr[j][0]
&&
pairArr[i][1]==pairArr[j][1])
||
(pairArr[i][0]==pairArr[j][1]
&&
pairArr[i][1]==pairArr[j][0])
){
pairArr.splice(i,1);
}
}//end isThere
}//end j loop
}//end i loop
}//removeDuplicatePairs



function getNeighbors(){
getVertexPairs();
for(let v=0;v<vertices.length;v++){
vertices[v].n=[];
for(let i=0;i<pairArr.length;i++){
if(
v==pairArr[i][0]
){
vertices[v].n.push(pairArr[i][1]);
}else if(
v==pairArr[i][1]
){
vertices[v].n.push(pairArr[i][0]);
}
if(i==pairArr.length-1){
vertices[v].nCount=vertices[v].n.length;
}
}//end i loop
}//end v loop
}//end get neighbors



function sortByNeighborCount(){

getNeighbors();
sortedVerts=[];
for(let v=0;v<vertices.length;v++){
sortedVerts[v]={nCount:vertices[v].nCount,i:vertices[v].i,n:vertices[v].n};
}
sortedVerts.sort((a,b)=>b.nCount-a.nCount);
}//end sortByNeighborCount



function colorGraph(){
for(let v=0;v<vertices.length;v++){
vertices[v].c=4;}

for(let v=0;v<sortedVerts.length;v++){
for(let c=0;c<4;c++){
let colorAvailable=true;
for(let n=0;n<sortedVerts[v].nCount;n++){
if(isThere(vertices[sortedVerts[v].n[n]])){
if(vertices[sortedVerts[v].n[n]].c==c){
colorAvailable=false;break;
}
}//isThere
}//end n loop
if(colorAvailable){vertices[sortedVerts[v].i].c=c;break;}
}//end c loop
}//end v loop
}//end colorGraph






function solveButton(){
if(solving&&el('solve').value=='Solve'){
//el('solve').value='Solving...';
el('solve').style.backgroundColor='#ffd7d4';
}
/*
else if(!solving&&el('solve').style.backgroundColor=='#ffd7d4'){
//el('solve').value='Solve';
el('solve').style.backgroundColor='#dbedff';
}
*/

}//end solveButton



function buildRandomGraphButton(){
if(building&&el('buildRandomGraph').value=='Build Random Graph'){
el('buildRandomGraph').value='Building..........';
el('buildRandomGraph').style.backgroundColor='#ffd7d4';
}else if(!building&&el('buildRandomGraph').value=='Building..........'){
el('buildRandomGraph').value='Build Random Graph';
el('buildRandomGraph').style.backgroundColor='#dbedff';
}
}//end buildRandomGraphButton




function showSolvingButton(){
if((el('showSolving').value=='Solving...||'||el('showSolving').value=='Paused...\ > ')&&showSolving&&!stepping){
pauser=!pauser;}
stepping=false;
solving=false;
showSolving=true;
showSolvingStatus();
if(pauser){
el('showSolving').value='Paused...\ > ';
el('showSolving').style.backgroundColor='#ffd7d4';
}else if(!pauser||streamSolving){el('showSolving').value='Solving...||';}
}//end showSolvingButton



function stepper(){
showSolving=false;
recursiveNeighborSolver();
render();
}//end stepper


function showSolvingStatus(){
if(showSolving){
el('showSolving').style.backgroundColor='#dbedff';
el('showSolving').value='Solving...||';
}else{
el('showSolving').style.backgroundColor='white';
el('showSolving').value='Show Solving';
}

if(streamSolving){
el('streamSolve').style.backgroundColor='#ffd7d4';
}else{
el('streamSolve').style.backgroundColor='#ffffff';
}
}//end showSolvingStatus


var counter1=0,counter2=0,counter3=0,counter4=0;



//called once onload
function animInit(){
cancelAnimationFrame(animId);
animId=0;
stepping=false;
rColorGraphDone=false;
solved=false;
pauser=false;
animSV=0;
animate();
showSolving=true;
activeButton('showSolving');
showSolvingStatus();
//setTimeout("activeButton('showSolving');showSolvingButton();",100);
}//end animInit




function animate(){
clearTimeout(animateTimer);
animateTimer=setTimeout(function(){
animId=requestAnimationFrame(animate);

if(streamSolving&&loading){solved=false;loading=false;
buildAndRender();activeButton('showSolving');showSolvingButton();
}else if(streamSolving&&solved){solved=false;
setTimeout("buildAndRender();activeButton('showSolving');showSolvingButton();",2000);
}


if(showSolving&&!pauser&&!stepping){
recursiveNeighborSolver();
render();
}//end showSolving&&!&&pauser
},1000/framesPerSecond);//end setTimeout
}//end animate



/*
function rColorGraph(){
if(!isThere(sortedVerts[animSV])){
animSV=sortedVerts.length;
}else{

if(solved||stepping){
if(animSV==0){
rColorGraphDone=false;
for(let v=0;v<vertices.length;v++){
vertices[v].c=4;
}
}//if animSV==0
solved=false;
}//if solved

for(let c=0;c<4;c++){
let colorAvailable=true;
for(let n=0;n<sortedVerts[animSV].nCount;n++){
if(isThere(vertices[sortedVerts[animSV].n[n]])){
if(vertices[sortedVerts[animSV].n[n]].c==c){
colorAvailable=false;
break;
}
}//isThere
}//end n loop
if(colorAvailable){
vertices[sortedVerts[animSV].i].c=c;

if(animSV>=sortedVerts.length-1){
//pauser=true;
rColorGraphDone=true;
animSV=0;
}
break;
}//if colorAvailable
}//end c loop
}//isThere(sortedVerts[animSV]
}//end rColorGraph
*/






var checkCounter=0;
var foundUnsolved=false;

function recursiveNeighborSolver(){
numSolves++; 
numSolvesCounter=numSolves;

stillSearching=false;
let stringer='';
let errorString='';
checkCounter=0;

nonNeighbor=[];
for(let s=0;s<lastSearcher.length;s++){
nonNeighbor[s]=lastSearcher[s];
}
searcher=[];
lastSearcher=[];

nextVertex:
for(let v=0;v<vertices.length;v++){
let neighArray=[];
let neighColorCount=[];
let colorAvailable=[true,true,true,true];

if(vertices[v].c==4||vertices[v].searching){
stillSearching=true;


for(let n=0;n<vertices[v].nCount;n++){
if(isThere(vertices[vertices[v].n[n]])){
let nColor=vertices[vertices[v].n[n]].c;
neighArray.push({
i:vertices[v].n[n],
color:nColor
});

colorAvailable[nColor]=false;
}//isThere
}//end n loop

for(let c=0;c<4;c++){
if(colorAvailable[c]&&c!=vertices[v].c){
vertices[v].c=c;
vertices[v].searching=false;
if(showSolving||stepping){render();return;}else{
continue nextVertex;
}
}//if(colorAvailable[c]
}//end c loop

let colorCounter=[];
for(let c=0;c<4;c++){
colorCounter[c]= neighArray.filter((obj)=>obj.color==c).length;

let nIndex=neighArray.filter(x=>x.color===c).map(x=>x.i);


let isNeigh=true;
for(let nn=0;nn<nonNeighbor.length;nn++){
for(let j=0;j<nIndex.length;j++){
if(nonNeighbor[nn]==nIndex[j]){isNeigh=false;}

}//end j loop
}//end nn loop

if(isNeigh){
neighColorCount.push({
nIndex:nIndex,
color:c, 
count:colorCounter[c]
});
}//isNeigh
}//end c loop

neighColorCount.sort((a,b)=>
a.count-b.count
||
a.color-b.color);

let ind=0;
if(loopingDetected){ind=randRange(1,2);
loopCounter++;
if(loopCounter>2){
loopingDetected=false;
}
}

if(isThere(neighColorCount[ind])&&isThere(neighColorCount[ind].nIndex[0])){

vertices[v].c=vertices[neighColorCount[ind].nIndex[0]].c;


for(let j=0;j<neighColorCount[ind].nIndex.length;j++){
searcher.push(neighColorCount[ind].nIndex[j]);

}//end j loop

lastSearcher.push(vertices[v].i);


//for looping detection
for(let i=0;i<neighColorCount[0].nIndex.length;i++){
nIndexString+=neighColorCount[0].nIndex[i]+' ';
}//i loop

chunkSolveString+=vertices[v].i+' '+nIndexString;
allSolvesString+=vertices[v].i+' '+nIndexString;

solveCounter++;
if(solveCounter==2){
solveCounter=0;


let regEx=new RegExp(chunkSolveString,'g');
let matchCount=(allSolvesString.match(regEx)||[]).length;

if(matchCount>1){
loopingDetected=true;
}

chunkSolveString='';
nIndexString='';
}//end if solveCounter greater than
//end looping detection

}//isThere neighColorCount
}//end if .c==4

//solve remaining same colored pairs
if(v==vertices.length-1&&(!stillSearching||tripleCheck)){

lastSearcher=[];
foundUnsolved=false;

for(let i=0;i<pairArr.length;i++){
if(isThere(vertices[pairArr[i][0]])&&isThere(vertices[pairArr[i][1]])){
if(
(vertices[pairArr[i][0]].c==
vertices[pairArr[i][1]].c)
||
(vertices[pairArr[i][0]].c==4)
||
(vertices[pairArr[i][1]].c==4)
){

vertices[pairArr[i][0]].searching=true;
vertices[pairArr[i][1]].searching=true;
lastSearcher.push(vertices[pairArr[i][0]].i);
lastSearcher.push(vertices[pairArr[i][1]].i);
vertices[pairArr[i][0]].c=0;
vertices[pairArr[i][1]].c=0;



solveRemainingPass++;
foundUnsolved=true;

}//if same color
}//isThere
}//end i loop

if(foundUnsolved){v=0;
}else if(!tripleCheck){
v=0;
checkCounter++;
if(checkCounter>3){
tripleCheck=true;}
}//if !tripleCheck
}//if v==vertices.length-1
//end solve remaining same colored pairs

}//end v loop

for(let v=0;v<vertices.length;v++){
vertices[v].searching=false;
for(let s=0;s<searcher.length;s++){
if(searcher[s]==vertices[v].i){
vertices[v].searching=true;
}
}//end s loop

if(v==vertices.length-1){

el('tester').scrollTop=el('tester').scrollHeight;

if(stillSearching==false){ //solved
endTime=Date.now();
deltaTime=endTime-startTime;
if(showSolving||stepping){showMessage('All Solved',2000);}
if(solving){
showMessage('Solved in: '+deltaTime+' ms',2000);
solving=false;solveButton();
el('solve').style.backgroundColor='#dbedff';
}
rColorGraphDone=false;
solved=true;
animSV=0;
showSolving=false;
showSolvingStatus();
pairString='';
numSolves=0;
solveCounter=0;
chunkSolveString='';
loopingDetected=false;
nIndexString='';
solveRemainingPass=0;
tripleCheck=false;


render();
counter1=0;counter2=0;counter3=0;counter4=0;
return;
}else if(stillSearching==true){
if(numSolves==40){
animSV=0;
//rColorGraph();
}else if(numSolves==100){
//alert('still solving after numSolves:'+numSolves);
tripleCheck=false;
checkCounter=0;
}else if(numSolves>5000){
alert('still solving after numSolves:'+numSolves+' so...returning.');
return;
}

if(!showSolving&&!pauser&&!stepping){
recursiveNeighborSolver();
}
}//if stillSearching
}//if(v==vertices.length-1){
}//end v loop
}//end recursiveNeighborSolver


function showMessage(messageString,time){
el('messageHolder').style.display='block';
da('message',messageString);
messageTimer=setTimeout("el('messageHolder').style.display='none';",time);
}//end show message

function hideMessage(timerId){
clearTimeout(timerId);
el('messageHolder').style.display='none';
}//hide message


function reSolverReset(){
pairString='';
da('tester','');
numSolves=0;
solveCounter=0;
chunkSolveString='';
allSolvesString='';
loopingDetected=false;
nIndexString='';
solveRemainingPass=0;
tripleCheck=false;
checkCounter=0;
rColorGraphDone=false;
solved=false;
}//end resolver reset


function getFlexibles(){
flexibles=[];

for(let v=0;v<vertices.length;v++){
flexibles[v]={
avail:false,
i: vertices[v].i,
colorsAvailable:[]
};
if(vertices[vertices[v].i].c!=4){
let colorAvailable=[true,true,true,true];
for(let c=0;c<4;c++){
for(let n=0;n<vertices[v].nCount;n++){
if(isThere(vertices[vertices[v].n[n]])){
if(
(vertices[v].c==c)||
(vertices[vertices[v].n[n]].c==c)){
colorAvailable[c]=false;
break;//next color
}
}//isThere
}//end n loop

if(colorAvailable[c]){
flexibles[v].avail=true;
flexibles[v].colorsAvailable.push(fourColorShort[c]);
}

}//end c loop
}//!=4
}//end v loop

flexiblesCount=
flexibles.filter((obj)=>obj.avail==true).length;

}//end getFlexibles


function clamp(a,min,max){
if(a<min){a=min;}else if(a>max){a=max;}
return a;
}//end clamp

//ww=1366 hh=689 (on desktop at 100% browser zoom) 
//with onlySome
var numPoints=60;
var diam=100;
var vertSize=19;
var maxVertSize=25;
var minVertSize=16;

function graphRenderScaleFactors(){
diam=Math.sqrt(cW*cH/numPoints*.29);
vertSize=clamp(.27*diam,minVertSize,maxVertSize);
}//graphRenderScaleFactors

graphRenderScaleFactors();

function buildAndRender(){
clearTimeout(buildTimer);
vertices=[];
triangles=[];
pairArr=[];
pairString='';
//da('tester','');
numSolves=0;
solveCounter=0;
chunkSolveString='';
allSolvesString='';
loopingDetected=false;
nIndexString='';
solveRemainingPass=0;
tripleCheck=false;
rColorGraphDone=false;
solved=false;
solving=false;
showSolving=false;
linkStart=-1;
linkEnd=-1;
delaunay=true;

let radius=diam*.5;
let offset=.5*radius;
let onlySome=0;
let pointCounter=0;

if(setRandomVerts){
for(let y=radius*1.7;y<cH-radius;y+=diam){
if(pointCounter>=numPoints){break;}
for(let x=radius*1.5;x<cW-radius*1.5;x+=diam){
let randOffX=randRange(-offset,offset);
let randOffY=randRange(-offset,offset);
onlySome=randRange(1,30);
if(onlySome>20){
vertices.push(new Vertex(x+randOffX,y+randOffY,4,pointCounter,0,[],false));
pointCounter++;
triangles=triangulate(vertices);

if(pointCounter>=numPoints){break;}
}//onlySome
}//end x loop
}//end y loop


sortByNeighborCount();
if(!showSolving){
render();
}

}else if(!setRandomVerts){
getGraphData();
}

building=false;
//activeButton('buildRandomGraph');
buildRandomGraphButton();
hideMessage(messageTimer);
}// end buildAndRender



var renderCount=0;

function render(){
for(let v=0;v<vertices.length;v++){
vertices[v].i=v;}


if(showFlexibles){getFlexibles();}

//drawBackground
ctx.beginPath();
ctx.globalAlpha=1;
ctx.fillStyle='white';
ctx.fillRect(0, 0, cW, cH);
ctx.globalAlpha=1;
ctx.fillStyle=backgroundColor;//d6d651
ctx.fillRect(0, 0, cW, cH);
ctx.closePath();

//drawFrame that saves to image
ctx.globalAlpha=.4;
ctx.lineWidth=4;
ctx.strokeStyle='black';
ctx.strokeRect(0, 0, cW, cH);
ctx.lineWidth=2;
//end drawFrame


if(delaunay){
//draw triangles
ctx.globalAlpha=1;
let i=0;
triangles.forEach(function(triangle){
ctx.beginPath();
ctx.moveTo(triangle.v0.x, triangle.v0.y);
ctx.lineTo(triangle.v1.x, triangle.v1.y);
ctx.lineTo(triangle.v2.x, triangle.v2.y);
ctx.closePath();
ctx.strokeStyle="black";
ctx.lineWidth=1;
ctx.stroke();
//ctx.fillStyle='transparent';//triColors[i];
//ctx.fill();
i++;
});//end triangles foreach

}//!custom

if(!delaunay){
ctx.globalAlpha=1;



for(let i=0;i<pairArr.length;i++){
if(isThere(vertices[pairArr[i][0]])&&isThere(vertices[pairArr[i][1]])){

ctx.beginPath();

ctx.moveTo(
vertices[pairArr[i][0]].x, 
vertices[pairArr[i][0]].y);


ctx.lineTo(
vertices[pairArr[i][1]].x, vertices[pairArr[i][1]].y);

ctx.closePath();
ctx.strokeStyle='black';
ctx.lineWidth=1;
ctx.stroke();
}//isThere
}//end i loop
}//if !delaunay



//highlight same color vertices link


if(highlightSame){

sameColorVerts=[];
for(let i=0;i<pairArr.length;i++){
sameColorVerts[i]=false;
}

for(let i=0;i<pairArr.length;i++){
if(isThere(vertices[pairArr[i][0]])&&isThere(vertices[pairArr[i][1]])){
if(vertices[pairArr[i][0]].c==vertices[pairArr[i][1]].c){
sameColorVerts[i]=true;
}//end if
}//isThere
}//end i loop


for(let i=0;i<pairArr.length;i++){

if(sameColorVerts[i]){

ctx.beginPath();
ctx.moveTo(vertices[pairArr[i][0]].x, vertices[pairArr[i][0]].y);
ctx.lineTo(vertices[pairArr[i][1]].x, vertices[pairArr[i][1]].y);
ctx.closePath();
ctx.strokeStyle="black";
ctx.lineWidth=5;
ctx.stroke();

}//end if same color

}//end i loop

}//end if highlightSame

    

//draw vertices as circles
let ci=0;
this.vertices.forEach(function(vertex){
ctx.beginPath();
ctx.arc(vertex.x, vertex.y, vertSize, 0, Math.PI * 2, true);
ctx.closePath();

if(xray){
ctx.fillStyle='transparent';
}else{
ctx.fillStyle=fourColor[vertices[ci].c];
}
ctx.fill();


if(showFlexibles&&flexibles[ci].avail){
ctx.fillStyle='black';
for(let c=0;c<flexibles[ci].colorsAvailable.length;c++){
let coff=c*15;
ctx.fillText(flexibles[ci
].colorsAvailable[c],vertex.x+12+coff,vertex.y+39);
}//end c loop
ctx.strokeStyle='black';
ctx.lineWidth=9;
}else{
ctx.strokeStyle='black';
ctx.lineWidth=1;
}
ctx.stroke();



if(vertices[ci].c==4){
ctx.fillStyle='black';
}else{
ctx.fillStyle='white';
}
ctx.font="22px Monospace";
let xOff=5;
let yOff=8;
if(vertex.i>99){xOff=14;yOff=6;ctx.font="15px Monospace";}else
if(vertex.i>9){xOff=11;yOff=8;ctx.font="20px Monospace";}



if(showNumNeigh){
xOff=5;yOff=8;
ctx.fillText(vertex.nCount,vertex.x-xOff,vertex.y+yOff);
}else{
ctx.fillText(vertex.i,vertex.x-xOff,vertex.y+yOff);
}



ci++;
});//end vertices foreach

renderCount++;
}//end render




//Vertex object constructor; //returns {x:x,y:y,c:c,i:i,n:n,nCount:nCount,searching:searching}

function Vertex(x,y,c,i,n,nCount,searching){ 
this.x=x;
this.y=y;
this.c=c;//color
this.i=i;//index
this.n=n;//neighbors
this.nCount=nCount;//neighbors count
this.searching=searching;
}//end Vertex

      
//Triangle object constructor
//returns {v0:Vertex, v1:Vertex, v2:Vertex, center:Vertex, radius:number, radius_squared:number}

function Triangle(v0, v1, v2){ 
this.v0=v0;
this.v1=v1;
this.v2=v2;
//calculate circumcircle;we always do this when we build a new triangle object, so why not put it here in the constructor, instead of putting it somewhere else and calling it from here?
let A=this.v1.x - this.v0.x;
let B=this.v1.y - this.v0.y;
let C=this.v2.x - this.v0.x;
let D=this.v2.y - this.v0.y;
let E=A * (this.v0.x + this.v1.x) + B * (this.v0.y + this.v1.y);
let F=C * (this.v0.x + this.v2.x) + D * (this.v0.y + this.v2.y);
let G=2.0 * (A * (this.v2.y - this.v1.y) - B * (this.v2.x - this.v1.x));
let dx, dy;
if(Math.abs(G)<EPSILON){
let minx=Math.min(this.v0.x, this.v1.x, this.v2.x);
let miny=Math.min(this.v0.y, this.v1.y, this.v2.y);
let maxx=Math.max(this.v0.x, this.v1.x, this.v2.x);
let maxy=Math.max(this.v0.y, this.v1.y, this.v2.y);
this.center=new Vertex((minx + maxx) / 2, (miny + maxy) / 2, 4);
dx=this.center.x - minx;
dy=this.center.y - miny;
}else{
let cx=(D * E - B * F) / G;
let cy=(A * F - C * E) / G;
this.center=new Vertex(cx, cy, 4);
dx=this.center.x - this.v0.x;
dy=this.center.y - this.v0.y;
}
this.radius_squared=dx * dx + dy * dy;
this.radius=Math.sqrt(this.radius_squared);
//end calculate circumcircle;
}//end Triangle

//Edge object constructor; 
//returns {v0:Vertex,v1:vertex,equals:function,inverse:function}
function Edge(v0, v1){ 
this.v0=v0;
this.v1=v1;
this.equals=function(other){return (this.v0 === other.v0 && this.v1 === other.v1);};
this.inverse=function(){return new Edge(this.v1, this.v0);};
}//end edge


function triangulate(vertices){
pairString='';
let triangles=[];
let minx, miny, maxx, maxy;
vertices.forEach(function(vertex){
if(minx === undefined || vertex.x<minx){ minx=vertex.x;}
if(miny === undefined || vertex.y<miny){ miny=vertex.y;}
if(maxx === undefined || vertex.x > maxx){ maxx=vertex.x;}
if(maxy === undefined || vertex.y > maxy){ maxy=vertex.y;}
});
let dx=(maxx - minx) * 10;
let dy=(maxy - miny) * 10;
let stv0=new Vertex(minx - dx, miny - dy * 3, 4);
let stv1=new Vertex(minx - dx, maxy + dy, 4);
let stv2=new Vertex(maxx + dx * 3, maxy + dy, 4);
let st=new Triangle(stv0, stv1, stv2);
triangles.push(st);

let ci=0;
vertices.forEach(function(vertex){
vertex.i=ci;
ci++;

edges=[];
triangles=triangles.filter(function(triangle){
let dx=triangle.center.x - vertex.x;
let dy=triangle.center.y - vertex.y;
let dist_squared=dx * dx + dy * dy;
let inCirc=(dist_squared <= triangle.radius_squared);
if(inCirc){
edges.push(new Edge(triangle.v0, triangle.v1));
edges.push(new Edge(triangle.v1, triangle.v2));
edges.push(new Edge(triangle.v2, triangle.v0));
return false;
}else{
return true;
}
});

let uniqueEdgesArray=[];


for(let i=0;i<edges.length;++i){
let edge1=edges[i];

let unique=true;
for(let j=0;j<edges.length;++j){
if(i === j){continue;}
let edge2=edges[j];
if(edge1.equals(edge2) || edge1.inverse().equals(edge2)){unique=false;break;}
} //end j loop
if(unique){
uniqueEdgesArray.push(edge1);
}
}//end i loop
edges=uniqueEdgesArray;

edges.forEach(function(edge){
triangles.push(new Triangle(edge.v0, edge.v1, vertex));
});//end foreach edges
});//end foreach vertices


triangles=triangles.filter(function(triangle){
return !(triangle.v0 == st.v0 || triangle.v0 == st.v1 || triangle.v0 == st.v2 ||
triangle.v1 == st.v0 || triangle.v1 == st.v1 || triangle.v1 == st.v2 ||
triangle.v2 == st.v0 || triangle.v2 == st.v1 || triangle.v2 == st.v2);
});


return triangles;
}//end triangulate





function countOccurrences(arr,property,targetValue,conditionProperty, conditionValue){
return arr.reduce((count,obj)=>{
if(obj[property]===targetValue &&obj[conditionProperty]===conditionValue){
    return count+1;
    }
    return count;
  }, 0);
}



function dropRandom(){
streamSolving=false;
showSolving=false;
showSolvingStatus();

let sampleSize=5;

let sumVertCount=0;
let avgVertCount=0;

let sumFlexCount=0;
let avgFlexCount=0;

let sumVertFlexRatios=0;
let avgVertFlexRatios=0;


let sumDiffColorPairsCount=0;
let avgDiffColorPairsCount=0;

let sumSameColorPairsCount=0;
let avgSameColorPairsCount=0;

let avgDiffSamePairsRatio=0;
let sumDiffSamePairsRatio=0;

let sumPairCount=0;
let avgPairCount=0;

let sumSameFlexibleCount=0;
let avgSameFlexibleCount=0;

let sumVertsInSameColorPairCount=0;
let avgVertsInSameColorPairCount=0;

let vertsInSameColorPairCount=0;

let sumNeighsPerVertex=0;
let avgNeighsPerVertex=0;

let sumColorsPerFlexible=0;
let avgColorsPerFlexible=0;

let maxNeighs=0;
let minNeighs=1000;

for(let r=0;r<sampleSize;r++){
buildAndRender();

let sameColorPairsCount=0;
let diffColorPairsCount=0;
let neighsPerVertex=0;
let colorsPerFlexible=0;

sumVertCount+=vertices.length;
sumPairCount+=pairArr.length;

maxNeighs=0;

for(let v=0;v<vertices.length;v++){
vertices[v].c=randRange(0,3);
neighsPerVertex+=vertices[v].nCount;
if(vertices[v].nCount>maxNeighs){
maxNeighs=vertices[v].nCount;
}
if(vertices[v].nCount<minNeighs){
minNeighs=vertices[v].nCount;
}

//render();
}//end v loop

neighsPerVertex/=vertices.length;
sumNeighsPerVertex+=neighsPerVertex;

for(let j=0;j<pairArr.length;j++){
if(vertices[pairArr[j][0]].c==vertices[pairArr[j][1]].c){
vertices[pairArr[j][0]].inSameColorPair=true;
vertices[pairArr[j][1]].inSameColorPair=true;
sameColorPairsCount++;
}else{
diffColorPairsCount++;
}
}//end j loop




render();
getFlexibles();


for(let f=0;f<flexibles.length;f++){
if(flexibles[f].avail){
colorsPerFlexible+=flexibles[f].colorsAvailable.length;
}//if(flex
}//f loop
sumColorsPerFlexible+=colorsPerFlexible/flexiblesCount;

sumFlexCount+=flexiblesCount;
sumVertFlexRatios+=(vertices.length/flexiblesCount);

sumDiffSamePairsRatio+=(diffColorPairsCount/sameColorPairsCount);

sumSameColorPairsCount+=sameColorPairsCount;
sumDiffColorPairsCount+=diffColorPairsCount;

let sameFlexibleCount=countOccurrences(vertices, 'isFlexible',true,'inSameColorPair',true);
sumSameFlexibleCount+=sameFlexibleCount;




vertsInSameColorPairCount=vertices.filter((obj)=>obj.inSameColorPair==true).length;
sumVertsInSameColorPairCount+=vertsInSameColorPairCount;


}//end r loop

avgColorsPerFlexible=(sumColorsPerFlexible/sampleSize).toFixed(3);

avgNeighsPerVertex=(sumNeighsPerVertex/sampleSize).toFixed(0);

avgVertsInSameColorPairCount=(sumVertsInSameColorPairCount/sampleSize).toFixed(0);


avgSameFlexibleCount=(sumSameFlexibleCount/sampleSize).toFixed(0);

avgPairCount=(sumPairCount/sampleSize).toFixed(0);

avgSameColorPairsCount=(sumSameColorPairsCount
/sampleSize).toFixed(0);

avgDiffColorPairsCount=(sumDiffColorPairsCount
/sampleSize).toFixed(0);

avgDiffSamePairsRatio=(sumDiffSamePairsRatio/sampleSize).toFixed(2);

avgVertCount=(sumVertCount/sampleSize).toFixed(0);
avgPercentVertsInSameColorPair=((avgVertsInSameColorPairCount/avgVertCount)*100).toFixed(0);
avgFlexCount=(sumFlexCount/sampleSize).toFixed(0);
avgVertFlexRatio=(sumVertFlexRatios/sampleSize).toFixed(2);

let avgVertPairPercent=((avgVertCount/avgPairCount)*100).toFixed(0);
let avgVertPairRatio=(avgVertCount/avgPairCount).toFixed(2);
let avgPairsPerVertex=(avgPairCount/avgVertCount).toFixed(2)

el('data').style.display='block';

let dat=[
[`number of graphs sampled:`,sampleSize], 
[`avg # vertices:`,avgVertCount],
[`avg # pairs:`,avgPairCount],
['avg ratio pairs/verts:',avgPairsPerVertex+` x more pairs`],
['avg ratio verts/pairs:',avgVertPairRatio+' ('+avgVertPairPercent+'% of pairs)'],
['avg neighbors per vertex, max, min:',avgNeighsPerVertex+', '+maxNeighs+', '+minNeighs],
[`avg # flexibles:`,avgFlexCount],
[`avg ratio flexibles/vertices:`,
(1/avgVertFlexRatio).toFixed(2)+` (`+((1/avgVertFlexRatio)*100).toFixed(0)+`% of verts)`],
[`avg ratio vertices/flexibles:`,avgVertFlexRatio+` x more verts`],
[`avg # different color pairs:`,avgDiffColorPairsCount],
[`avg # same color pairs:`,avgSameColorPairsCount],
[`avg ratio diff/same pairs:`,avgDiffSamePairsRatio+` times more diff`],
[`avg ratio same/diff pairs:`,(1/avgDiffSamePairsRatio).toFixed(2)+` (`+((1/avgDiffSamePairsRatio)*100).toFixed(0)+`% of same)`],
[`avg % of pairs which are different colors:`,((avgDiffColorPairsCount/avgPairCount)*100).toFixed(0)+`%`],
[`avg % of pairs which are same colors:`,((avgSameColorPairsCount/avgPairCount)*100).toFixed(0)+`%`],
[`avg # verts in at least one same color pair:`,avgVertsInSameColorPairCount+` (`+avgPercentVertsInSameColorPair+`% of all verts)`],
[`avg # flexible verts in same color pairs:`,avgSameFlexibleCount+` (`+((avgSameFlexibleCount/avgFlexCount)*100).toFixed(0)+`% of all flexibles)`],
[`avg % verts in same color pairs which are flexible:`,((avgSameFlexibleCount/avgVertsInSameColorPairCount)*100).toFixed(0)+`%`],
[`avg # alternate colors per flexible:`,avgColorsPerFlexible]
];


let stringer2=`<table style="width:100%;"`;
for(let d=0;d<dat.length;d++){
stringer2+=
`<tr><td class="t2">`+
dat[d][0]
+`</td><td class="t">`+
dat[d][1]
;
}//end d loop
stringer2+=`</td></tr></table>`;

da('tableId',stringer2);
activeButton('dropRandom');
setTimeout('setDataShowHideButton();',100);
hideMessage('messageTimer');
}//dropRandom





//document.body.onload=function(){init();}

document.body.onkeydown=function(){onKeyDowner(event);}


onKeyDowner=function(event){
if(!typing){
switch(event.key){
case 'w':
toggleFullScreen();
break;
case 'k':
showHide('shortcutKeys');
break;
case ' ':
canv.click();
//buildAndRender();
//activeButton('showSolving');
showSolvingButton();showSolvingButton();
case 'p':
activeButton('showSolving');showSolvingButton();
break;
case 's':
solveActions();
break;
case 'v': 
activeButton('step');solved=false;stepping=true;stepper();showSolving=false;showSolvingStatus();
break;
case 'b':
activeButton('buildRandomGraph');building=true;buildRandomGraphButton();setRandomVerts=true;clearTimeout(buildTimer);buildTimer=setTimeout('buildAndRender();',50);canv.onmousedown=function(e){setRandomVerts=true;buildAndRender();};
break;
case 'h':controlPanelOpenClose();
break;
case 'a':
activeButton('addVertex');canv.onmousedown=function(e){delaunay=true;mouseAdd_Vertex(e);solved=false;}
break;
case 'm':
activeButton('moveVertex');canv.onmousedown=function(e){el('expander').style.visibility='hidden';dragging=true;moveRaw=false;getVertexToEdit(e);solved=false;}
break;
case 'd':
activeButton('deleteVertex');canv.onmousedown=function(e){getVertexToEdit(e);deleteVertex(e,true);solved=false;}
break;
case 'c':
activeButton('colorVerts');canv.onmousedown=function(e){getVertexToEdit(e);changeVertexColor(e);solved=false;}
break;
case 'y':
activeButton('testerButton');showHide('testerHolder');el('tester').scrollTop=el('tester').scrollHeight;
break;
case 'n':
activeButton('numberOfVerts');el('enterNumVerts').value=numPoints;showHideV('numVertsInputDiv');
break;
case 'f':
activeButton('fpsId');el('enterFPS').value=parseInt(framesPerSecond);showHideV('fpsInputDiv');
break;
case 't':
activeButton('timeToSolveId');showMessage('Solved in: '+deltaTime+' ms<br> after '+ numSolvesCounter+' steps',2000);
break;
case 'g':
activeButton('neighs');if(showNumNeigh){showNumNeigh=false;}else{showNumNeigh=true;}render();
break;
case 'x':
activeButton('flexiblesButton');showFlexibles=!showFlexibles;render();
break;j
case 'o':
activeButton('consoleButton');showHideV('consoleInputDiv');render();
break;
case '1':
activeButton('addButton');gettingLinkStart=false;delaunay=false;canv.onmousedown=function(e){el('expander').style.visibility='hidden';mouseAdd_Vertex(e);solved=false;}
break;
case '2':
activeButton('addLinkedButton');delaunay=false;gettingLinkStart=true;canv.onmousedown=function(e){el('expander').style.visibility='hidden';getVertexToEdit(e);solved=false;}
break;
case '3':
activeButton('linkVertsButton');gettingLinkStart=false;startConnecting=true;delaunay=false;canv.onmousedown=function(e){el('expander').style.visibility='hidden';getVertexToEdit(e);solved=false;}
break;
case '4':
activeButton('moveVertButton');canv.onmousedown=function(e){el('expander').style.visibility='hidden';dragging=true;moveRaw=true;getVertexToEdit(e);solved=false;}
break;
case '5':
activeButton('deleteVertButton');canv.onmousedown=function(e){delaunay=false;getVertexToEdit(e);deleteVertex(e,false);solved=false;}
break;
}//end switch
}//end if(!typing){
}//end onKeyDowner


function isFullScreen(){
return (document.fullScreenElement && document.fullScreenElement !== null)
|| document.mozFullScreen
|| document.webkitIsFullScreen;
}//end is full screen

function requestFullScreen(){
var el=document.documentElement;
var rfs=el.requestFullscreen
|| el.webkitRequestFullScreen
|| el.mozRequestFullScreen
|| el.msRequestFullscreen;
rfs.call(el);
}//end request full screen 

function exitFullScreen(){
var d=document;
var rfs=d.exitFullscreen
|| d.webkitExitFullscreen
|| d.mozCancelFullScreen
|| d.msExitFullscreen ;
rfs.call(d);
}//end exit fullscreen

function toggleFullScreen(){
if(isFullScreen()){exitFullScreen();
}else{requestFullScreen();
}
}//end toggle full screen


</script>

</body>
</html>